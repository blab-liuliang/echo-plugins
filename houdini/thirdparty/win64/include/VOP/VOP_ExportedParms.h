/*
 * PROPRIETARY INFORMATION.  This software is proprietary to
 * Side Effects Software Inc., and is not to be reproduced,
 * transmitted, or disclosed in any way without written permission.
 *
 * NAME:	VOP_ExportedParms.h (VOP Library, C++)
 *
 * COMMENTS:
 *
 *		Exported parameters generated by VOP_ParmGenerator objects.
 */

#ifndef __VOP_ExportedParms_h__
#define __VOP_ExportedParms_h__

#include "VOP_API.h"

#include "VOP_ParmGenerator.h"

#include <OP/OP_Node.h>
#include <UT/UT_Array.h>
#include <UT/UT_Map.h>
#include <UT/UT_StringHolder.h>

class VOP_API VOP_ExportedParm
{
public:
    typedef enum {
	ENDGROUP,
	STARTGROUP,
	ENTRY
    } VOP_ExportedParmType;

    VOP_ExportedParm()
	: myType(ENDGROUP), myNodeId(OP_INVALID_NODE_ID) { }
    VOP_ExportedParm(const char *groupname)
	: myType(STARTGROUP), myName(groupname), 
	  myNodeId(OP_INVALID_NODE_ID) 
	{ }
    VOP_ExportedParm(VOP_ParmGenerator *vop)
	: myType(ENTRY), myNodeId(vop->getUniqueId()) { 
	    myName = vop->getParmNameCache();
	}
    VOP_ExportedParm(const VOP_ExportedParm &src) = default;

    VOP_ExportedParmType	 getType() const
			 { return myType; }
    const char		*getName() const
			 { return myName.c_str(); }
    void		 setName(const char *name)
			 { myName = name; }
    VOP_ParmGenerator	*getOp() const
			 { 
			     OP_Node *node = OP_Node::lookupNode(myNodeId);
			     if (!node)
				 return NULL;

			     return VOP_Node::castToParmGenerator(node); 
			 }
    int			 getOpId() const
			 { return myNodeId; }

    bool operator==(const VOP_ExportedParm &o) const
    { return myType == o.myType && myName == o.myName && myNodeId == o.myNodeId; }

    bool operator!=(const VOP_ExportedParm &o) const
    { return myType != o.myType || myName != o.myName || myNodeId != o.myNodeId; }

private:
    VOP_ExportedParmType	 myType;
    UT_StringHolder	 myName;
    int			 myNodeId;
};

class VOP_ExportedParmList
{
public:
			 VOP_ExportedParmList()
			 { }
			 VOP_ExportedParmList(const VOP_ExportedParmList &src_list)
			 {	
			    clear();

			    int i;
			    for (i=0; i<src_list.entries(); i++)
				append(src_list(i));
			 }
			~VOP_ExportedParmList()
			 { clear(); }

    const VOP_ExportedParmList	&operator=(const VOP_ExportedParmList &src)
				{
				    if (&src != this)
				    {
					int		i;
					clear();
					for (i=0; i<src.entries(); i++)
					    append(src(i));
				    }
				    return *this;
				}
    bool		 operator==(const VOP_ExportedParmList &src) const
			 {
			     int		i;
			     if (entries() != src.entries())
				 return false;
			     for (i = 0; i < entries(); ++i)
				 if ((*this)(i) != src(i))
				     return false;
			     return true;
			 }
    bool		 operator!=(const VOP_ExportedParmList &s) const
			    { return !(*this == s); }

    void		 append(const VOP_ExportedParm &parm)
			 {
			     VOP_ExportedParm *new_parm;
			     new_parm = new VOP_ExportedParm(parm);

			     myParms.append(new_parm);
			     myParmNodes[new_parm->getOpId()] = new_parm;
			 }
    void		 insert(const VOP_ExportedParm &parm, int idx)
			 {
			     VOP_ExportedParm *new_parm;
			     new_parm = new VOP_ExportedParm(parm);

			     myParms.insert(new_parm, idx);
			     myParmNodes[new_parm->getOpId()] = new_parm;
			 }
    void		 move(int first, int last, int newpos)
			 {
			     myParms.move(first, last, newpos);
			 }
    void		 remove(int idx)
			 {
			     VOP_ExportedParm   *parm;
			     int	     node_id;

			     node_id = myParms(idx)->getOpId();
			     parm = myParms(idx);

			     myParms.removeIndex(idx);
			     myParmNodes.erase(node_id);
			     delete parm;
			 }
    void		 clear()
			 {
			     UTdeleteAll(myParms);
			     myParms.clear();
			     myParmNodes.clear();
			 }

    /// Return the list index of the requested parameter.
    /// Return -1 if no parameter with the name equal to `parm_name`
    /// can be found in the list.
    int			 getParmIndex(const char *parm_name) const
			 {
			     if (!parm_name)
				 return -1;

			     for (int i=0; i<myParms.entries(); i++)
			     {
				 const char *code_parm_name;
				 code_parm_name = myParms(i)->getName();
				if (!code_parm_name)
				    continue;

				 if (::strcmp(code_parm_name, parm_name) == 0)
				     return i;
			     }

			     return -1;
			 }

    /// Return the name of the parameter generated by the given node.
    /// If no such parameter exists, then return NULL.
    const char		*getParmName(int node_id) const
			 {
			    auto it = myParmNodes.find(node_id);
			    if (it == myParmNodes.end())
				return nullptr;
			    
			    return it->second->getName();
			 }

    const VOP_ExportedParm	&operator()(int idx) const
			 {
			     return *myParms(idx);
			 }
    VOP_ExportedParm	&operator()(int idx)
			 {
			     return *myParms(idx);
			 }
    int			 entries() const
			 {
			     return myParms.entries();
			 }
    bool		 hasNode(int node_id) const
			 {
			     return myParmNodes.contains(node_id);
			 }
    bool		 hasParmName(const char *parm_name) const
			 {
			    if (!parm_name)
				return false;

			    for (int i=0; i<myParms.entries(); i++)
			    {
				const char *code_parm_name;
				code_parm_name = myParms(i)->getName();
				if (!code_parm_name)
				    continue;

				if (::strcmp(code_parm_name, parm_name) == 0)
				    return true;
			    }

			    return false;
			 }



private:
    UT_Array<VOP_ExportedParm*> myParms;
    UT_Map<int, VOP_ExportedParm *> myParmNodes;
};

#endif
