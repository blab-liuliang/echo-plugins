/*
 * PROPRIETARY INFORMATION.  This software is proprietary to
 * Side Effects Software Inc., and is not to be reproduced,
 * transmitted, or disclosed in any way without written permission.
 *
 * NAME:	UT_NoiseBasis.h ( UT Library, C++)
 *
 * COMMENTS:	Low level noise generation using cellular basis functions
 *		This is based off:  "A Cellular Texture Basis Function",
 *		Siggraph 1996, pg. 291.  It can provide noise similar to
 *		alligator noise (which was developed independently).
 *
 * NOTES:	This noise type can be considered a super-set of alligator and
 *		sparse convolution noise.  Alligator noise is created using a
 *		simple linear combination of (1-F(0)) - (1-F(3)) or something
 *		to that effect.  Sparse convolution on the other hand can be
 *		generated by:
 *			sum(.5*cos(F(i)*FACTOR)+.5)
 */

#ifndef __UT_NoiseBasis__
#define __UT_NoiseBasis__

#include "UT_API.h"
#include <SYS/SYS_Types.h>

class UT_API UT_NoiseValue {
public:
    union {
	float		myDistance;
	int		myIDistance;		// Used internally
    };
    uint		mySeed;
};

enum class UT_NoiseBasisMetric
{
    Euclidean,
    Manhattan,
    Chebyshev
};

template <UT_NoiseBasisMetric METRIC=UT_NoiseBasisMetric::Euclidean>
class UT_API UT_NoiseBasis
{
public:
    static void		initNoise();

    // Voronoi noise (Euclidean distance metric)
    static void	noise1D(float pos, UT_NoiseValue vals[], int nvals);
    static void	noise2D(const fpreal32 pos[2], UT_NoiseValue vals[], int nvals);
    static void	noise2D(const fpreal64 pos[2], UT_NoiseValue vals[], int nvals);
    static void	noise3D(const fpreal32 pos[3], UT_NoiseValue vals[], int nvals);
    static void	noise3D(const fpreal64 pos[3], UT_NoiseValue vals[], int nvals);
    static void	noise4D(const fpreal32 pos[4], UT_NoiseValue vals[], int nvals);
    static void	noise4D(const fpreal64 pos[4], UT_NoiseValue vals[], int nvals);
    static void	noise1D(float pos, UT_NoiseValue vals[], int nvals, uint period);
    static void	noise2D(const fpreal32 pos[2], UT_NoiseValue vals[], int nvals,
				uint periodx, uint periody);
    static void	noise2D(const fpreal64 pos[2], UT_NoiseValue vals[], int nvals,
				uint periodx, uint periody);
    static void	noise3D(const fpreal32 pos[3], UT_NoiseValue vals[], int nvals,
				uint periodx, uint periody, uint periodz);
    static void	noise3D(const fpreal64 pos[3], UT_NoiseValue vals[], int nvals,
				uint periodx, uint periody, uint periodz);
    static void	noise4D(const fpreal32 pos[4], UT_NoiseValue vals[], int nvals,
			uint periodx, uint periody, uint periodz, uint periodw);
    static void	noise4D(const fpreal64 pos[4], UT_NoiseValue vals[], int nvals,
			uint periodx, uint periody, uint periodz, uint periodw);

    // For periodic noise, the period should contain dimension values (one for
    // each dimension)
    template <typename T>
    static inline void	noise2D(const T pos[2], UT_NoiseValue vals[],
				int nvals, const uint period[2])
			    { noise2D(pos, vals, nvals, period[0], period[1]); }
    template <typename T>
    static inline void	noise3D(const T pos[3], UT_NoiseValue vals[],
				int nvals, const uint period[3])
			{
			    noise3D(pos, vals, nvals, period[0], period[1],
						      period[2]);
			}
    template <typename T>
    static inline void	noise4D(const T pos[4], UT_NoiseValue vals[],
				int nvals, const uint period[4])
			{
			    noise4D(pos, vals, nvals, period[0], period[1],
						      period[2], period[3]);
			}

    // Voronoi noise with jitter (Euclidean distance metric)
    static void	noise1D(const fpreal32 P[1],
			const fpreal32 *jitter, int32 *period,
			int32 &seed, fpreal32 &f1, fpreal32 &f2,
			fpreal32 p0[1], fpreal32 p1[1]);
    static void noise2D(const fpreal32 P[2],
			const fpreal32 *jitter, int32 *period,
			int32 &seed, fpreal32 &f1, fpreal32 &f2,
			fpreal32 p0[2], fpreal32 p1[2]);
    static void	noise3D(const fpreal32 P[3],
			const fpreal32 *jitter, int32 *period,
			int32 &seed, fpreal32 &f1, fpreal32 &f2,
			fpreal32 p0[3], fpreal32 p1[3]);
    static void	noise4D(const fpreal32 P[4],
			const fpreal32 *jitter, int32 *period,
			int32 &seed, fpreal32 &f1, fpreal32 &f2,
			fpreal32 p0[4], fpreal32 p1[4]);

    static void	noise1D(const fpreal64 P[1],
			const fpreal64 *jitter, int64 *period,
			int64 &seed, fpreal64 &f1, fpreal64 &f2,
			fpreal64 p0[1], fpreal64 p1[1]);
    static void noise2D(const fpreal64 P[2],
			const fpreal64 *jitter, int64 *period,
			int64 &seed, fpreal64 &f1, fpreal64 &f2,
			fpreal64 p0[2], fpreal64 p1[2]);
    static void	noise3D(const fpreal64 P[3],
			const fpreal64 *jitter, int64 *period,
			int64 &seed, fpreal64 &f1, fpreal64 &f2,
			fpreal64 p0[3], fpreal64 p1[3]);
    static void	noise4D(const fpreal64 P[4],
			const fpreal64 *jitter, int64 *period,
			int64 &seed, fpreal64 &f1, fpreal64 &f2,
			fpreal64 p0[4], fpreal64 p1[4]);
private:
};

#endif
