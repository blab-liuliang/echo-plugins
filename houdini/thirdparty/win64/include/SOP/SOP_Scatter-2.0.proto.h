/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_Scatter_2_0Enums
{
    enum class GenerateBy
    {
        BYDENSITY = 0,
        COUNTPERPRIMITIVE,
        TEXTURESPACE
    };
}


class SOP_API SOP_Scatter_2_0Parms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_Scatter_2_0Parms()
    {
        myGroup = ""_sh;
        myGenerateBy = 0;
        myUseDensityAttrib = false;
        myDensityAttrib = "density"_sh;
        myUseAreaAttrib = false;
        myAreaAttrib = "area"_sh;
        myIndepVoxel = false;
        myForceTotal = false;
        myNpts = 1000;
        myUseDensityTexture = false;
        myDensityTexture = "default.pic"_sh;
        myCountPerPrimAttrib = "count"_sh;
        myUseEmergencyLimit = false;
        myEmergencyLimit = 1e+06;
        mySeed = 0;
        myOverridePrimSeed = false;
        myPrimSeedAttrib = "primid"_sh;
        myRandomizeOrder = false;
        myRelaxPoints = false;
        myRelaxIterations = 10;
        myUsePrimNumAttrib = false;
        myPrimNumAttrib = "sourceprim"_sh;
        myUsePrimUVWAttrib = false;
        myPrimUVWAttrib = "sourceprimuv"_sh;
        myUseOutputDensityAttrib = false;
        myOutputDensityAttrib = "density"_sh;
        myUseOutputRadiusAttrib = false;
        myOutputRadiusAttrib = "pscale"_sh;
        myRadiusInTextureSpace = false;
        myPointAttribs = "*"_sh;
        myVertAttribs = ""_sh;
        myPrimAttribs = ""_sh;
        myDetailAttribs = ""_sh;
        myDensityScale = 10;
        myUseAreaForVolumes = false;
        myScaleRadiiBy = 1;
        myUseMaxRadius = false;
        myMaxRadius = 10;

    }

    explicit SOP_Scatter_2_0Parms(const SOP_Scatter_2_0Parms &) = default;

    virtual ~SOP_Scatter_2_0Parms() {}

    bool operator==(const SOP_Scatter_2_0Parms &src) const
    {
        if (myGroup != src.myGroup) return false;
        if (myGenerateBy != src.myGenerateBy) return false;
        if (myUseDensityAttrib != src.myUseDensityAttrib) return false;
        if (myDensityAttrib != src.myDensityAttrib) return false;
        if (myUseAreaAttrib != src.myUseAreaAttrib) return false;
        if (myAreaAttrib != src.myAreaAttrib) return false;
        if (myIndepVoxel != src.myIndepVoxel) return false;
        if (myForceTotal != src.myForceTotal) return false;
        if (myNpts != src.myNpts) return false;
        if (myUseDensityTexture != src.myUseDensityTexture) return false;
        if (myDensityTexture != src.myDensityTexture) return false;
        if (myCountPerPrimAttrib != src.myCountPerPrimAttrib) return false;
        if (myUseEmergencyLimit != src.myUseEmergencyLimit) return false;
        if (myEmergencyLimit != src.myEmergencyLimit) return false;
        if (mySeed != src.mySeed) return false;
        if (myOverridePrimSeed != src.myOverridePrimSeed) return false;
        if (myPrimSeedAttrib != src.myPrimSeedAttrib) return false;
        if (myRandomizeOrder != src.myRandomizeOrder) return false;
        if (myRelaxPoints != src.myRelaxPoints) return false;
        if (myRelaxIterations != src.myRelaxIterations) return false;
        if (myUsePrimNumAttrib != src.myUsePrimNumAttrib) return false;
        if (myPrimNumAttrib != src.myPrimNumAttrib) return false;
        if (myUsePrimUVWAttrib != src.myUsePrimUVWAttrib) return false;
        if (myPrimUVWAttrib != src.myPrimUVWAttrib) return false;
        if (myUseOutputDensityAttrib != src.myUseOutputDensityAttrib) return false;
        if (myOutputDensityAttrib != src.myOutputDensityAttrib) return false;
        if (myUseOutputRadiusAttrib != src.myUseOutputRadiusAttrib) return false;
        if (myOutputRadiusAttrib != src.myOutputRadiusAttrib) return false;
        if (myRadiusInTextureSpace != src.myRadiusInTextureSpace) return false;
        if (myPointAttribs != src.myPointAttribs) return false;
        if (myVertAttribs != src.myVertAttribs) return false;
        if (myPrimAttribs != src.myPrimAttribs) return false;
        if (myDetailAttribs != src.myDetailAttribs) return false;
        if (myDensityScale != src.myDensityScale) return false;
        if (myUseAreaForVolumes != src.myUseAreaForVolumes) return false;
        if (myScaleRadiiBy != src.myScaleRadiiBy) return false;
        if (myUseMaxRadius != src.myUseMaxRadius) return false;
        if (myMaxRadius != src.myMaxRadius) return false;

        return true;
    }
    bool operator!=(const SOP_Scatter_2_0Parms &src) const
    {
        return !operator==(src);
    }
    using GenerateBy = SOP_Scatter_2_0Enums::GenerateBy;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myGroup, node, "group", time, 0);
        else myGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myGenerateBy, node, "generateby", time, 0);
        else myGenerateBy = 0;
        if (true && ( (!(((int64(getGenerateBy())!=0)))) ) )
            OP_Utils::evalOpParm(myUseDensityAttrib, node, "usedensityattrib", time, 0);
        else myUseDensityAttrib = false;
        if (true && ( (!(((int64(getGenerateBy())!=0))||((getUseDensityAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myDensityAttrib, node, "densityattrib", time, 0);
        else myDensityAttrib = "density"_sh;
        if (true && ( (!(((int64(getGenerateBy())!=0)))) ) )
            OP_Utils::evalOpParm(myUseAreaAttrib, node, "useareaattrib", time, 0);
        else myUseAreaAttrib = false;
        if (true && ( (!(((int64(getGenerateBy())!=0))||((getUseAreaAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myAreaAttrib, node, "areaattrib", time, 0);
        else myAreaAttrib = "area"_sh;
        if (true && ( (!(((int64(getGenerateBy())!=0)))) ) )
            OP_Utils::evalOpParm(myIndepVoxel, node, "indepvoxel", time, 0);
        else myIndepVoxel = false;
        if (true && ( (!(((int64(getGenerateBy())!=0))||((getIndepVoxel()==1)))) ) )
            OP_Utils::evalOpParm(myForceTotal, node, "forcetotal", time, 0);
        else myForceTotal = false;
        if (true && ( (!(((int64(getGenerateBy())!=0))||((getForceTotal()==0))||((getIndepVoxel()==1)))) ) )
            OP_Utils::evalOpParm(myNpts, node, "npts", time, 0);
        else myNpts = 1000;
        if (true && ( (!(((int64(getGenerateBy())!=2)))) ) )
            OP_Utils::evalOpParm(myUseDensityTexture, node, "usedensitytexture", time, 0);
        else myUseDensityTexture = false;
        if (true && ( (!(((int64(getGenerateBy())!=2))||((getUseDensityTexture()==0)))) ) )
            OP_Utils::evalOpParm(myDensityTexture, node, "densitytexture", time, 0);
        else myDensityTexture = "default.pic"_sh;
        if (true && ( (!(((int64(getGenerateBy())!=1)))) ) )
            OP_Utils::evalOpParm(myCountPerPrimAttrib, node, "primcountattrib", time, 0);
        else myCountPerPrimAttrib = "count"_sh;
        if (true)
            OP_Utils::evalOpParm(myUseEmergencyLimit, node, "useemergencylimit", time, 0);
        else myUseEmergencyLimit = false;
        if (true && ( (!(((getUseEmergencyLimit()==0)))) ) )
            OP_Utils::evalOpParm(myEmergencyLimit, node, "emergencylimit", time, 0);
        else myEmergencyLimit = 1e+06;
        if (true)
            OP_Utils::evalOpParm(mySeed, node, "seed", time, 0);
        else mySeed = 0;
        if (true && ( (!(((int64(getGenerateBy())==2)))) ) )
            OP_Utils::evalOpParm(myOverridePrimSeed, node, "overrideprimseed", time, 0);
        else myOverridePrimSeed = false;
        if (true && ( (!(((int64(getGenerateBy())==2))||((getOverridePrimSeed()==0)))) ) )
            OP_Utils::evalOpParm(myPrimSeedAttrib, node, "primseedattrib", time, 0);
        else myPrimSeedAttrib = "primid"_sh;
        if (true)
            OP_Utils::evalOpParm(myRandomizeOrder, node, "randomizeorder", time, 0);
        else myRandomizeOrder = false;
        if (true)
            OP_Utils::evalOpParm(myRelaxPoints, node, "relaxpoints", time, 0);
        else myRelaxPoints = false;
        if (true && ( (!(((getRelaxPoints()==0)))) ) )
            OP_Utils::evalOpParm(myRelaxIterations, node, "relaxiterations", time, 0);
        else myRelaxIterations = 10;
        if (true)
            OP_Utils::evalOpParm(myUsePrimNumAttrib, node, "useprimnumattrib", time, 0);
        else myUsePrimNumAttrib = false;
        if (true && ( (!(((getUsePrimNumAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myPrimNumAttrib, node, "primnumattrib", time, 0);
        else myPrimNumAttrib = "sourceprim"_sh;
        if (true)
            OP_Utils::evalOpParm(myUsePrimUVWAttrib, node, "useprimuvwattrib", time, 0);
        else myUsePrimUVWAttrib = false;
        if (true && ( (!(((getUsePrimUVWAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myPrimUVWAttrib, node, "primuvwattrib", time, 0);
        else myPrimUVWAttrib = "sourceprimuv"_sh;
        if (true)
            OP_Utils::evalOpParm(myUseOutputDensityAttrib, node, "useoutputdensityattrib", time, 0);
        else myUseOutputDensityAttrib = false;
        if (true && ( (!(((getUseOutputDensityAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myOutputDensityAttrib, node, "outputdensityattrib", time, 0);
        else myOutputDensityAttrib = "density"_sh;
        if (true)
            OP_Utils::evalOpParm(myUseOutputRadiusAttrib, node, "useoutputradiusattrib", time, 0);
        else myUseOutputRadiusAttrib = false;
        if (true && ( (!(((getUseOutputRadiusAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myOutputRadiusAttrib, node, "outputradiusattrib", time, 0);
        else myOutputRadiusAttrib = "pscale"_sh;
        if (true && ( (!(((int64(getGenerateBy())!=2))||((getUseOutputRadiusAttrib()==0)&&(getUseOutputDensityAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myRadiusInTextureSpace, node, "radiusintexturespace", time, 0);
        else myRadiusInTextureSpace = false;
        if (true)
            OP_Utils::evalOpParm(myPointAttribs, node, "pointattribs", time, 0);
        else myPointAttribs = "*"_sh;
        if (true)
            OP_Utils::evalOpParm(myVertAttribs, node, "vertattribs", time, 0);
        else myVertAttribs = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myPrimAttribs, node, "primattribs", time, 0);
        else myPrimAttribs = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myDetailAttribs, node, "detailattribs", time, 0);
        else myDetailAttribs = ""_sh;
        if (true && ( (!(((int64(getGenerateBy())==1))||((int64(getGenerateBy())==0)&&(getForceTotal()==1)&&(getIndepVoxel()==0)))) ) )
            OP_Utils::evalOpParm(myDensityScale, node, "densityscale", time, 0);
        else myDensityScale = 10;
        if (true && ( (!(((int64(getGenerateBy())!=0))||((getForceTotal()==1)&&(getIndepVoxel()==0)))) ) )
            OP_Utils::evalOpParm(myUseAreaForVolumes, node, "useareaforvolumes", time, 0);
        else myUseAreaForVolumes = false;
        if (true && ( (!(((getRelaxPoints()==0)&&(getUseOutputRadiusAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myScaleRadiiBy, node, "scaleradiiby", time, 0);
        else myScaleRadiiBy = 1;
        if (true && ( (!(((getRelaxPoints()==0)&&(getUseOutputRadiusAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myUseMaxRadius, node, "usemaxradius", time, 0);
        else myUseMaxRadius = false;
        if (true && ( (!(((getRelaxPoints()==0)&&(getUseOutputRadiusAttrib()==0))||((getUseMaxRadius()==0)))) ) )
            OP_Utils::evalOpParm(myMaxRadius, node, "maxradius", time, 0);
        else myMaxRadius = 10;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_Scatter_2_0Parms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myGroup);
                break;
            case 1:
                coerceValue(value, myGenerateBy);
                break;
            case 2:
                coerceValue(value, myUseDensityAttrib);
                break;
            case 3:
                coerceValue(value, myDensityAttrib);
                break;
            case 4:
                coerceValue(value, myUseAreaAttrib);
                break;
            case 5:
                coerceValue(value, myAreaAttrib);
                break;
            case 6:
                coerceValue(value, myIndepVoxel);
                break;
            case 7:
                coerceValue(value, myForceTotal);
                break;
            case 8:
                coerceValue(value, myNpts);
                break;
            case 9:
                coerceValue(value, myUseDensityTexture);
                break;
            case 10:
                coerceValue(value, myDensityTexture);
                break;
            case 11:
                coerceValue(value, myCountPerPrimAttrib);
                break;
            case 12:
                coerceValue(value, myUseEmergencyLimit);
                break;
            case 13:
                coerceValue(value, myEmergencyLimit);
                break;
            case 14:
                coerceValue(value, mySeed);
                break;
            case 15:
                coerceValue(value, myOverridePrimSeed);
                break;
            case 16:
                coerceValue(value, myPrimSeedAttrib);
                break;
            case 17:
                coerceValue(value, myRandomizeOrder);
                break;
            case 18:
                coerceValue(value, myRelaxPoints);
                break;
            case 19:
                coerceValue(value, myRelaxIterations);
                break;
            case 20:
                coerceValue(value, myUsePrimNumAttrib);
                break;
            case 21:
                coerceValue(value, myPrimNumAttrib);
                break;
            case 22:
                coerceValue(value, myUsePrimUVWAttrib);
                break;
            case 23:
                coerceValue(value, myPrimUVWAttrib);
                break;
            case 24:
                coerceValue(value, myUseOutputDensityAttrib);
                break;
            case 25:
                coerceValue(value, myOutputDensityAttrib);
                break;
            case 26:
                coerceValue(value, myUseOutputRadiusAttrib);
                break;
            case 27:
                coerceValue(value, myOutputRadiusAttrib);
                break;
            case 28:
                coerceValue(value, myRadiusInTextureSpace);
                break;
            case 29:
                coerceValue(value, myPointAttribs);
                break;
            case 30:
                coerceValue(value, myVertAttribs);
                break;
            case 31:
                coerceValue(value, myPrimAttribs);
                break;
            case 32:
                coerceValue(value, myDetailAttribs);
                break;
            case 33:
                coerceValue(value, myDensityScale);
                break;
            case 34:
                coerceValue(value, myUseAreaForVolumes);
                break;
            case 35:
                coerceValue(value, myScaleRadiiBy);
                break;
            case 36:
                coerceValue(value, myUseMaxRadius);
                break;
            case 37:
                coerceValue(value, myMaxRadius);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myGroup, value);
                break;
            case 1:
                coerceValue(myGenerateBy, value);
                break;
            case 2:
                coerceValue(myUseDensityAttrib, value);
                break;
            case 3:
                coerceValue(myDensityAttrib, value);
                break;
            case 4:
                coerceValue(myUseAreaAttrib, value);
                break;
            case 5:
                coerceValue(myAreaAttrib, value);
                break;
            case 6:
                coerceValue(myIndepVoxel, value);
                break;
            case 7:
                coerceValue(myForceTotal, value);
                break;
            case 8:
                coerceValue(myNpts, value);
                break;
            case 9:
                coerceValue(myUseDensityTexture, value);
                break;
            case 10:
                coerceValue(myDensityTexture, value);
                break;
            case 11:
                coerceValue(myCountPerPrimAttrib, value);
                break;
            case 12:
                coerceValue(myUseEmergencyLimit, value);
                break;
            case 13:
                coerceValue(myEmergencyLimit, value);
                break;
            case 14:
                coerceValue(mySeed, value);
                break;
            case 15:
                coerceValue(myOverridePrimSeed, value);
                break;
            case 16:
                coerceValue(myPrimSeedAttrib, value);
                break;
            case 17:
                coerceValue(myRandomizeOrder, value);
                break;
            case 18:
                coerceValue(myRelaxPoints, value);
                break;
            case 19:
                coerceValue(myRelaxIterations, value);
                break;
            case 20:
                coerceValue(myUsePrimNumAttrib, value);
                break;
            case 21:
                coerceValue(myPrimNumAttrib, value);
                break;
            case 22:
                coerceValue(myUsePrimUVWAttrib, value);
                break;
            case 23:
                coerceValue(myPrimUVWAttrib, value);
                break;
            case 24:
                coerceValue(myUseOutputDensityAttrib, value);
                break;
            case 25:
                coerceValue(myOutputDensityAttrib, value);
                break;
            case 26:
                coerceValue(myUseOutputRadiusAttrib, value);
                break;
            case 27:
                coerceValue(myOutputRadiusAttrib, value);
                break;
            case 28:
                coerceValue(myRadiusInTextureSpace, value);
                break;
            case 29:
                coerceValue(myPointAttribs, value);
                break;
            case 30:
                coerceValue(myVertAttribs, value);
                break;
            case 31:
                coerceValue(myPrimAttribs, value);
                break;
            case 32:
                coerceValue(myDetailAttribs, value);
                break;
            case 33:
                coerceValue(myDensityScale, value);
                break;
            case 34:
                coerceValue(myUseAreaForVolumes, value);
                break;
            case 35:
                coerceValue(myScaleRadiiBy, value);
                break;
            case 36:
                coerceValue(myUseMaxRadius, value);
                break;
            case 37:
                coerceValue(myMaxRadius, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 38;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "group";
            case 1:
                return "generateby";
            case 2:
                return "usedensityattrib";
            case 3:
                return "densityattrib";
            case 4:
                return "useareaattrib";
            case 5:
                return "areaattrib";
            case 6:
                return "indepvoxel";
            case 7:
                return "forcetotal";
            case 8:
                return "npts";
            case 9:
                return "usedensitytexture";
            case 10:
                return "densitytexture";
            case 11:
                return "primcountattrib";
            case 12:
                return "useemergencylimit";
            case 13:
                return "emergencylimit";
            case 14:
                return "seed";
            case 15:
                return "overrideprimseed";
            case 16:
                return "primseedattrib";
            case 17:
                return "randomizeorder";
            case 18:
                return "relaxpoints";
            case 19:
                return "relaxiterations";
            case 20:
                return "useprimnumattrib";
            case 21:
                return "primnumattrib";
            case 22:
                return "useprimuvwattrib";
            case 23:
                return "primuvwattrib";
            case 24:
                return "useoutputdensityattrib";
            case 25:
                return "outputdensityattrib";
            case 26:
                return "useoutputradiusattrib";
            case 27:
                return "outputradiusattrib";
            case 28:
                return "radiusintexturespace";
            case 29:
                return "pointattribs";
            case 30:
                return "vertattribs";
            case 31:
                return "primattribs";
            case 32:
                return "detailattribs";
            case 33:
                return "densityscale";
            case 34:
                return "useareaforvolumes";
            case 35:
                return "scaleradiiby";
            case 36:
                return "usemaxradius";
            case 37:
                return "maxradius";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_INTEGER;
                case 3:
                    return PARM_STRING;
                case 4:
                    return PARM_INTEGER;
                case 5:
                    return PARM_STRING;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_INTEGER;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_STRING;
                case 11:
                    return PARM_STRING;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_INTEGER;
                case 14:
                    return PARM_FLOAT;
                case 15:
                    return PARM_INTEGER;
                case 16:
                    return PARM_STRING;
                case 17:
                    return PARM_INTEGER;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_INTEGER;
                case 20:
                    return PARM_INTEGER;
                case 21:
                    return PARM_STRING;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_STRING;
                case 24:
                    return PARM_INTEGER;
                case 25:
                    return PARM_STRING;
                case 26:
                    return PARM_INTEGER;
                case 27:
                    return PARM_STRING;
                case 28:
                    return PARM_INTEGER;
                case 29:
                    return PARM_STRING;
                case 30:
                    return PARM_STRING;
                case 31:
                    return PARM_STRING;
                case 32:
                    return PARM_STRING;
                case 33:
                    return PARM_FLOAT;
                case 34:
                    return PARM_INTEGER;
                case 35:
                    return PARM_FLOAT;
                case 36:
                    return PARM_INTEGER;
                case 37:
                    return PARM_FLOAT;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myGroup);
        saveData(os, myGenerateBy);
        saveData(os, myUseDensityAttrib);
        saveData(os, myDensityAttrib);
        saveData(os, myUseAreaAttrib);
        saveData(os, myAreaAttrib);
        saveData(os, myIndepVoxel);
        saveData(os, myForceTotal);
        saveData(os, myNpts);
        saveData(os, myUseDensityTexture);
        saveData(os, myDensityTexture);
        saveData(os, myCountPerPrimAttrib);
        saveData(os, myUseEmergencyLimit);
        saveData(os, myEmergencyLimit);
        saveData(os, mySeed);
        saveData(os, myOverridePrimSeed);
        saveData(os, myPrimSeedAttrib);
        saveData(os, myRandomizeOrder);
        saveData(os, myRelaxPoints);
        saveData(os, myRelaxIterations);
        saveData(os, myUsePrimNumAttrib);
        saveData(os, myPrimNumAttrib);
        saveData(os, myUsePrimUVWAttrib);
        saveData(os, myPrimUVWAttrib);
        saveData(os, myUseOutputDensityAttrib);
        saveData(os, myOutputDensityAttrib);
        saveData(os, myUseOutputRadiusAttrib);
        saveData(os, myOutputRadiusAttrib);
        saveData(os, myRadiusInTextureSpace);
        saveData(os, myPointAttribs);
        saveData(os, myVertAttribs);
        saveData(os, myPrimAttribs);
        saveData(os, myDetailAttribs);
        saveData(os, myDensityScale);
        saveData(os, myUseAreaForVolumes);
        saveData(os, myScaleRadiiBy);
        saveData(os, myUseMaxRadius);
        saveData(os, myMaxRadius);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myGroup);
        loadData(is, myGenerateBy);
        loadData(is, myUseDensityAttrib);
        loadData(is, myDensityAttrib);
        loadData(is, myUseAreaAttrib);
        loadData(is, myAreaAttrib);
        loadData(is, myIndepVoxel);
        loadData(is, myForceTotal);
        loadData(is, myNpts);
        loadData(is, myUseDensityTexture);
        loadData(is, myDensityTexture);
        loadData(is, myCountPerPrimAttrib);
        loadData(is, myUseEmergencyLimit);
        loadData(is, myEmergencyLimit);
        loadData(is, mySeed);
        loadData(is, myOverridePrimSeed);
        loadData(is, myPrimSeedAttrib);
        loadData(is, myRandomizeOrder);
        loadData(is, myRelaxPoints);
        loadData(is, myRelaxIterations);
        loadData(is, myUsePrimNumAttrib);
        loadData(is, myPrimNumAttrib);
        loadData(is, myUsePrimUVWAttrib);
        loadData(is, myPrimUVWAttrib);
        loadData(is, myUseOutputDensityAttrib);
        loadData(is, myOutputDensityAttrib);
        loadData(is, myUseOutputRadiusAttrib);
        loadData(is, myOutputRadiusAttrib);
        loadData(is, myRadiusInTextureSpace);
        loadData(is, myPointAttribs);
        loadData(is, myVertAttribs);
        loadData(is, myPrimAttribs);
        loadData(is, myDetailAttribs);
        loadData(is, myDensityScale);
        loadData(is, myUseAreaForVolumes);
        loadData(is, myScaleRadiiBy);
        loadData(is, myUseMaxRadius);
        loadData(is, myMaxRadius);

        return true;
    }

    const UT_StringHolder & getGroup() const { return myGroup; }
    void setGroup(const UT_StringHolder & val) { myGroup = val; }
    UT_StringHolder opGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "group", cookparms.getCookTime(), 0);
        return result;
    }
    GenerateBy getGenerateBy() const { return GenerateBy(myGenerateBy); }
    void setGenerateBy(GenerateBy val) { myGenerateBy = int64(val); }
    GenerateBy opGenerateBy(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGenerateBy();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "generateby", cookparms.getCookTime(), 0);
        return GenerateBy(result);
    }
    bool getUseDensityAttrib() const { return myUseDensityAttrib; }
    void setUseDensityAttrib(bool val) { myUseDensityAttrib = val; }
    bool opUseDensityAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseDensityAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usedensityattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getDensityAttrib() const { return myDensityAttrib; }
    void setDensityAttrib(const UT_StringHolder & val) { myDensityAttrib = val; }
    UT_StringHolder opDensityAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDensityAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "densityattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAreaAttrib() const { return myUseAreaAttrib; }
    void setUseAreaAttrib(bool val) { myUseAreaAttrib = val; }
    bool opUseAreaAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAreaAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useareaattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAreaAttrib() const { return myAreaAttrib; }
    void setAreaAttrib(const UT_StringHolder & val) { myAreaAttrib = val; }
    UT_StringHolder opAreaAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAreaAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "areaattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getIndepVoxel() const { return myIndepVoxel; }
    void setIndepVoxel(bool val) { myIndepVoxel = val; }
    bool opIndepVoxel(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIndepVoxel();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "indepvoxel", cookparms.getCookTime(), 0);
        return result;
    }
    bool getForceTotal() const { return myForceTotal; }
    void setForceTotal(bool val) { myForceTotal = val; }
    bool opForceTotal(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getForceTotal();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "forcetotal", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getNpts() const { return myNpts; }
    void setNpts(int64 val) { myNpts = val; }
    int64 opNpts(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNpts();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "npts", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseDensityTexture() const { return myUseDensityTexture; }
    void setUseDensityTexture(bool val) { myUseDensityTexture = val; }
    bool opUseDensityTexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseDensityTexture();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usedensitytexture", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getDensityTexture() const { return myDensityTexture; }
    void setDensityTexture(const UT_StringHolder & val) { myDensityTexture = val; }
    UT_StringHolder opDensityTexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDensityTexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "densitytexture", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getCountPerPrimAttrib() const { return myCountPerPrimAttrib; }
    void setCountPerPrimAttrib(const UT_StringHolder & val) { myCountPerPrimAttrib = val; }
    UT_StringHolder opCountPerPrimAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCountPerPrimAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primcountattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseEmergencyLimit() const { return myUseEmergencyLimit; }
    void setUseEmergencyLimit(bool val) { myUseEmergencyLimit = val; }
    bool opUseEmergencyLimit(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseEmergencyLimit();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useemergencylimit", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getEmergencyLimit() const { return myEmergencyLimit; }
    void setEmergencyLimit(int64 val) { myEmergencyLimit = val; }
    int64 opEmergencyLimit(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmergencyLimit();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "emergencylimit", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getSeed() const { return mySeed; }
    void setSeed(fpreal64 val) { mySeed = val; }
    fpreal64 opSeed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSeed();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "seed", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOverridePrimSeed() const { return myOverridePrimSeed; }
    void setOverridePrimSeed(bool val) { myOverridePrimSeed = val; }
    bool opOverridePrimSeed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOverridePrimSeed();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "overrideprimseed", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPrimSeedAttrib() const { return myPrimSeedAttrib; }
    void setPrimSeedAttrib(const UT_StringHolder & val) { myPrimSeedAttrib = val; }
    UT_StringHolder opPrimSeedAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimSeedAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primseedattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRandomizeOrder() const { return myRandomizeOrder; }
    void setRandomizeOrder(bool val) { myRandomizeOrder = val; }
    bool opRandomizeOrder(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandomizeOrder();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "randomizeorder", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRelaxPoints() const { return myRelaxPoints; }
    void setRelaxPoints(bool val) { myRelaxPoints = val; }
    bool opRelaxPoints(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRelaxPoints();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "relaxpoints", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getRelaxIterations() const { return myRelaxIterations; }
    void setRelaxIterations(int64 val) { myRelaxIterations = val; }
    int64 opRelaxIterations(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRelaxIterations();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "relaxiterations", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUsePrimNumAttrib() const { return myUsePrimNumAttrib; }
    void setUsePrimNumAttrib(bool val) { myUsePrimNumAttrib = val; }
    bool opUsePrimNumAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUsePrimNumAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useprimnumattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPrimNumAttrib() const { return myPrimNumAttrib; }
    void setPrimNumAttrib(const UT_StringHolder & val) { myPrimNumAttrib = val; }
    UT_StringHolder opPrimNumAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimNumAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primnumattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUsePrimUVWAttrib() const { return myUsePrimUVWAttrib; }
    void setUsePrimUVWAttrib(bool val) { myUsePrimUVWAttrib = val; }
    bool opUsePrimUVWAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUsePrimUVWAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useprimuvwattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPrimUVWAttrib() const { return myPrimUVWAttrib; }
    void setPrimUVWAttrib(const UT_StringHolder & val) { myPrimUVWAttrib = val; }
    UT_StringHolder opPrimUVWAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimUVWAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primuvwattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseOutputDensityAttrib() const { return myUseOutputDensityAttrib; }
    void setUseOutputDensityAttrib(bool val) { myUseOutputDensityAttrib = val; }
    bool opUseOutputDensityAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseOutputDensityAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useoutputdensityattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getOutputDensityAttrib() const { return myOutputDensityAttrib; }
    void setOutputDensityAttrib(const UT_StringHolder & val) { myOutputDensityAttrib = val; }
    UT_StringHolder opOutputDensityAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputDensityAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "outputdensityattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseOutputRadiusAttrib() const { return myUseOutputRadiusAttrib; }
    void setUseOutputRadiusAttrib(bool val) { myUseOutputRadiusAttrib = val; }
    bool opUseOutputRadiusAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseOutputRadiusAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useoutputradiusattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getOutputRadiusAttrib() const { return myOutputRadiusAttrib; }
    void setOutputRadiusAttrib(const UT_StringHolder & val) { myOutputRadiusAttrib = val; }
    UT_StringHolder opOutputRadiusAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputRadiusAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "outputradiusattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRadiusInTextureSpace() const { return myRadiusInTextureSpace; }
    void setRadiusInTextureSpace(bool val) { myRadiusInTextureSpace = val; }
    bool opRadiusInTextureSpace(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRadiusInTextureSpace();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "radiusintexturespace", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPointAttribs() const { return myPointAttribs; }
    void setPointAttribs(const UT_StringHolder & val) { myPointAttribs = val; }
    UT_StringHolder opPointAttribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointAttribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "pointattribs", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getVertAttribs() const { return myVertAttribs; }
    void setVertAttribs(const UT_StringHolder & val) { myVertAttribs = val; }
    UT_StringHolder opVertAttribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVertAttribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "vertattribs", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPrimAttribs() const { return myPrimAttribs; }
    void setPrimAttribs(const UT_StringHolder & val) { myPrimAttribs = val; }
    UT_StringHolder opPrimAttribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimAttribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primattribs", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getDetailAttribs() const { return myDetailAttribs; }
    void setDetailAttribs(const UT_StringHolder & val) { myDetailAttribs = val; }
    UT_StringHolder opDetailAttribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDetailAttribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "detailattribs", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getDensityScale() const { return myDensityScale; }
    void setDensityScale(fpreal64 val) { myDensityScale = val; }
    fpreal64 opDensityScale(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDensityScale();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "densityscale", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAreaForVolumes() const { return myUseAreaForVolumes; }
    void setUseAreaForVolumes(bool val) { myUseAreaForVolumes = val; }
    bool opUseAreaForVolumes(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAreaForVolumes();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useareaforvolumes", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getScaleRadiiBy() const { return myScaleRadiiBy; }
    void setScaleRadiiBy(fpreal64 val) { myScaleRadiiBy = val; }
    fpreal64 opScaleRadiiBy(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getScaleRadiiBy();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "scaleradiiby", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseMaxRadius() const { return myUseMaxRadius; }
    void setUseMaxRadius(bool val) { myUseMaxRadius = val; }
    bool opUseMaxRadius(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseMaxRadius();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usemaxradius", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getMaxRadius() const { return myMaxRadius; }
    void setMaxRadius(fpreal64 val) { myMaxRadius = val; }
    fpreal64 opMaxRadius(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxRadius();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "maxradius", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myGroup;
    int64 myGenerateBy;
    bool myUseDensityAttrib;
    UT_StringHolder myDensityAttrib;
    bool myUseAreaAttrib;
    UT_StringHolder myAreaAttrib;
    bool myIndepVoxel;
    bool myForceTotal;
    int64 myNpts;
    bool myUseDensityTexture;
    UT_StringHolder myDensityTexture;
    UT_StringHolder myCountPerPrimAttrib;
    bool myUseEmergencyLimit;
    int64 myEmergencyLimit;
    fpreal64 mySeed;
    bool myOverridePrimSeed;
    UT_StringHolder myPrimSeedAttrib;
    bool myRandomizeOrder;
    bool myRelaxPoints;
    int64 myRelaxIterations;
    bool myUsePrimNumAttrib;
    UT_StringHolder myPrimNumAttrib;
    bool myUsePrimUVWAttrib;
    UT_StringHolder myPrimUVWAttrib;
    bool myUseOutputDensityAttrib;
    UT_StringHolder myOutputDensityAttrib;
    bool myUseOutputRadiusAttrib;
    UT_StringHolder myOutputRadiusAttrib;
    bool myRadiusInTextureSpace;
    UT_StringHolder myPointAttribs;
    UT_StringHolder myVertAttribs;
    UT_StringHolder myPrimAttribs;
    UT_StringHolder myDetailAttribs;
    fpreal64 myDensityScale;
    bool myUseAreaForVolumes;
    fpreal64 myScaleRadiiBy;
    bool myUseMaxRadius;
    fpreal64 myMaxRadius;

};
