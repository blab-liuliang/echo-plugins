/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_Triangulate2D_3_0Enums
{
    enum class PlanePosSrc
    {
        FITPLANE = 0,
        SETPROJPLANE,
        USEATTRIB
    };
    enum class TriangleSize
    {
        UNRESTRICTED = 0,
        CAPMAXAREA,
        SETTARGETEDGELENGTH
    };
}


class SOP_API SOP_Triangulate2D_3_0Parms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_Triangulate2D_3_0Parms()
    {
        myPoints = ""_sh;
        myPlanePosSrc = 0;
        myOrigin = UT_Vector3D(0,0,0);
        myDist = 0;
        myDir = UT_Vector3D(0,1,0);
        myPos2AttribName = ""_sh;
        myUseConstrEdges = false;
        myConstrEdges = ""_sh;
        myUseConstrPolys = false;
        myConstrPolys = ""_sh;
        myIgnorePolyBridges = false;
        myUseSilhouettePolys = false;
        mySilhouettePolys = ""_sh;
        myAllowConstrSplit = false;
        myUseExactConstruction = false;
        myIgnoreNonConstrPts = false;
        myRemoveFromConvexHull = false;
        myRemoveFromConstrPolys = false;
        myRemoveOutsideSilhouette = false;
        myRefine = false;
        myAllowRefineConstrSplits = false;
        myEncroachAngle = 180;
        myMinAngle = 0;
        myTriangleSize = 0;
        myMaxArea = 10000;
        myTargetEdgeLength = 100;
        myMinEdgeLength = 0.0001;
        myMaxNewPts = 5000;
        myNumLloydSteps = 0;
        myAllowMovingInteriorInputPts = false;
        myRestorePos = false;
        myKeepPrims = false;
        myUpdateNormals = false;
        myRemoveUnusedPts = false;
        myRemoveDuplicatePts = false;
        myUseConstrSplitPtsGrp = false;
        myConstrSplitPtsGrp = "constrsplitpts"_sh;
        myUseConstrdEdges = false;
        myConstrdEdges = "constrdedges"_sh;
        myRandomSeed = 5678;

    }

    explicit SOP_Triangulate2D_3_0Parms(const SOP_Triangulate2D_3_0Parms &) = default;

    virtual ~SOP_Triangulate2D_3_0Parms() {}

    bool operator==(const SOP_Triangulate2D_3_0Parms &src) const
    {
        if (myPoints != src.myPoints) return false;
        if (myPlanePosSrc != src.myPlanePosSrc) return false;
        if (myOrigin != src.myOrigin) return false;
        if (myDist != src.myDist) return false;
        if (myDir != src.myDir) return false;
        if (myPos2AttribName != src.myPos2AttribName) return false;
        if (myUseConstrEdges != src.myUseConstrEdges) return false;
        if (myConstrEdges != src.myConstrEdges) return false;
        if (myUseConstrPolys != src.myUseConstrPolys) return false;
        if (myConstrPolys != src.myConstrPolys) return false;
        if (myIgnorePolyBridges != src.myIgnorePolyBridges) return false;
        if (myUseSilhouettePolys != src.myUseSilhouettePolys) return false;
        if (mySilhouettePolys != src.mySilhouettePolys) return false;
        if (myAllowConstrSplit != src.myAllowConstrSplit) return false;
        if (myUseExactConstruction != src.myUseExactConstruction) return false;
        if (myIgnoreNonConstrPts != src.myIgnoreNonConstrPts) return false;
        if (myRemoveFromConvexHull != src.myRemoveFromConvexHull) return false;
        if (myRemoveFromConstrPolys != src.myRemoveFromConstrPolys) return false;
        if (myRemoveOutsideSilhouette != src.myRemoveOutsideSilhouette) return false;
        if (myRefine != src.myRefine) return false;
        if (myAllowRefineConstrSplits != src.myAllowRefineConstrSplits) return false;
        if (myEncroachAngle != src.myEncroachAngle) return false;
        if (myMinAngle != src.myMinAngle) return false;
        if (myTriangleSize != src.myTriangleSize) return false;
        if (myMaxArea != src.myMaxArea) return false;
        if (myTargetEdgeLength != src.myTargetEdgeLength) return false;
        if (myMinEdgeLength != src.myMinEdgeLength) return false;
        if (myMaxNewPts != src.myMaxNewPts) return false;
        if (myNumLloydSteps != src.myNumLloydSteps) return false;
        if (myAllowMovingInteriorInputPts != src.myAllowMovingInteriorInputPts) return false;
        if (myRestorePos != src.myRestorePos) return false;
        if (myKeepPrims != src.myKeepPrims) return false;
        if (myUpdateNormals != src.myUpdateNormals) return false;
        if (myRemoveUnusedPts != src.myRemoveUnusedPts) return false;
        if (myRemoveDuplicatePts != src.myRemoveDuplicatePts) return false;
        if (myUseConstrSplitPtsGrp != src.myUseConstrSplitPtsGrp) return false;
        if (myConstrSplitPtsGrp != src.myConstrSplitPtsGrp) return false;
        if (myUseConstrdEdges != src.myUseConstrdEdges) return false;
        if (myConstrdEdges != src.myConstrdEdges) return false;
        if (myRandomSeed != src.myRandomSeed) return false;

        return true;
    }
    bool operator!=(const SOP_Triangulate2D_3_0Parms &src) const
    {
        return !operator==(src);
    }
    using PlanePosSrc = SOP_Triangulate2D_3_0Enums::PlanePosSrc;
    using TriangleSize = SOP_Triangulate2D_3_0Enums::TriangleSize;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myPoints, node, "points", time, 0);
        else myPoints = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myPlanePosSrc, node, "planepossrc", time, 0);
        else myPlanePosSrc = 0;
        if (true && ( (!(((int64(getPlanePosSrc())!=1)))) ) )
            OP_Utils::evalOpParm(myOrigin, node, "origin", time, 0);
        else myOrigin = UT_Vector3D(0,0,0);
        if (true && ( (!(((int64(getPlanePosSrc())!=1)))) ) )
            OP_Utils::evalOpParm(myDist, node, "dist", time, 0);
        else myDist = 0;
        if (true && ( (!(((int64(getPlanePosSrc())!=1)))) ) )
            OP_Utils::evalOpParm(myDir, node, "dir", time, 0);
        else myDir = UT_Vector3D(0,1,0);
        if (true && ( (!(((int64(getPlanePosSrc())!=2)))) ) )
            OP_Utils::evalOpParm(myPos2AttribName, node, "pos2attrib", time, 0);
        else myPos2AttribName = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUseConstrEdges, node, "useconstredges", time, 0);
        else myUseConstrEdges = false;
        if (true && ( (!(((getUseConstrEdges()==0)))) ) )
            OP_Utils::evalOpParm(myConstrEdges, node, "constredges", time, 0);
        else myConstrEdges = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUseConstrPolys, node, "useconstrpolys", time, 0);
        else myUseConstrPolys = false;
        if (true && ( (!(((getUseConstrPolys()==0)))) ) )
            OP_Utils::evalOpParm(myConstrPolys, node, "constrpolys", time, 0);
        else myConstrPolys = ""_sh;
        if (true && ( (!(((getUseConstrPolys()==0)))) ) )
            OP_Utils::evalOpParm(myIgnorePolyBridges, node, "ignorepolybridges", time, 0);
        else myIgnorePolyBridges = false;
        if (true)
            OP_Utils::evalOpParm(myUseSilhouettePolys, node, "usesilhouettepolys", time, 0);
        else myUseSilhouettePolys = false;
        if (true && ( (!(((getUseSilhouettePolys()==0)))) ) )
            OP_Utils::evalOpParm(mySilhouettePolys, node, "silhouettepolys", time, 0);
        else mySilhouettePolys = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myAllowConstrSplit, node, "allowconstrsplit", time, 0);
        else myAllowConstrSplit = false;
        if (true && ( (!(((getAllowConstrSplit()==0)))) ) )
            OP_Utils::evalOpParm(myUseExactConstruction, node, "useexactconstruction", time, 0);
        else myUseExactConstruction = false;
        if (true && ( (!(((getUseConstrEdges()==0)&&(getUseConstrPolys()==0)&&(getUseSilhouettePolys()==0)))) ) )
            OP_Utils::evalOpParm(myIgnoreNonConstrPts, node, "ignorenonconstrpts", time, 0);
        else myIgnoreNonConstrPts = false;
        if (true && ( (!(((getUseConstrEdges()==0)&&(getUseConstrPolys()==0)&&(getUseSilhouettePolys()==0)))) ) )
            OP_Utils::evalOpParm(myRemoveFromConvexHull, node, "removefromconvexhull", time, 0);
        else myRemoveFromConvexHull = false;
        if (true && ( (!(((getUseConstrPolys()==0)))) ) )
            OP_Utils::evalOpParm(myRemoveFromConstrPolys, node, "removefromconstrpolys", time, 0);
        else myRemoveFromConstrPolys = false;
        if (true && ( (!(((getUseSilhouettePolys()==0)))) ) )
            OP_Utils::evalOpParm(myRemoveOutsideSilhouette, node, "removeoutsidesilhouette", time, 0);
        else myRemoveOutsideSilhouette = false;
        if (true)
            OP_Utils::evalOpParm(myRefine, node, "refine", time, 0);
        else myRefine = false;
        if (true)
            OP_Utils::evalOpParm(myAllowRefineConstrSplits, node, "allowrefineonstrsplit", time, 0);
        else myAllowRefineConstrSplits = false;
        if (true && ( (!(((getAllowRefineConstrSplits()==1)))) ) )
            OP_Utils::evalOpParm(myEncroachAngle, node, "encroachangle", time, 0);
        else myEncroachAngle = 180;
        if (true && ( (!(((getRefine()==0)))) ) )
            OP_Utils::evalOpParm(myMinAngle, node, "minangle", time, 0);
        else myMinAngle = 0;
        if (true && ( (!(((getRefine()==0)))) ) )
            OP_Utils::evalOpParm(myTriangleSize, node, "trianglesize", time, 0);
        else myTriangleSize = 0;
        if (true && ( (!(((int64(getTriangleSize())!=1))||((getRefine()==0)))) ) )
            OP_Utils::evalOpParm(myMaxArea, node, "maxarea", time, 0);
        else myMaxArea = 10000;
        if (true && ( (!(((int64(getTriangleSize())!=2))||((getRefine()==0)))) ) )
            OP_Utils::evalOpParm(myTargetEdgeLength, node, "targetedgelength", time, 0);
        else myTargetEdgeLength = 100;
        if (true && ( (!(((getRefine()==0)))) ) )
            OP_Utils::evalOpParm(myMinEdgeLength, node, "minedgelength", time, 0);
        else myMinEdgeLength = 0.0001;
        if (true && ( (!(((getRefine()==0)))) ) )
            OP_Utils::evalOpParm(myMaxNewPts, node, "maxnewpts", time, 0);
        else myMaxNewPts = 5000;
        if (true && ( (!(((getRefine()==0)))) ) )
            OP_Utils::evalOpParm(myNumLloydSteps, node, "lloydsteps", time, 0);
        else myNumLloydSteps = 0;
        if (true && ( (!(((getRefine()==0))||((int64(getNumLloydSteps())==0)))) ) )
            OP_Utils::evalOpParm(myAllowMovingInteriorInputPts, node, "allowmovinginteriorpts", time, 0);
        else myAllowMovingInteriorInputPts = false;
        if (true)
            OP_Utils::evalOpParm(myRestorePos, node, "restorepos", time, 0);
        else myRestorePos = false;
        if (true)
            OP_Utils::evalOpParm(myKeepPrims, node, "keepprims", time, 0);
        else myKeepPrims = false;
        if (true)
            OP_Utils::evalOpParm(myUpdateNormals, node, "updatenmls", time, 0);
        else myUpdateNormals = false;
        if (true)
            OP_Utils::evalOpParm(myRemoveUnusedPts, node, "removeunusedpoints", time, 0);
        else myRemoveUnusedPts = false;
        if (true)
            OP_Utils::evalOpParm(myRemoveDuplicatePts, node, "removeduplicatepoints", time, 0);
        else myRemoveDuplicatePts = false;
        if (true && ( (!(((getAllowConstrSplit()==0)))) ) )
            OP_Utils::evalOpParm(myUseConstrSplitPtsGrp, node, "usecontrsplitptgrp", time, 0);
        else myUseConstrSplitPtsGrp = false;
        if (true && ( (!(((getUseConstrSplitPtsGrp()==0)))) ) )
            OP_Utils::evalOpParm(myConstrSplitPtsGrp, node, "constrsplitptgrp", time, 0);
        else myConstrSplitPtsGrp = "constrsplitpts"_sh;
        if (true)
            OP_Utils::evalOpParm(myUseConstrdEdges, node, "useconstrdedges", time, 0);
        else myUseConstrdEdges = false;
        if (true && ( (!(((getUseConstrdEdges()==0)))) ) )
            OP_Utils::evalOpParm(myConstrdEdges, node, "constrdedges", time, 0);
        else myConstrdEdges = "constrdedges"_sh;
        if (true)
            OP_Utils::evalOpParm(myRandomSeed, node, "randseed", time, 0);
        else myRandomSeed = 5678;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_Triangulate2D_3_0Parms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myPoints);
                break;
            case 1:
                coerceValue(value, myPlanePosSrc);
                break;
            case 2:
                coerceValue(value, myOrigin);
                break;
            case 3:
                coerceValue(value, myDist);
                break;
            case 4:
                coerceValue(value, myDir);
                break;
            case 5:
                coerceValue(value, myPos2AttribName);
                break;
            case 6:
                coerceValue(value, myUseConstrEdges);
                break;
            case 7:
                coerceValue(value, myConstrEdges);
                break;
            case 8:
                coerceValue(value, myUseConstrPolys);
                break;
            case 9:
                coerceValue(value, myConstrPolys);
                break;
            case 10:
                coerceValue(value, myIgnorePolyBridges);
                break;
            case 11:
                coerceValue(value, myUseSilhouettePolys);
                break;
            case 12:
                coerceValue(value, mySilhouettePolys);
                break;
            case 13:
                coerceValue(value, myAllowConstrSplit);
                break;
            case 14:
                coerceValue(value, myUseExactConstruction);
                break;
            case 15:
                coerceValue(value, myIgnoreNonConstrPts);
                break;
            case 16:
                coerceValue(value, myRemoveFromConvexHull);
                break;
            case 17:
                coerceValue(value, myRemoveFromConstrPolys);
                break;
            case 18:
                coerceValue(value, myRemoveOutsideSilhouette);
                break;
            case 19:
                coerceValue(value, myRefine);
                break;
            case 20:
                coerceValue(value, myAllowRefineConstrSplits);
                break;
            case 21:
                coerceValue(value, myEncroachAngle);
                break;
            case 22:
                coerceValue(value, myMinAngle);
                break;
            case 23:
                coerceValue(value, myTriangleSize);
                break;
            case 24:
                coerceValue(value, myMaxArea);
                break;
            case 25:
                coerceValue(value, myTargetEdgeLength);
                break;
            case 26:
                coerceValue(value, myMinEdgeLength);
                break;
            case 27:
                coerceValue(value, myMaxNewPts);
                break;
            case 28:
                coerceValue(value, myNumLloydSteps);
                break;
            case 29:
                coerceValue(value, myAllowMovingInteriorInputPts);
                break;
            case 30:
                coerceValue(value, myRestorePos);
                break;
            case 31:
                coerceValue(value, myKeepPrims);
                break;
            case 32:
                coerceValue(value, myUpdateNormals);
                break;
            case 33:
                coerceValue(value, myRemoveUnusedPts);
                break;
            case 34:
                coerceValue(value, myRemoveDuplicatePts);
                break;
            case 35:
                coerceValue(value, myUseConstrSplitPtsGrp);
                break;
            case 36:
                coerceValue(value, myConstrSplitPtsGrp);
                break;
            case 37:
                coerceValue(value, myUseConstrdEdges);
                break;
            case 38:
                coerceValue(value, myConstrdEdges);
                break;
            case 39:
                coerceValue(value, myRandomSeed);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myPoints, value);
                break;
            case 1:
                coerceValue(myPlanePosSrc, value);
                break;
            case 2:
                coerceValue(myOrigin, value);
                break;
            case 3:
                coerceValue(myDist, value);
                break;
            case 4:
                coerceValue(myDir, value);
                break;
            case 5:
                coerceValue(myPos2AttribName, value);
                break;
            case 6:
                coerceValue(myUseConstrEdges, value);
                break;
            case 7:
                coerceValue(myConstrEdges, value);
                break;
            case 8:
                coerceValue(myUseConstrPolys, value);
                break;
            case 9:
                coerceValue(myConstrPolys, value);
                break;
            case 10:
                coerceValue(myIgnorePolyBridges, value);
                break;
            case 11:
                coerceValue(myUseSilhouettePolys, value);
                break;
            case 12:
                coerceValue(mySilhouettePolys, value);
                break;
            case 13:
                coerceValue(myAllowConstrSplit, value);
                break;
            case 14:
                coerceValue(myUseExactConstruction, value);
                break;
            case 15:
                coerceValue(myIgnoreNonConstrPts, value);
                break;
            case 16:
                coerceValue(myRemoveFromConvexHull, value);
                break;
            case 17:
                coerceValue(myRemoveFromConstrPolys, value);
                break;
            case 18:
                coerceValue(myRemoveOutsideSilhouette, value);
                break;
            case 19:
                coerceValue(myRefine, value);
                break;
            case 20:
                coerceValue(myAllowRefineConstrSplits, value);
                break;
            case 21:
                coerceValue(myEncroachAngle, value);
                break;
            case 22:
                coerceValue(myMinAngle, value);
                break;
            case 23:
                coerceValue(myTriangleSize, value);
                break;
            case 24:
                coerceValue(myMaxArea, value);
                break;
            case 25:
                coerceValue(myTargetEdgeLength, value);
                break;
            case 26:
                coerceValue(myMinEdgeLength, value);
                break;
            case 27:
                coerceValue(myMaxNewPts, value);
                break;
            case 28:
                coerceValue(myNumLloydSteps, value);
                break;
            case 29:
                coerceValue(myAllowMovingInteriorInputPts, value);
                break;
            case 30:
                coerceValue(myRestorePos, value);
                break;
            case 31:
                coerceValue(myKeepPrims, value);
                break;
            case 32:
                coerceValue(myUpdateNormals, value);
                break;
            case 33:
                coerceValue(myRemoveUnusedPts, value);
                break;
            case 34:
                coerceValue(myRemoveDuplicatePts, value);
                break;
            case 35:
                coerceValue(myUseConstrSplitPtsGrp, value);
                break;
            case 36:
                coerceValue(myConstrSplitPtsGrp, value);
                break;
            case 37:
                coerceValue(myUseConstrdEdges, value);
                break;
            case 38:
                coerceValue(myConstrdEdges, value);
                break;
            case 39:
                coerceValue(myRandomSeed, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 40;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "points";
            case 1:
                return "planepossrc";
            case 2:
                return "origin";
            case 3:
                return "dist";
            case 4:
                return "dir";
            case 5:
                return "pos2attrib";
            case 6:
                return "useconstredges";
            case 7:
                return "constredges";
            case 8:
                return "useconstrpolys";
            case 9:
                return "constrpolys";
            case 10:
                return "ignorepolybridges";
            case 11:
                return "usesilhouettepolys";
            case 12:
                return "silhouettepolys";
            case 13:
                return "allowconstrsplit";
            case 14:
                return "useexactconstruction";
            case 15:
                return "ignorenonconstrpts";
            case 16:
                return "removefromconvexhull";
            case 17:
                return "removefromconstrpolys";
            case 18:
                return "removeoutsidesilhouette";
            case 19:
                return "refine";
            case 20:
                return "allowrefineonstrsplit";
            case 21:
                return "encroachangle";
            case 22:
                return "minangle";
            case 23:
                return "trianglesize";
            case 24:
                return "maxarea";
            case 25:
                return "targetedgelength";
            case 26:
                return "minedgelength";
            case 27:
                return "maxnewpts";
            case 28:
                return "lloydsteps";
            case 29:
                return "allowmovinginteriorpts";
            case 30:
                return "restorepos";
            case 31:
                return "keepprims";
            case 32:
                return "updatenmls";
            case 33:
                return "removeunusedpoints";
            case 34:
                return "removeduplicatepoints";
            case 35:
                return "usecontrsplitptgrp";
            case 36:
                return "constrsplitptgrp";
            case 37:
                return "useconstrdedges";
            case 38:
                return "constrdedges";
            case 39:
                return "randseed";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_VECTOR3;
                case 3:
                    return PARM_FLOAT;
                case 4:
                    return PARM_VECTOR3;
                case 5:
                    return PARM_STRING;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_STRING;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_STRING;
                case 10:
                    return PARM_INTEGER;
                case 11:
                    return PARM_INTEGER;
                case 12:
                    return PARM_STRING;
                case 13:
                    return PARM_INTEGER;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_INTEGER;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_INTEGER;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_INTEGER;
                case 20:
                    return PARM_INTEGER;
                case 21:
                    return PARM_FLOAT;
                case 22:
                    return PARM_FLOAT;
                case 23:
                    return PARM_INTEGER;
                case 24:
                    return PARM_FLOAT;
                case 25:
                    return PARM_FLOAT;
                case 26:
                    return PARM_FLOAT;
                case 27:
                    return PARM_INTEGER;
                case 28:
                    return PARM_INTEGER;
                case 29:
                    return PARM_INTEGER;
                case 30:
                    return PARM_INTEGER;
                case 31:
                    return PARM_INTEGER;
                case 32:
                    return PARM_INTEGER;
                case 33:
                    return PARM_INTEGER;
                case 34:
                    return PARM_INTEGER;
                case 35:
                    return PARM_INTEGER;
                case 36:
                    return PARM_STRING;
                case 37:
                    return PARM_INTEGER;
                case 38:
                    return PARM_STRING;
                case 39:
                    return PARM_INTEGER;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myPoints);
        saveData(os, myPlanePosSrc);
        saveData(os, myOrigin);
        saveData(os, myDist);
        saveData(os, myDir);
        saveData(os, myPos2AttribName);
        saveData(os, myUseConstrEdges);
        saveData(os, myConstrEdges);
        saveData(os, myUseConstrPolys);
        saveData(os, myConstrPolys);
        saveData(os, myIgnorePolyBridges);
        saveData(os, myUseSilhouettePolys);
        saveData(os, mySilhouettePolys);
        saveData(os, myAllowConstrSplit);
        saveData(os, myUseExactConstruction);
        saveData(os, myIgnoreNonConstrPts);
        saveData(os, myRemoveFromConvexHull);
        saveData(os, myRemoveFromConstrPolys);
        saveData(os, myRemoveOutsideSilhouette);
        saveData(os, myRefine);
        saveData(os, myAllowRefineConstrSplits);
        saveData(os, myEncroachAngle);
        saveData(os, myMinAngle);
        saveData(os, myTriangleSize);
        saveData(os, myMaxArea);
        saveData(os, myTargetEdgeLength);
        saveData(os, myMinEdgeLength);
        saveData(os, myMaxNewPts);
        saveData(os, myNumLloydSteps);
        saveData(os, myAllowMovingInteriorInputPts);
        saveData(os, myRestorePos);
        saveData(os, myKeepPrims);
        saveData(os, myUpdateNormals);
        saveData(os, myRemoveUnusedPts);
        saveData(os, myRemoveDuplicatePts);
        saveData(os, myUseConstrSplitPtsGrp);
        saveData(os, myConstrSplitPtsGrp);
        saveData(os, myUseConstrdEdges);
        saveData(os, myConstrdEdges);
        saveData(os, myRandomSeed);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myPoints);
        loadData(is, myPlanePosSrc);
        loadData(is, myOrigin);
        loadData(is, myDist);
        loadData(is, myDir);
        loadData(is, myPos2AttribName);
        loadData(is, myUseConstrEdges);
        loadData(is, myConstrEdges);
        loadData(is, myUseConstrPolys);
        loadData(is, myConstrPolys);
        loadData(is, myIgnorePolyBridges);
        loadData(is, myUseSilhouettePolys);
        loadData(is, mySilhouettePolys);
        loadData(is, myAllowConstrSplit);
        loadData(is, myUseExactConstruction);
        loadData(is, myIgnoreNonConstrPts);
        loadData(is, myRemoveFromConvexHull);
        loadData(is, myRemoveFromConstrPolys);
        loadData(is, myRemoveOutsideSilhouette);
        loadData(is, myRefine);
        loadData(is, myAllowRefineConstrSplits);
        loadData(is, myEncroachAngle);
        loadData(is, myMinAngle);
        loadData(is, myTriangleSize);
        loadData(is, myMaxArea);
        loadData(is, myTargetEdgeLength);
        loadData(is, myMinEdgeLength);
        loadData(is, myMaxNewPts);
        loadData(is, myNumLloydSteps);
        loadData(is, myAllowMovingInteriorInputPts);
        loadData(is, myRestorePos);
        loadData(is, myKeepPrims);
        loadData(is, myUpdateNormals);
        loadData(is, myRemoveUnusedPts);
        loadData(is, myRemoveDuplicatePts);
        loadData(is, myUseConstrSplitPtsGrp);
        loadData(is, myConstrSplitPtsGrp);
        loadData(is, myUseConstrdEdges);
        loadData(is, myConstrdEdges);
        loadData(is, myRandomSeed);

        return true;
    }

    const UT_StringHolder & getPoints() const { return myPoints; }
    void setPoints(const UT_StringHolder & val) { myPoints = val; }
    UT_StringHolder opPoints(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPoints();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "points", cookparms.getCookTime(), 0);
        return result;
    }
    PlanePosSrc getPlanePosSrc() const { return PlanePosSrc(myPlanePosSrc); }
    void setPlanePosSrc(PlanePosSrc val) { myPlanePosSrc = int64(val); }
    PlanePosSrc opPlanePosSrc(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPlanePosSrc();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "planepossrc", cookparms.getCookTime(), 0);
        return PlanePosSrc(result);
    }
    UT_Vector3D getOrigin() const { return myOrigin; }
    void setOrigin(UT_Vector3D val) { myOrigin = val; }
    UT_Vector3D opOrigin(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOrigin();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "origin", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getDist() const { return myDist; }
    void setDist(fpreal64 val) { myDist = val; }
    fpreal64 opDist(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDist();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "dist", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getDir() const { return myDir; }
    void setDir(UT_Vector3D val) { myDir = val; }
    UT_Vector3D opDir(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDir();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "dir", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPos2AttribName() const { return myPos2AttribName; }
    void setPos2AttribName(const UT_StringHolder & val) { myPos2AttribName = val; }
    UT_StringHolder opPos2AttribName(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPos2AttribName();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "pos2attrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseConstrEdges() const { return myUseConstrEdges; }
    void setUseConstrEdges(bool val) { myUseConstrEdges = val; }
    bool opUseConstrEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseConstrEdges();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useconstredges", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getConstrEdges() const { return myConstrEdges; }
    void setConstrEdges(const UT_StringHolder & val) { myConstrEdges = val; }
    UT_StringHolder opConstrEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getConstrEdges();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "constredges", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseConstrPolys() const { return myUseConstrPolys; }
    void setUseConstrPolys(bool val) { myUseConstrPolys = val; }
    bool opUseConstrPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseConstrPolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useconstrpolys", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getConstrPolys() const { return myConstrPolys; }
    void setConstrPolys(const UT_StringHolder & val) { myConstrPolys = val; }
    UT_StringHolder opConstrPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getConstrPolys();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "constrpolys", cookparms.getCookTime(), 0);
        return result;
    }
    bool getIgnorePolyBridges() const { return myIgnorePolyBridges; }
    void setIgnorePolyBridges(bool val) { myIgnorePolyBridges = val; }
    bool opIgnorePolyBridges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIgnorePolyBridges();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "ignorepolybridges", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseSilhouettePolys() const { return myUseSilhouettePolys; }
    void setUseSilhouettePolys(bool val) { myUseSilhouettePolys = val; }
    bool opUseSilhouettePolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseSilhouettePolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usesilhouettepolys", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getSilhouettePolys() const { return mySilhouettePolys; }
    void setSilhouettePolys(const UT_StringHolder & val) { mySilhouettePolys = val; }
    UT_StringHolder opSilhouettePolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSilhouettePolys();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "silhouettepolys", cookparms.getCookTime(), 0);
        return result;
    }
    bool getAllowConstrSplit() const { return myAllowConstrSplit; }
    void setAllowConstrSplit(bool val) { myAllowConstrSplit = val; }
    bool opAllowConstrSplit(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAllowConstrSplit();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "allowconstrsplit", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseExactConstruction() const { return myUseExactConstruction; }
    void setUseExactConstruction(bool val) { myUseExactConstruction = val; }
    bool opUseExactConstruction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseExactConstruction();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useexactconstruction", cookparms.getCookTime(), 0);
        return result;
    }
    bool getIgnoreNonConstrPts() const { return myIgnoreNonConstrPts; }
    void setIgnoreNonConstrPts(bool val) { myIgnoreNonConstrPts = val; }
    bool opIgnoreNonConstrPts(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIgnoreNonConstrPts();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "ignorenonconstrpts", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRemoveFromConvexHull() const { return myRemoveFromConvexHull; }
    void setRemoveFromConvexHull(bool val) { myRemoveFromConvexHull = val; }
    bool opRemoveFromConvexHull(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRemoveFromConvexHull();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "removefromconvexhull", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRemoveFromConstrPolys() const { return myRemoveFromConstrPolys; }
    void setRemoveFromConstrPolys(bool val) { myRemoveFromConstrPolys = val; }
    bool opRemoveFromConstrPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRemoveFromConstrPolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "removefromconstrpolys", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRemoveOutsideSilhouette() const { return myRemoveOutsideSilhouette; }
    void setRemoveOutsideSilhouette(bool val) { myRemoveOutsideSilhouette = val; }
    bool opRemoveOutsideSilhouette(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRemoveOutsideSilhouette();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "removeoutsidesilhouette", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRefine() const { return myRefine; }
    void setRefine(bool val) { myRefine = val; }
    bool opRefine(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRefine();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "refine", cookparms.getCookTime(), 0);
        return result;
    }
    bool getAllowRefineConstrSplits() const { return myAllowRefineConstrSplits; }
    void setAllowRefineConstrSplits(bool val) { myAllowRefineConstrSplits = val; }
    bool opAllowRefineConstrSplits(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAllowRefineConstrSplits();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "allowrefineonstrsplit", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getEncroachAngle() const { return myEncroachAngle; }
    void setEncroachAngle(fpreal64 val) { myEncroachAngle = val; }
    fpreal64 opEncroachAngle(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEncroachAngle();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "encroachangle", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getMinAngle() const { return myMinAngle; }
    void setMinAngle(fpreal64 val) { myMinAngle = val; }
    fpreal64 opMinAngle(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMinAngle();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "minangle", cookparms.getCookTime(), 0);
        return result;
    }
    TriangleSize getTriangleSize() const { return TriangleSize(myTriangleSize); }
    void setTriangleSize(TriangleSize val) { myTriangleSize = int64(val); }
    TriangleSize opTriangleSize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTriangleSize();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "trianglesize", cookparms.getCookTime(), 0);
        return TriangleSize(result);
    }
    fpreal64 getMaxArea() const { return myMaxArea; }
    void setMaxArea(fpreal64 val) { myMaxArea = val; }
    fpreal64 opMaxArea(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxArea();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "maxarea", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getTargetEdgeLength() const { return myTargetEdgeLength; }
    void setTargetEdgeLength(fpreal64 val) { myTargetEdgeLength = val; }
    fpreal64 opTargetEdgeLength(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetEdgeLength();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "targetedgelength", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getMinEdgeLength() const { return myMinEdgeLength; }
    void setMinEdgeLength(fpreal64 val) { myMinEdgeLength = val; }
    fpreal64 opMinEdgeLength(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMinEdgeLength();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "minedgelength", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getMaxNewPts() const { return myMaxNewPts; }
    void setMaxNewPts(int64 val) { myMaxNewPts = val; }
    int64 opMaxNewPts(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxNewPts();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "maxnewpts", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getNumLloydSteps() const { return myNumLloydSteps; }
    void setNumLloydSteps(int64 val) { myNumLloydSteps = val; }
    int64 opNumLloydSteps(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNumLloydSteps();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "lloydsteps", cookparms.getCookTime(), 0);
        return result;
    }
    bool getAllowMovingInteriorInputPts() const { return myAllowMovingInteriorInputPts; }
    void setAllowMovingInteriorInputPts(bool val) { myAllowMovingInteriorInputPts = val; }
    bool opAllowMovingInteriorInputPts(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAllowMovingInteriorInputPts();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "allowmovinginteriorpts", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRestorePos() const { return myRestorePos; }
    void setRestorePos(bool val) { myRestorePos = val; }
    bool opRestorePos(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRestorePos();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "restorepos", cookparms.getCookTime(), 0);
        return result;
    }
    bool getKeepPrims() const { return myKeepPrims; }
    void setKeepPrims(bool val) { myKeepPrims = val; }
    bool opKeepPrims(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getKeepPrims();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "keepprims", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUpdateNormals() const { return myUpdateNormals; }
    void setUpdateNormals(bool val) { myUpdateNormals = val; }
    bool opUpdateNormals(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUpdateNormals();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "updatenmls", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRemoveUnusedPts() const { return myRemoveUnusedPts; }
    void setRemoveUnusedPts(bool val) { myRemoveUnusedPts = val; }
    bool opRemoveUnusedPts(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRemoveUnusedPts();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "removeunusedpoints", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRemoveDuplicatePts() const { return myRemoveDuplicatePts; }
    void setRemoveDuplicatePts(bool val) { myRemoveDuplicatePts = val; }
    bool opRemoveDuplicatePts(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRemoveDuplicatePts();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "removeduplicatepoints", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseConstrSplitPtsGrp() const { return myUseConstrSplitPtsGrp; }
    void setUseConstrSplitPtsGrp(bool val) { myUseConstrSplitPtsGrp = val; }
    bool opUseConstrSplitPtsGrp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseConstrSplitPtsGrp();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usecontrsplitptgrp", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getConstrSplitPtsGrp() const { return myConstrSplitPtsGrp; }
    void setConstrSplitPtsGrp(const UT_StringHolder & val) { myConstrSplitPtsGrp = val; }
    UT_StringHolder opConstrSplitPtsGrp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getConstrSplitPtsGrp();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "constrsplitptgrp", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseConstrdEdges() const { return myUseConstrdEdges; }
    void setUseConstrdEdges(bool val) { myUseConstrdEdges = val; }
    bool opUseConstrdEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseConstrdEdges();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useconstrdedges", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getConstrdEdges() const { return myConstrdEdges; }
    void setConstrdEdges(const UT_StringHolder & val) { myConstrdEdges = val; }
    UT_StringHolder opConstrdEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getConstrdEdges();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "constrdedges", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getRandomSeed() const { return myRandomSeed; }
    void setRandomSeed(int64 val) { myRandomSeed = val; }
    int64 opRandomSeed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandomSeed();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "randseed", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myPoints;
    int64 myPlanePosSrc;
    UT_Vector3D myOrigin;
    fpreal64 myDist;
    UT_Vector3D myDir;
    UT_StringHolder myPos2AttribName;
    bool myUseConstrEdges;
    UT_StringHolder myConstrEdges;
    bool myUseConstrPolys;
    UT_StringHolder myConstrPolys;
    bool myIgnorePolyBridges;
    bool myUseSilhouettePolys;
    UT_StringHolder mySilhouettePolys;
    bool myAllowConstrSplit;
    bool myUseExactConstruction;
    bool myIgnoreNonConstrPts;
    bool myRemoveFromConvexHull;
    bool myRemoveFromConstrPolys;
    bool myRemoveOutsideSilhouette;
    bool myRefine;
    bool myAllowRefineConstrSplits;
    fpreal64 myEncroachAngle;
    fpreal64 myMinAngle;
    int64 myTriangleSize;
    fpreal64 myMaxArea;
    fpreal64 myTargetEdgeLength;
    fpreal64 myMinEdgeLength;
    int64 myMaxNewPts;
    int64 myNumLloydSteps;
    bool myAllowMovingInteriorInputPts;
    bool myRestorePos;
    bool myKeepPrims;
    bool myUpdateNormals;
    bool myRemoveUnusedPts;
    bool myRemoveDuplicatePts;
    bool myUseConstrSplitPtsGrp;
    UT_StringHolder myConstrSplitPtsGrp;
    bool myUseConstrdEdges;
    UT_StringHolder myConstrdEdges;
    int64 myRandomSeed;

};
