/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_UVLayout_3_0Enums
{
    enum class UVProjPlane
    {
        XY = 0,
        YZ,
        ZX
    };
    enum class AxisAlignment
    {
        NONE = 0,
        INTRINSIC,
        EXTRINSIC
    };
    enum class Scaling
    {
        AUTO = 0,
        CUSTOM
    };
    enum class RotationStep
    {
        NONE = 0,
        PI,
        PI2,
        PI4,
        PI8,
        PI16,
        PI32,
        CUSTOM
    };
    enum class Resolution
    {
        RES1 = 0,
        RES2,
        RES3,
        RES4,
        RES5,
        CUSTOM
    };
    enum class TargetType
    {
        BOXES = 0,
        UDIM,
        GEO
    };
    enum class TargetProjPlane
    {
        XY = 0,
        YZ,
        ZX
    };
}


class SOP_API SOP_UVLayout_3_0Parms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }
    struct Rects
    {
        bool rect_use;
        UT_Vector2D rect_center;
        UT_Vector2D rect_size;


        Rects()
        {
            rect_use = false;
            rect_center = UT_Vector2D(0.5,0.5);
            rect_size = UT_Vector2D(1,1);

        }

        bool operator==(const Rects &src) const
        {
            if (rect_use != src.rect_use) return false;
            if (rect_center != src.rect_center) return false;
            if (rect_size != src.rect_size) return false;

            return true;
        }
        bool operator!=(const Rects &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Rects> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            buf.appendSprintf("%s", (list(i).rect_use) ? "true" : "false");
            buf.append(", ");
            buf.appendSprintf("(%f, %f)", list(i).rect_center.x(), list(i).rect_center.y());
            buf.append(", ");
            buf.appendSprintf("(%f, %f)", list(i).rect_size.x(), list(i).rect_size.y());

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }

    SOP_UVLayout_3_0Parms()
    {
        myUVAttr = "uv"_sh;
        myUVProjPlane = 0;
        myGroup = ""_sh;
        mySeparatorEdges = ""_sh;
        myUseIslandAttr = false;
        myIslandAttr = "island"_sh;
        myUseTargetAttr = false;
        myTargetAttr = "udim"_sh;
        myTargetOverrides = ""_sh;
        myUseIslandScaleAttr = false;
        myIslandScaleAttr = "iscale"_sh;
        myScaleOverrides = ""_sh;
        myUseIslandOffsetAttr = false;
        myIslandOffsetAttr = "ioffset"_sh;
        myOffsetOverrides = ""_sh;
        myCorrectAreas = false;
        myAxisAlignment = 1;
        myScaling = 0;
        myScale = 1;
        myRotationStep = 0;
        myCircleDivs = 1;
        myPackBetween = false;
        myPackInCavities = false;
        myPadding = 1;
        myPadBoundaries = false;
        myExpandPadding = false;
        myIterations = 1;
        myResolution = 2;
        myCustomResolution = 1024;
        myConnectivityTolerance = 1e-05;
        myScaleTolerance = 0.005;
        myRandSeed = 5489;
        myTargetType = 0;
        myUseDefaultTarget = false;
        myDefaultTarget = 0;
        myUseDefaultUdimTarget = false;
        myDefaultUdimTarget = 1001;
        myTileSize = UT_Vector2D(1,1);
        myNumColumns = 10;
        myStartingUdim = 1001;
        myTargetUVAttr = "uv"_sh;
        myTargetProjPlane = 0;
        myTargetGroup = ""_sh;
        myTargetSeparatorEdges = ""_sh;
        myUseTargetIslandAttr = false;
        myTargetIslandAttr = "targetisland"_sh;
        myStackIslands = false;
        myStackMirrored = false;
        myStackOnNonGroup = false;
        myStackingLengthTolerance = 0.02;
        myGenerateNonpackedPolys = false;
        myNonpackedPolys = "nonpacked"_sh;
        myGenerateIslandAttr = false;
        myOutputIslandAttr = "island"_sh;
        myGenerateTargetAttr = false;
        myOutputTargetAttr = "target"_sh;

    }

    explicit SOP_UVLayout_3_0Parms(const SOP_UVLayout_3_0Parms &) = default;

    virtual ~SOP_UVLayout_3_0Parms() {}

    bool operator==(const SOP_UVLayout_3_0Parms &src) const
    {
        if (myUVAttr != src.myUVAttr) return false;
        if (myUVProjPlane != src.myUVProjPlane) return false;
        if (myGroup != src.myGroup) return false;
        if (mySeparatorEdges != src.mySeparatorEdges) return false;
        if (myUseIslandAttr != src.myUseIslandAttr) return false;
        if (myIslandAttr != src.myIslandAttr) return false;
        if (myUseTargetAttr != src.myUseTargetAttr) return false;
        if (myTargetAttr != src.myTargetAttr) return false;
        if (myTargetOverrides != src.myTargetOverrides) return false;
        if (myUseIslandScaleAttr != src.myUseIslandScaleAttr) return false;
        if (myIslandScaleAttr != src.myIslandScaleAttr) return false;
        if (myScaleOverrides != src.myScaleOverrides) return false;
        if (myUseIslandOffsetAttr != src.myUseIslandOffsetAttr) return false;
        if (myIslandOffsetAttr != src.myIslandOffsetAttr) return false;
        if (myOffsetOverrides != src.myOffsetOverrides) return false;
        if (myCorrectAreas != src.myCorrectAreas) return false;
        if (myAxisAlignment != src.myAxisAlignment) return false;
        if (myScaling != src.myScaling) return false;
        if (myScale != src.myScale) return false;
        if (myRotationStep != src.myRotationStep) return false;
        if (myCircleDivs != src.myCircleDivs) return false;
        if (myPackBetween != src.myPackBetween) return false;
        if (myPackInCavities != src.myPackInCavities) return false;
        if (myPadding != src.myPadding) return false;
        if (myPadBoundaries != src.myPadBoundaries) return false;
        if (myExpandPadding != src.myExpandPadding) return false;
        if (myIterations != src.myIterations) return false;
        if (myResolution != src.myResolution) return false;
        if (myCustomResolution != src.myCustomResolution) return false;
        if (myConnectivityTolerance != src.myConnectivityTolerance) return false;
        if (myScaleTolerance != src.myScaleTolerance) return false;
        if (myRandSeed != src.myRandSeed) return false;
        if (myTargetType != src.myTargetType) return false;
        if (myUseDefaultTarget != src.myUseDefaultTarget) return false;
        if (myDefaultTarget != src.myDefaultTarget) return false;
        if (myUseDefaultUdimTarget != src.myUseDefaultUdimTarget) return false;
        if (myDefaultUdimTarget != src.myDefaultUdimTarget) return false;
        if (myRects != src.myRects) return false;
        if (myTileSize != src.myTileSize) return false;
        if (myNumColumns != src.myNumColumns) return false;
        if (myStartingUdim != src.myStartingUdim) return false;
        if (myTargetUVAttr != src.myTargetUVAttr) return false;
        if (myTargetProjPlane != src.myTargetProjPlane) return false;
        if (myTargetGroup != src.myTargetGroup) return false;
        if (myTargetSeparatorEdges != src.myTargetSeparatorEdges) return false;
        if (myUseTargetIslandAttr != src.myUseTargetIslandAttr) return false;
        if (myTargetIslandAttr != src.myTargetIslandAttr) return false;
        if (myStackIslands != src.myStackIslands) return false;
        if (myStackMirrored != src.myStackMirrored) return false;
        if (myStackOnNonGroup != src.myStackOnNonGroup) return false;
        if (myStackingLengthTolerance != src.myStackingLengthTolerance) return false;
        if (myGenerateNonpackedPolys != src.myGenerateNonpackedPolys) return false;
        if (myNonpackedPolys != src.myNonpackedPolys) return false;
        if (myGenerateIslandAttr != src.myGenerateIslandAttr) return false;
        if (myOutputIslandAttr != src.myOutputIslandAttr) return false;
        if (myGenerateTargetAttr != src.myGenerateTargetAttr) return false;
        if (myOutputTargetAttr != src.myOutputTargetAttr) return false;

        return true;
    }
    bool operator!=(const SOP_UVLayout_3_0Parms &src) const
    {
        return !operator==(src);
    }
    using UVProjPlane = SOP_UVLayout_3_0Enums::UVProjPlane;
    using AxisAlignment = SOP_UVLayout_3_0Enums::AxisAlignment;
    using Scaling = SOP_UVLayout_3_0Enums::Scaling;
    using RotationStep = SOP_UVLayout_3_0Enums::RotationStep;
    using Resolution = SOP_UVLayout_3_0Enums::Resolution;
    using TargetType = SOP_UVLayout_3_0Enums::TargetType;
    using TargetProjPlane = SOP_UVLayout_3_0Enums::TargetProjPlane;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myUVAttr, node, "uvattrib", time, 0);
        else myUVAttr = "uv"_sh;
        if (true)
            OP_Utils::evalOpParm(myUVProjPlane, node, "projplane", time, 0);
        else myUVProjPlane = 0;
        if (true)
            OP_Utils::evalOpParm(myGroup, node, "group", time, 0);
        else myGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(mySeparatorEdges, node, "separatoredges", time, 0);
        else mySeparatorEdges = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUseIslandAttr, node, "useislandattr", time, 0);
        else myUseIslandAttr = false;
        if (true && ( (!(((getUseIslandAttr()==0)))) ) )
            OP_Utils::evalOpParm(myIslandAttr, node, "islandattr", time, 0);
        else myIslandAttr = "island"_sh;
        if (true)
            OP_Utils::evalOpParm(myUseTargetAttr, node, "usetargetattr", time, 0);
        else myUseTargetAttr = false;
        if (true && ( (!(((getUseTargetAttr()==0)))) ) )
            OP_Utils::evalOpParm(myTargetAttr, node, "targetattr", time, 0);
        else myTargetAttr = "udim"_sh;
        if (true)
            OP_Utils::evalOpParm(myTargetOverrides, node, "targetoverrides", time, 0);
        else myTargetOverrides = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUseIslandScaleAttr, node, "useislandscaleattr", time, 0);
        else myUseIslandScaleAttr = false;
        if (true && ( (!(((getUseIslandScaleAttr()==0)))) ) )
            OP_Utils::evalOpParm(myIslandScaleAttr, node, "islandscaleattr", time, 0);
        else myIslandScaleAttr = "iscale"_sh;
        if (true)
            OP_Utils::evalOpParm(myScaleOverrides, node, "scaleoverrides", time, 0);
        else myScaleOverrides = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUseIslandOffsetAttr, node, "useislandsetattr", time, 0);
        else myUseIslandOffsetAttr = false;
        if (true && ( (!(((getUseIslandOffsetAttr()==0)))) ) )
            OP_Utils::evalOpParm(myIslandOffsetAttr, node, "islandoffsetattr", time, 0);
        else myIslandOffsetAttr = "ioffset"_sh;
        if (true)
            OP_Utils::evalOpParm(myOffsetOverrides, node, "offsetoverrides", time, 0);
        else myOffsetOverrides = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myCorrectAreas, node, "correctareas", time, 0);
        else myCorrectAreas = false;
        if (true)
            OP_Utils::evalOpParm(myAxisAlignment, node, "axisalignislands", time, 0);
        else myAxisAlignment = 1;
        if (true)
            OP_Utils::evalOpParm(myScaling, node, "scaling", time, 0);
        else myScaling = 0;
        if (true && ( (!(((int64(getScaling())!=1)))) ) )
            OP_Utils::evalOpParm(myScale, node, "scale", time, 0);
        else myScale = 1;
        if (true)
            OP_Utils::evalOpParm(myRotationStep, node, "rotstep", time, 0);
        else myRotationStep = 0;
        if (true && ( (!(((int64(getRotationStep())!=7)))) ) )
            OP_Utils::evalOpParm(myCircleDivs, node, "circledivs", time, 0);
        else myCircleDivs = 1;
        if (true)
            OP_Utils::evalOpParm(myPackBetween, node, "packbetween", time, 0);
        else myPackBetween = false;
        if (true)
            OP_Utils::evalOpParm(myPackInCavities, node, "packincavities", time, 0);
        else myPackInCavities = false;
        if (true)
            OP_Utils::evalOpParm(myPadding, node, "padding", time, 0);
        else myPadding = 1;
        if (true)
            OP_Utils::evalOpParm(myPadBoundaries, node, "paddingboundary", time, 0);
        else myPadBoundaries = false;
        if (true)
            OP_Utils::evalOpParm(myExpandPadding, node, "expandpadding", time, 0);
        else myExpandPadding = false;
        if (true)
            OP_Utils::evalOpParm(myIterations, node, "iterations", time, 0);
        else myIterations = 1;
        if (true)
            OP_Utils::evalOpParm(myResolution, node, "resolution", time, 0);
        else myResolution = 2;
        if (true && ( (!(((int64(getResolution())!=5)))) ) )
            OP_Utils::evalOpParm(myCustomResolution, node, "customresolution", time, 0);
        else myCustomResolution = 1024;
        if (true)
            OP_Utils::evalOpParm(myConnectivityTolerance, node, "uvtolerance", time, 0);
        else myConnectivityTolerance = 1e-05;
        if (true && ( (!(((int64(getScaling())==1)))) ) )
            OP_Utils::evalOpParm(myScaleTolerance, node, "scaletolerance", time, 0);
        else myScaleTolerance = 0.005;
        if (true && ( (!(((int64(getIterations())==1)))) ) )
            OP_Utils::evalOpParm(myRandSeed, node, "randseed", time, 0);
        else myRandSeed = 5489;
        if (true)
            OP_Utils::evalOpParm(myTargetType, node, "targettype", time, 0);
        else myTargetType = 0;
        if (true && ( (!(((int64(getTargetType())==1)))) ) )
            OP_Utils::evalOpParm(myUseDefaultTarget, node, "usedefaulttarget", time, 0);
        else myUseDefaultTarget = false;
        if (true && ( (!(((getUseDefaultTarget()==0))||((int64(getTargetType())==1)))) ) )
            OP_Utils::evalOpParm(myDefaultTarget, node, "defaulttarget", time, 0);
        else myDefaultTarget = 0;
        if (true && ( (!(((int64(getTargetType())!=1)))) ) )
            OP_Utils::evalOpParm(myUseDefaultUdimTarget, node, "usedefaultudimtarget", time, 0);
        else myUseDefaultUdimTarget = false;
        if (true && ( (!(((getUseDefaultUdimTarget()==0))||((int64(getTargetType())!=1)))) ) )
            OP_Utils::evalOpParm(myDefaultUdimTarget, node, "defaultudimtarget", time, 0);
        else myDefaultUdimTarget = 1001;
            if (true && ( (!(((int64(getTargetType())!=0))||((int64(getTargetType())!=0)))) ) )
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "rects", time, 0);
                myRects.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myRects(i);
                    (void) _curentry;
                    if (true && ( (!(((int64(getTargetType())!=0))||((int64(getTargetType())!=0)))) )  && ( (!(((int64(getTargetType())!=0)))) ) )
                        OP_Utils::evalOpParmInst(myRects(i).rect_use, node, "rect_use#", &parmidx, time, 0);
                    else myRects(i).rect_use = false;
                    if (true && ( (!(((int64(getTargetType())!=0))||((int64(getTargetType())!=0)))) )  && ( (!(((int64(getTargetType())!=0))||((_curentry.rect_use==0)))) ) )
                        OP_Utils::evalOpParmInst(myRects(i).rect_center, node, "rect_center#", &parmidx, time, 0);
                    else myRects(i).rect_center = UT_Vector2D(0.5,0.5);
                    if (true && ( (!(((int64(getTargetType())!=0))||((int64(getTargetType())!=0)))) )  && ( (!(((int64(getTargetType())!=0))||((_curentry.rect_use==0)))) ) )
                        OP_Utils::evalOpParmInst(myRects(i).rect_size, node, "rect_size#", &parmidx, time, 0);
                    else myRects(i).rect_size = UT_Vector2D(1,1);

                }
            }
            else
                myRects.clear();
        if (true && ( (!(((int64(getTargetType())!=1)))) ) )
            OP_Utils::evalOpParm(myTileSize, node, "tilesize", time, 0);
        else myTileSize = UT_Vector2D(1,1);
        if (true && ( (!(((int64(getTargetType())!=1)))) ) )
            OP_Utils::evalOpParm(myNumColumns, node, "numcolumns", time, 0);
        else myNumColumns = 10;
        if (true && ( (!(((int64(getTargetType())!=1)))) ) )
            OP_Utils::evalOpParm(myStartingUdim, node, "startingudim", time, 0);
        else myStartingUdim = 1001;
        if (true && ( (!(((int64(getTargetType())!=2))||(((node->getInput(1)!=0)==0)))) ) )
            OP_Utils::evalOpParm(myTargetUVAttr, node, "targetuvattrib", time, 0);
        else myTargetUVAttr = "uv"_sh;
        if (true && ( (!(((int64(getTargetType())!=2))||(((node->getInput(1)!=0)==0)))) ) )
            OP_Utils::evalOpParm(myTargetProjPlane, node, "targetprojplane", time, 0);
        else myTargetProjPlane = 0;
        if (true && ( (!((((node->getInput(1)!=0)==0))||((int64(getTargetType())!=2)))) ) )
            OP_Utils::evalOpParm(myTargetGroup, node, "targetgroup", time, 0);
        else myTargetGroup = ""_sh;
        if (true && ( (!(((int64(getTargetType())!=2))||(((node->getInput(1)!=0)==0))||((int64(getTargetType())!=2)))) ) )
            OP_Utils::evalOpParm(myTargetSeparatorEdges, node, "targetseparatoredges", time, 0);
        else myTargetSeparatorEdges = ""_sh;
        if (true && ( (!(((int64(getTargetType())!=2))||(((node->getInput(1)!=0)==0))||((int64(getTargetType())!=2)))) ) )
            OP_Utils::evalOpParm(myUseTargetIslandAttr, node, "usetargetislandattr", time, 0);
        else myUseTargetIslandAttr = false;
        if (true && ( (!(((int64(getTargetType())!=2))||((getUseTargetIslandAttr()==0))||((int64(getTargetType())!=2)))) ) )
            OP_Utils::evalOpParm(myTargetIslandAttr, node, "targetislandattr", time, 0);
        else myTargetIslandAttr = "targetisland"_sh;
        if (true)
            OP_Utils::evalOpParm(myStackIslands, node, "stackislands", time, 0);
        else myStackIslands = false;
        if (true && ( (!(((getStackIslands()==0)))) ) )
            OP_Utils::evalOpParm(myStackMirrored, node, "invertedoverlays", time, 0);
        else myStackMirrored = false;
        if (true && ( (!(((getStackIslands()==0)))) ) )
            OP_Utils::evalOpParm(myStackOnNonGroup, node, "stackonnongroup", time, 0);
        else myStackOnNonGroup = false;
        if (true && ( (!(((getStackIslands()==0)))) ) )
            OP_Utils::evalOpParm(myStackingLengthTolerance, node, "overlaytolerance", time, 0);
        else myStackingLengthTolerance = 0.02;
        if (true)
            OP_Utils::evalOpParm(myGenerateNonpackedPolys, node, "generatenonpackedpoly", time, 0);
        else myGenerateNonpackedPolys = false;
        if (true && ( (!(((getGenerateNonpackedPolys()==0)))) ) )
            OP_Utils::evalOpParm(myNonpackedPolys, node, "nonpackedpolys", time, 0);
        else myNonpackedPolys = "nonpacked"_sh;
        if (true)
            OP_Utils::evalOpParm(myGenerateIslandAttr, node, "generateislandattr", time, 0);
        else myGenerateIslandAttr = false;
        if (true && ( (!(((getGenerateIslandAttr()==0)))) ) )
            OP_Utils::evalOpParm(myOutputIslandAttr, node, "outputislandattr", time, 0);
        else myOutputIslandAttr = "island"_sh;
        if (true)
            OP_Utils::evalOpParm(myGenerateTargetAttr, node, "generatetargetattr", time, 0);
        else myGenerateTargetAttr = false;
        if (true && ( (!(((getGenerateTargetAttr()==0)))) ) )
            OP_Utils::evalOpParm(myOutputTargetAttr, node, "outputtargetattr", time, 0);
        else myOutputTargetAttr = "target"_sh;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_UVLayout_3_0Parms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myUVAttr);
                break;
            case 1:
                coerceValue(value, myUVProjPlane);
                break;
            case 2:
                coerceValue(value, myGroup);
                break;
            case 3:
                coerceValue(value, mySeparatorEdges);
                break;
            case 4:
                coerceValue(value, myUseIslandAttr);
                break;
            case 5:
                coerceValue(value, myIslandAttr);
                break;
            case 6:
                coerceValue(value, myUseTargetAttr);
                break;
            case 7:
                coerceValue(value, myTargetAttr);
                break;
            case 8:
                coerceValue(value, myTargetOverrides);
                break;
            case 9:
                coerceValue(value, myUseIslandScaleAttr);
                break;
            case 10:
                coerceValue(value, myIslandScaleAttr);
                break;
            case 11:
                coerceValue(value, myScaleOverrides);
                break;
            case 12:
                coerceValue(value, myUseIslandOffsetAttr);
                break;
            case 13:
                coerceValue(value, myIslandOffsetAttr);
                break;
            case 14:
                coerceValue(value, myOffsetOverrides);
                break;
            case 15:
                coerceValue(value, myCorrectAreas);
                break;
            case 16:
                coerceValue(value, myAxisAlignment);
                break;
            case 17:
                coerceValue(value, myScaling);
                break;
            case 18:
                coerceValue(value, myScale);
                break;
            case 19:
                coerceValue(value, myRotationStep);
                break;
            case 20:
                coerceValue(value, myCircleDivs);
                break;
            case 21:
                coerceValue(value, myPackBetween);
                break;
            case 22:
                coerceValue(value, myPackInCavities);
                break;
            case 23:
                coerceValue(value, myPadding);
                break;
            case 24:
                coerceValue(value, myPadBoundaries);
                break;
            case 25:
                coerceValue(value, myExpandPadding);
                break;
            case 26:
                coerceValue(value, myIterations);
                break;
            case 27:
                coerceValue(value, myResolution);
                break;
            case 28:
                coerceValue(value, myCustomResolution);
                break;
            case 29:
                coerceValue(value, myConnectivityTolerance);
                break;
            case 30:
                coerceValue(value, myScaleTolerance);
                break;
            case 31:
                coerceValue(value, myRandSeed);
                break;
            case 32:
                coerceValue(value, myTargetType);
                break;
            case 33:
                coerceValue(value, myUseDefaultTarget);
                break;
            case 34:
                coerceValue(value, myDefaultTarget);
                break;
            case 35:
                coerceValue(value, myUseDefaultUdimTarget);
                break;
            case 36:
                coerceValue(value, myDefaultUdimTarget);
                break;
            case 38:
                coerceValue(value, myTileSize);
                break;
            case 39:
                coerceValue(value, myNumColumns);
                break;
            case 40:
                coerceValue(value, myStartingUdim);
                break;
            case 41:
                coerceValue(value, myTargetUVAttr);
                break;
            case 42:
                coerceValue(value, myTargetProjPlane);
                break;
            case 43:
                coerceValue(value, myTargetGroup);
                break;
            case 44:
                coerceValue(value, myTargetSeparatorEdges);
                break;
            case 45:
                coerceValue(value, myUseTargetIslandAttr);
                break;
            case 46:
                coerceValue(value, myTargetIslandAttr);
                break;
            case 47:
                coerceValue(value, myStackIslands);
                break;
            case 48:
                coerceValue(value, myStackMirrored);
                break;
            case 49:
                coerceValue(value, myStackOnNonGroup);
                break;
            case 50:
                coerceValue(value, myStackingLengthTolerance);
                break;
            case 51:
                coerceValue(value, myGenerateNonpackedPolys);
                break;
            case 52:
                coerceValue(value, myNonpackedPolys);
                break;
            case 53:
                coerceValue(value, myGenerateIslandAttr);
                break;
            case 54:
                coerceValue(value, myOutputIslandAttr);
                break;
            case 55:
                coerceValue(value, myGenerateTargetAttr);
                break;
            case 56:
                coerceValue(value, myOutputTargetAttr);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myUVAttr, value);
                break;
            case 1:
                coerceValue(myUVProjPlane, value);
                break;
            case 2:
                coerceValue(myGroup, value);
                break;
            case 3:
                coerceValue(mySeparatorEdges, value);
                break;
            case 4:
                coerceValue(myUseIslandAttr, value);
                break;
            case 5:
                coerceValue(myIslandAttr, value);
                break;
            case 6:
                coerceValue(myUseTargetAttr, value);
                break;
            case 7:
                coerceValue(myTargetAttr, value);
                break;
            case 8:
                coerceValue(myTargetOverrides, value);
                break;
            case 9:
                coerceValue(myUseIslandScaleAttr, value);
                break;
            case 10:
                coerceValue(myIslandScaleAttr, value);
                break;
            case 11:
                coerceValue(myScaleOverrides, value);
                break;
            case 12:
                coerceValue(myUseIslandOffsetAttr, value);
                break;
            case 13:
                coerceValue(myIslandOffsetAttr, value);
                break;
            case 14:
                coerceValue(myOffsetOverrides, value);
                break;
            case 15:
                coerceValue(myCorrectAreas, value);
                break;
            case 16:
                coerceValue(myAxisAlignment, value);
                break;
            case 17:
                coerceValue(myScaling, value);
                break;
            case 18:
                coerceValue(myScale, value);
                break;
            case 19:
                coerceValue(myRotationStep, value);
                break;
            case 20:
                coerceValue(myCircleDivs, value);
                break;
            case 21:
                coerceValue(myPackBetween, value);
                break;
            case 22:
                coerceValue(myPackInCavities, value);
                break;
            case 23:
                coerceValue(myPadding, value);
                break;
            case 24:
                coerceValue(myPadBoundaries, value);
                break;
            case 25:
                coerceValue(myExpandPadding, value);
                break;
            case 26:
                coerceValue(myIterations, value);
                break;
            case 27:
                coerceValue(myResolution, value);
                break;
            case 28:
                coerceValue(myCustomResolution, value);
                break;
            case 29:
                coerceValue(myConnectivityTolerance, value);
                break;
            case 30:
                coerceValue(myScaleTolerance, value);
                break;
            case 31:
                coerceValue(myRandSeed, value);
                break;
            case 32:
                coerceValue(myTargetType, value);
                break;
            case 33:
                coerceValue(myUseDefaultTarget, value);
                break;
            case 34:
                coerceValue(myDefaultTarget, value);
                break;
            case 35:
                coerceValue(myUseDefaultUdimTarget, value);
                break;
            case 36:
                coerceValue(myDefaultUdimTarget, value);
                break;
            case 38:
                coerceValue(myTileSize, value);
                break;
            case 39:
                coerceValue(myNumColumns, value);
                break;
            case 40:
                coerceValue(myStartingUdim, value);
                break;
            case 41:
                coerceValue(myTargetUVAttr, value);
                break;
            case 42:
                coerceValue(myTargetProjPlane, value);
                break;
            case 43:
                coerceValue(myTargetGroup, value);
                break;
            case 44:
                coerceValue(myTargetSeparatorEdges, value);
                break;
            case 45:
                coerceValue(myUseTargetIslandAttr, value);
                break;
            case 46:
                coerceValue(myTargetIslandAttr, value);
                break;
            case 47:
                coerceValue(myStackIslands, value);
                break;
            case 48:
                coerceValue(myStackMirrored, value);
                break;
            case 49:
                coerceValue(myStackOnNonGroup, value);
                break;
            case 50:
                coerceValue(myStackingLengthTolerance, value);
                break;
            case 51:
                coerceValue(myGenerateNonpackedPolys, value);
                break;
            case 52:
                coerceValue(myNonpackedPolys, value);
                break;
            case 53:
                coerceValue(myGenerateIslandAttr, value);
                break;
            case 54:
                coerceValue(myOutputIslandAttr, value);
                break;
            case 55:
                coerceValue(myGenerateTargetAttr, value);
                break;
            case 56:
                coerceValue(myOutputTargetAttr, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 57;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "uvattrib";
            case 1:
                return "projplane";
            case 2:
                return "group";
            case 3:
                return "separatoredges";
            case 4:
                return "useislandattr";
            case 5:
                return "islandattr";
            case 6:
                return "usetargetattr";
            case 7:
                return "targetattr";
            case 8:
                return "targetoverrides";
            case 9:
                return "useislandscaleattr";
            case 10:
                return "islandscaleattr";
            case 11:
                return "scaleoverrides";
            case 12:
                return "useislandsetattr";
            case 13:
                return "islandoffsetattr";
            case 14:
                return "offsetoverrides";
            case 15:
                return "correctareas";
            case 16:
                return "axisalignislands";
            case 17:
                return "scaling";
            case 18:
                return "scale";
            case 19:
                return "rotstep";
            case 20:
                return "circledivs";
            case 21:
                return "packbetween";
            case 22:
                return "packincavities";
            case 23:
                return "padding";
            case 24:
                return "paddingboundary";
            case 25:
                return "expandpadding";
            case 26:
                return "iterations";
            case 27:
                return "resolution";
            case 28:
                return "customresolution";
            case 29:
                return "uvtolerance";
            case 30:
                return "scaletolerance";
            case 31:
                return "randseed";
            case 32:
                return "targettype";
            case 33:
                return "usedefaulttarget";
            case 34:
                return "defaulttarget";
            case 35:
                return "usedefaultudimtarget";
            case 36:
                return "defaultudimtarget";
                case 37:
                    return "rects";
            case 38:
                return "tilesize";
            case 39:
                return "numcolumns";
            case 40:
                return "startingudim";
            case 41:
                return "targetuvattrib";
            case 42:
                return "targetprojplane";
            case 43:
                return "targetgroup";
            case 44:
                return "targetseparatoredges";
            case 45:
                return "usetargetislandattr";
            case 46:
                return "targetislandattr";
            case 47:
                return "stackislands";
            case 48:
                return "invertedoverlays";
            case 49:
                return "stackonnongroup";
            case 50:
                return "overlaytolerance";
            case 51:
                return "generatenonpackedpoly";
            case 52:
                return "nonpackedpolys";
            case 53:
                return "generateislandattr";
            case 54:
                return "outputislandattr";
            case 55:
                return "generatetargetattr";
            case 56:
                return "outputtargetattr";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_STRING;
                case 3:
                    return PARM_STRING;
                case 4:
                    return PARM_INTEGER;
                case 5:
                    return PARM_STRING;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_STRING;
                case 8:
                    return PARM_STRING;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_STRING;
                case 11:
                    return PARM_STRING;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_STRING;
                case 14:
                    return PARM_STRING;
                case 15:
                    return PARM_INTEGER;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_INTEGER;
                case 18:
                    return PARM_FLOAT;
                case 19:
                    return PARM_INTEGER;
                case 20:
                    return PARM_INTEGER;
                case 21:
                    return PARM_INTEGER;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_INTEGER;
                case 24:
                    return PARM_INTEGER;
                case 25:
                    return PARM_INTEGER;
                case 26:
                    return PARM_INTEGER;
                case 27:
                    return PARM_INTEGER;
                case 28:
                    return PARM_INTEGER;
                case 29:
                    return PARM_FLOAT;
                case 30:
                    return PARM_FLOAT;
                case 31:
                    return PARM_INTEGER;
                case 32:
                    return PARM_INTEGER;
                case 33:
                    return PARM_INTEGER;
                case 34:
                    return PARM_INTEGER;
                case 35:
                    return PARM_INTEGER;
                case 36:
                    return PARM_INTEGER;
                case 38:
                    return PARM_VECTOR2;
                case 39:
                    return PARM_INTEGER;
                case 40:
                    return PARM_INTEGER;
                case 41:
                    return PARM_STRING;
                case 42:
                    return PARM_INTEGER;
                case 43:
                    return PARM_STRING;
                case 44:
                    return PARM_STRING;
                case 45:
                    return PARM_INTEGER;
                case 46:
                    return PARM_STRING;
                case 47:
                    return PARM_INTEGER;
                case 48:
                    return PARM_INTEGER;
                case 49:
                    return PARM_INTEGER;
                case 50:
                    return PARM_FLOAT;
                case 51:
                    return PARM_INTEGER;
                case 52:
                    return PARM_STRING;
                case 53:
                    return PARM_INTEGER;
                case 54:
                    return PARM_STRING;
                case 55:
                    return PARM_INTEGER;
                case 56:
                    return PARM_STRING;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myUVAttr);
        saveData(os, myUVProjPlane);
        saveData(os, myGroup);
        saveData(os, mySeparatorEdges);
        saveData(os, myUseIslandAttr);
        saveData(os, myIslandAttr);
        saveData(os, myUseTargetAttr);
        saveData(os, myTargetAttr);
        saveData(os, myTargetOverrides);
        saveData(os, myUseIslandScaleAttr);
        saveData(os, myIslandScaleAttr);
        saveData(os, myScaleOverrides);
        saveData(os, myUseIslandOffsetAttr);
        saveData(os, myIslandOffsetAttr);
        saveData(os, myOffsetOverrides);
        saveData(os, myCorrectAreas);
        saveData(os, myAxisAlignment);
        saveData(os, myScaling);
        saveData(os, myScale);
        saveData(os, myRotationStep);
        saveData(os, myCircleDivs);
        saveData(os, myPackBetween);
        saveData(os, myPackInCavities);
        saveData(os, myPadding);
        saveData(os, myPadBoundaries);
        saveData(os, myExpandPadding);
        saveData(os, myIterations);
        saveData(os, myResolution);
        saveData(os, myCustomResolution);
        saveData(os, myConnectivityTolerance);
        saveData(os, myScaleTolerance);
        saveData(os, myRandSeed);
        saveData(os, myTargetType);
        saveData(os, myUseDefaultTarget);
        saveData(os, myDefaultTarget);
        saveData(os, myUseDefaultUdimTarget);
        saveData(os, myDefaultUdimTarget);
        {
            int64   length = myRects.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myRects(i).rect_use);
                saveData(os, myRects(i).rect_center);
                saveData(os, myRects(i).rect_size);

            }
        }
        saveData(os, myTileSize);
        saveData(os, myNumColumns);
        saveData(os, myStartingUdim);
        saveData(os, myTargetUVAttr);
        saveData(os, myTargetProjPlane);
        saveData(os, myTargetGroup);
        saveData(os, myTargetSeparatorEdges);
        saveData(os, myUseTargetIslandAttr);
        saveData(os, myTargetIslandAttr);
        saveData(os, myStackIslands);
        saveData(os, myStackMirrored);
        saveData(os, myStackOnNonGroup);
        saveData(os, myStackingLengthTolerance);
        saveData(os, myGenerateNonpackedPolys);
        saveData(os, myNonpackedPolys);
        saveData(os, myGenerateIslandAttr);
        saveData(os, myOutputIslandAttr);
        saveData(os, myGenerateTargetAttr);
        saveData(os, myOutputTargetAttr);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myUVAttr);
        loadData(is, myUVProjPlane);
        loadData(is, myGroup);
        loadData(is, mySeparatorEdges);
        loadData(is, myUseIslandAttr);
        loadData(is, myIslandAttr);
        loadData(is, myUseTargetAttr);
        loadData(is, myTargetAttr);
        loadData(is, myTargetOverrides);
        loadData(is, myUseIslandScaleAttr);
        loadData(is, myIslandScaleAttr);
        loadData(is, myScaleOverrides);
        loadData(is, myUseIslandOffsetAttr);
        loadData(is, myIslandOffsetAttr);
        loadData(is, myOffsetOverrides);
        loadData(is, myCorrectAreas);
        loadData(is, myAxisAlignment);
        loadData(is, myScaling);
        loadData(is, myScale);
        loadData(is, myRotationStep);
        loadData(is, myCircleDivs);
        loadData(is, myPackBetween);
        loadData(is, myPackInCavities);
        loadData(is, myPadding);
        loadData(is, myPadBoundaries);
        loadData(is, myExpandPadding);
        loadData(is, myIterations);
        loadData(is, myResolution);
        loadData(is, myCustomResolution);
        loadData(is, myConnectivityTolerance);
        loadData(is, myScaleTolerance);
        loadData(is, myRandSeed);
        loadData(is, myTargetType);
        loadData(is, myUseDefaultTarget);
        loadData(is, myDefaultTarget);
        loadData(is, myUseDefaultUdimTarget);
        loadData(is, myDefaultUdimTarget);
        {
            int64   length;
            is.read(&length, 1);
            myRects.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myRects(i).rect_use);
                loadData(is, myRects(i).rect_center);
                loadData(is, myRects(i).rect_size);

            }
        }
        loadData(is, myTileSize);
        loadData(is, myNumColumns);
        loadData(is, myStartingUdim);
        loadData(is, myTargetUVAttr);
        loadData(is, myTargetProjPlane);
        loadData(is, myTargetGroup);
        loadData(is, myTargetSeparatorEdges);
        loadData(is, myUseTargetIslandAttr);
        loadData(is, myTargetIslandAttr);
        loadData(is, myStackIslands);
        loadData(is, myStackMirrored);
        loadData(is, myStackOnNonGroup);
        loadData(is, myStackingLengthTolerance);
        loadData(is, myGenerateNonpackedPolys);
        loadData(is, myNonpackedPolys);
        loadData(is, myGenerateIslandAttr);
        loadData(is, myOutputIslandAttr);
        loadData(is, myGenerateTargetAttr);
        loadData(is, myOutputTargetAttr);

        return true;
    }

    const UT_StringHolder & getUVAttr() const { return myUVAttr; }
    void setUVAttr(const UT_StringHolder & val) { myUVAttr = val; }
    UT_StringHolder opUVAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUVAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "uvattrib", cookparms.getCookTime(), 0);
        return result;
    }
    UVProjPlane getUVProjPlane() const { return UVProjPlane(myUVProjPlane); }
    void setUVProjPlane(UVProjPlane val) { myUVProjPlane = int64(val); }
    UVProjPlane opUVProjPlane(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUVProjPlane();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "projplane", cookparms.getCookTime(), 0);
        return UVProjPlane(result);
    }
    const UT_StringHolder & getGroup() const { return myGroup; }
    void setGroup(const UT_StringHolder & val) { myGroup = val; }
    UT_StringHolder opGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "group", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getSeparatorEdges() const { return mySeparatorEdges; }
    void setSeparatorEdges(const UT_StringHolder & val) { mySeparatorEdges = val; }
    UT_StringHolder opSeparatorEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSeparatorEdges();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "separatoredges", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseIslandAttr() const { return myUseIslandAttr; }
    void setUseIslandAttr(bool val) { myUseIslandAttr = val; }
    bool opUseIslandAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseIslandAttr();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useislandattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getIslandAttr() const { return myIslandAttr; }
    void setIslandAttr(const UT_StringHolder & val) { myIslandAttr = val; }
    UT_StringHolder opIslandAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIslandAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "islandattr", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseTargetAttr() const { return myUseTargetAttr; }
    void setUseTargetAttr(bool val) { myUseTargetAttr = val; }
    bool opUseTargetAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseTargetAttr();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usetargetattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTargetAttr() const { return myTargetAttr; }
    void setTargetAttr(const UT_StringHolder & val) { myTargetAttr = val; }
    UT_StringHolder opTargetAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "targetattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTargetOverrides() const { return myTargetOverrides; }
    void setTargetOverrides(const UT_StringHolder & val) { myTargetOverrides = val; }
    UT_StringHolder opTargetOverrides(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetOverrides();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "targetoverrides", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseIslandScaleAttr() const { return myUseIslandScaleAttr; }
    void setUseIslandScaleAttr(bool val) { myUseIslandScaleAttr = val; }
    bool opUseIslandScaleAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseIslandScaleAttr();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useislandscaleattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getIslandScaleAttr() const { return myIslandScaleAttr; }
    void setIslandScaleAttr(const UT_StringHolder & val) { myIslandScaleAttr = val; }
    UT_StringHolder opIslandScaleAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIslandScaleAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "islandscaleattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getScaleOverrides() const { return myScaleOverrides; }
    void setScaleOverrides(const UT_StringHolder & val) { myScaleOverrides = val; }
    UT_StringHolder opScaleOverrides(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getScaleOverrides();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "scaleoverrides", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseIslandOffsetAttr() const { return myUseIslandOffsetAttr; }
    void setUseIslandOffsetAttr(bool val) { myUseIslandOffsetAttr = val; }
    bool opUseIslandOffsetAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseIslandOffsetAttr();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useislandsetattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getIslandOffsetAttr() const { return myIslandOffsetAttr; }
    void setIslandOffsetAttr(const UT_StringHolder & val) { myIslandOffsetAttr = val; }
    UT_StringHolder opIslandOffsetAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIslandOffsetAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "islandoffsetattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getOffsetOverrides() const { return myOffsetOverrides; }
    void setOffsetOverrides(const UT_StringHolder & val) { myOffsetOverrides = val; }
    UT_StringHolder opOffsetOverrides(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOffsetOverrides();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "offsetoverrides", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCorrectAreas() const { return myCorrectAreas; }
    void setCorrectAreas(bool val) { myCorrectAreas = val; }
    bool opCorrectAreas(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCorrectAreas();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "correctareas", cookparms.getCookTime(), 0);
        return result;
    }
    AxisAlignment getAxisAlignment() const { return AxisAlignment(myAxisAlignment); }
    void setAxisAlignment(AxisAlignment val) { myAxisAlignment = int64(val); }
    AxisAlignment opAxisAlignment(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAxisAlignment();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "axisalignislands", cookparms.getCookTime(), 0);
        return AxisAlignment(result);
    }
    Scaling getScaling() const { return Scaling(myScaling); }
    void setScaling(Scaling val) { myScaling = int64(val); }
    Scaling opScaling(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getScaling();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "scaling", cookparms.getCookTime(), 0);
        return Scaling(result);
    }
    fpreal64 getScale() const { return myScale; }
    void setScale(fpreal64 val) { myScale = val; }
    fpreal64 opScale(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getScale();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "scale", cookparms.getCookTime(), 0);
        return result;
    }
    RotationStep getRotationStep() const { return RotationStep(myRotationStep); }
    void setRotationStep(RotationStep val) { myRotationStep = int64(val); }
    RotationStep opRotationStep(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRotationStep();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "rotstep", cookparms.getCookTime(), 0);
        return RotationStep(result);
    }
    int64 getCircleDivs() const { return myCircleDivs; }
    void setCircleDivs(int64 val) { myCircleDivs = val; }
    int64 opCircleDivs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCircleDivs();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "circledivs", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPackBetween() const { return myPackBetween; }
    void setPackBetween(bool val) { myPackBetween = val; }
    bool opPackBetween(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPackBetween();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "packbetween", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPackInCavities() const { return myPackInCavities; }
    void setPackInCavities(bool val) { myPackInCavities = val; }
    bool opPackInCavities(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPackInCavities();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "packincavities", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getPadding() const { return myPadding; }
    void setPadding(int64 val) { myPadding = val; }
    int64 opPadding(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPadding();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "padding", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPadBoundaries() const { return myPadBoundaries; }
    void setPadBoundaries(bool val) { myPadBoundaries = val; }
    bool opPadBoundaries(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPadBoundaries();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "paddingboundary", cookparms.getCookTime(), 0);
        return result;
    }
    bool getExpandPadding() const { return myExpandPadding; }
    void setExpandPadding(bool val) { myExpandPadding = val; }
    bool opExpandPadding(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getExpandPadding();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "expandpadding", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getIterations() const { return myIterations; }
    void setIterations(int64 val) { myIterations = val; }
    int64 opIterations(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIterations();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "iterations", cookparms.getCookTime(), 0);
        return result;
    }
    Resolution getResolution() const { return Resolution(myResolution); }
    void setResolution(Resolution val) { myResolution = int64(val); }
    Resolution opResolution(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getResolution();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "resolution", cookparms.getCookTime(), 0);
        return Resolution(result);
    }
    int64 getCustomResolution() const { return myCustomResolution; }
    void setCustomResolution(int64 val) { myCustomResolution = val; }
    int64 opCustomResolution(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCustomResolution();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "customresolution", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getConnectivityTolerance() const { return myConnectivityTolerance; }
    void setConnectivityTolerance(fpreal64 val) { myConnectivityTolerance = val; }
    fpreal64 opConnectivityTolerance(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getConnectivityTolerance();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "uvtolerance", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getScaleTolerance() const { return myScaleTolerance; }
    void setScaleTolerance(fpreal64 val) { myScaleTolerance = val; }
    fpreal64 opScaleTolerance(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getScaleTolerance();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "scaletolerance", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getRandSeed() const { return myRandSeed; }
    void setRandSeed(int64 val) { myRandSeed = val; }
    int64 opRandSeed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandSeed();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "randseed", cookparms.getCookTime(), 0);
        return result;
    }
    TargetType getTargetType() const { return TargetType(myTargetType); }
    void setTargetType(TargetType val) { myTargetType = int64(val); }
    TargetType opTargetType(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetType();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "targettype", cookparms.getCookTime(), 0);
        return TargetType(result);
    }
    bool getUseDefaultTarget() const { return myUseDefaultTarget; }
    void setUseDefaultTarget(bool val) { myUseDefaultTarget = val; }
    bool opUseDefaultTarget(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseDefaultTarget();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usedefaulttarget", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getDefaultTarget() const { return myDefaultTarget; }
    void setDefaultTarget(int64 val) { myDefaultTarget = val; }
    int64 opDefaultTarget(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDefaultTarget();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "defaulttarget", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseDefaultUdimTarget() const { return myUseDefaultUdimTarget; }
    void setUseDefaultUdimTarget(bool val) { myUseDefaultUdimTarget = val; }
    bool opUseDefaultUdimTarget(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseDefaultUdimTarget();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usedefaultudimtarget", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getDefaultUdimTarget() const { return myDefaultUdimTarget; }
    void setDefaultUdimTarget(int64 val) { myDefaultUdimTarget = val; }
    int64 opDefaultUdimTarget(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDefaultUdimTarget();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "defaultudimtarget", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Rects> &getRects() const { return myRects; }
    void setRects(const UT_Array<Rects> &val) { myRects = val; }
    exint opRects(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRects().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "rects", cookparms.getCookTime(), 0);
        return result;
    }
            bool opRects_rect_use(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myRects(_idx).rect_use);
            int _parmidx = _idx + 0;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "rect_use#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_Vector2D opRects_rect_center(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myRects(_idx).rect_center);
            int _parmidx = _idx + 0;
            UT_Vector2D result;
            OP_Utils::evalOpParmInst(result, thissop, "rect_center#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_Vector2D opRects_rect_size(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myRects(_idx).rect_size);
            int _parmidx = _idx + 0;
            UT_Vector2D result;
            OP_Utils::evalOpParmInst(result, thissop, "rect_size#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    UT_Vector2D getTileSize() const { return myTileSize; }
    void setTileSize(UT_Vector2D val) { myTileSize = val; }
    UT_Vector2D opTileSize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTileSize();
        UT_Vector2D result;
        OP_Utils::evalOpParm(result, thissop, "tilesize", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getNumColumns() const { return myNumColumns; }
    void setNumColumns(int64 val) { myNumColumns = val; }
    int64 opNumColumns(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNumColumns();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "numcolumns", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getStartingUdim() const { return myStartingUdim; }
    void setStartingUdim(int64 val) { myStartingUdim = val; }
    int64 opStartingUdim(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStartingUdim();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "startingudim", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTargetUVAttr() const { return myTargetUVAttr; }
    void setTargetUVAttr(const UT_StringHolder & val) { myTargetUVAttr = val; }
    UT_StringHolder opTargetUVAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetUVAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "targetuvattrib", cookparms.getCookTime(), 0);
        return result;
    }
    TargetProjPlane getTargetProjPlane() const { return TargetProjPlane(myTargetProjPlane); }
    void setTargetProjPlane(TargetProjPlane val) { myTargetProjPlane = int64(val); }
    TargetProjPlane opTargetProjPlane(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetProjPlane();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "targetprojplane", cookparms.getCookTime(), 0);
        return TargetProjPlane(result);
    }
    const UT_StringHolder & getTargetGroup() const { return myTargetGroup; }
    void setTargetGroup(const UT_StringHolder & val) { myTargetGroup = val; }
    UT_StringHolder opTargetGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "targetgroup", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTargetSeparatorEdges() const { return myTargetSeparatorEdges; }
    void setTargetSeparatorEdges(const UT_StringHolder & val) { myTargetSeparatorEdges = val; }
    UT_StringHolder opTargetSeparatorEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetSeparatorEdges();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "targetseparatoredges", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseTargetIslandAttr() const { return myUseTargetIslandAttr; }
    void setUseTargetIslandAttr(bool val) { myUseTargetIslandAttr = val; }
    bool opUseTargetIslandAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseTargetIslandAttr();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usetargetislandattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTargetIslandAttr() const { return myTargetIslandAttr; }
    void setTargetIslandAttr(const UT_StringHolder & val) { myTargetIslandAttr = val; }
    UT_StringHolder opTargetIslandAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetIslandAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "targetislandattr", cookparms.getCookTime(), 0);
        return result;
    }
    bool getStackIslands() const { return myStackIslands; }
    void setStackIslands(bool val) { myStackIslands = val; }
    bool opStackIslands(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStackIslands();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "stackislands", cookparms.getCookTime(), 0);
        return result;
    }
    bool getStackMirrored() const { return myStackMirrored; }
    void setStackMirrored(bool val) { myStackMirrored = val; }
    bool opStackMirrored(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStackMirrored();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "invertedoverlays", cookparms.getCookTime(), 0);
        return result;
    }
    bool getStackOnNonGroup() const { return myStackOnNonGroup; }
    void setStackOnNonGroup(bool val) { myStackOnNonGroup = val; }
    bool opStackOnNonGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStackOnNonGroup();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "stackonnongroup", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getStackingLengthTolerance() const { return myStackingLengthTolerance; }
    void setStackingLengthTolerance(fpreal64 val) { myStackingLengthTolerance = val; }
    fpreal64 opStackingLengthTolerance(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStackingLengthTolerance();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "overlaytolerance", cookparms.getCookTime(), 0);
        return result;
    }
    bool getGenerateNonpackedPolys() const { return myGenerateNonpackedPolys; }
    void setGenerateNonpackedPolys(bool val) { myGenerateNonpackedPolys = val; }
    bool opGenerateNonpackedPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGenerateNonpackedPolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "generatenonpackedpoly", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getNonpackedPolys() const { return myNonpackedPolys; }
    void setNonpackedPolys(const UT_StringHolder & val) { myNonpackedPolys = val; }
    UT_StringHolder opNonpackedPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNonpackedPolys();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "nonpackedpolys", cookparms.getCookTime(), 0);
        return result;
    }
    bool getGenerateIslandAttr() const { return myGenerateIslandAttr; }
    void setGenerateIslandAttr(bool val) { myGenerateIslandAttr = val; }
    bool opGenerateIslandAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGenerateIslandAttr();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "generateislandattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getOutputIslandAttr() const { return myOutputIslandAttr; }
    void setOutputIslandAttr(const UT_StringHolder & val) { myOutputIslandAttr = val; }
    UT_StringHolder opOutputIslandAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputIslandAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "outputislandattr", cookparms.getCookTime(), 0);
        return result;
    }
    bool getGenerateTargetAttr() const { return myGenerateTargetAttr; }
    void setGenerateTargetAttr(bool val) { myGenerateTargetAttr = val; }
    bool opGenerateTargetAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGenerateTargetAttr();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "generatetargetattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getOutputTargetAttr() const { return myOutputTargetAttr; }
    void setOutputTargetAttr(const UT_StringHolder & val) { myOutputTargetAttr = val; }
    UT_StringHolder opOutputTargetAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputTargetAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "outputtargetattr", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myUVAttr;
    int64 myUVProjPlane;
    UT_StringHolder myGroup;
    UT_StringHolder mySeparatorEdges;
    bool myUseIslandAttr;
    UT_StringHolder myIslandAttr;
    bool myUseTargetAttr;
    UT_StringHolder myTargetAttr;
    UT_StringHolder myTargetOverrides;
    bool myUseIslandScaleAttr;
    UT_StringHolder myIslandScaleAttr;
    UT_StringHolder myScaleOverrides;
    bool myUseIslandOffsetAttr;
    UT_StringHolder myIslandOffsetAttr;
    UT_StringHolder myOffsetOverrides;
    bool myCorrectAreas;
    int64 myAxisAlignment;
    int64 myScaling;
    fpreal64 myScale;
    int64 myRotationStep;
    int64 myCircleDivs;
    bool myPackBetween;
    bool myPackInCavities;
    int64 myPadding;
    bool myPadBoundaries;
    bool myExpandPadding;
    int64 myIterations;
    int64 myResolution;
    int64 myCustomResolution;
    fpreal64 myConnectivityTolerance;
    fpreal64 myScaleTolerance;
    int64 myRandSeed;
    int64 myTargetType;
    bool myUseDefaultTarget;
    int64 myDefaultTarget;
    bool myUseDefaultUdimTarget;
    int64 myDefaultUdimTarget;
    UT_Array<Rects> myRects;
    UT_Vector2D myTileSize;
    int64 myNumColumns;
    int64 myStartingUdim;
    UT_StringHolder myTargetUVAttr;
    int64 myTargetProjPlane;
    UT_StringHolder myTargetGroup;
    UT_StringHolder myTargetSeparatorEdges;
    bool myUseTargetIslandAttr;
    UT_StringHolder myTargetIslandAttr;
    bool myStackIslands;
    bool myStackMirrored;
    bool myStackOnNonGroup;
    fpreal64 myStackingLengthTolerance;
    bool myGenerateNonpackedPolys;
    UT_StringHolder myNonpackedPolys;
    bool myGenerateIslandAttr;
    UT_StringHolder myOutputIslandAttr;
    bool myGenerateTargetAttr;
    UT_StringHolder myOutputTargetAttr;

};
