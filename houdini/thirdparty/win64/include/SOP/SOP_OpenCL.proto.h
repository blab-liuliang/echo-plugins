/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_OpenCLEnums
{
    enum class RunOver
    {
        ATTRIBUTE = 0,
        VOLUME,
        WORKSETS
    };
    enum class Timemethod
    {
        INVERT = 0,
        POW
    };
    enum class Bindings_type
    {
        INT = 0,
        FLOAT,
        FLOAT3,
        FLOAT4,
        RAMP,
        ATTRIBUTE,
        VOLUME
    };
    enum class Bindings_timescale
    {
        NONE = 0,
        MULT,
        INVERT,
        POW
    };
    enum class Bindings_attribclass
    {
        DETAIL = 0,
        PRIMITIVE,
        POINT,
        VERTEX
    };
    enum class Bindings_attribtype
    {
        FLOAT = 0,
        INT,
        FLOATARRAY,
        INTARRAY
    };
}


class SOP_API SOP_OpenCLParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }
    struct Bindings
    {
        UT_StringHolder bindings_name;
        int64 bindings_type;
        int64 bindings_intval;
        fpreal64 bindings_fval;
        UT_Vector3D bindings_v3val;
        UT_Vector4D bindings_v4val;
        int64 bindings_timescale;
        UT_SharedPtr<UT_Ramp> bindings_ramp;
        int64 bindings_rampsize;
        UT_StringHolder bindings_volume;
        bool bindings_forcealign;
        bool bindings_resolution;
        bool bindings_voxelsize;
        bool bindings_xformtoworld;
        bool bindings_xformtovoxel;
        UT_StringHolder bindings_attribute;
        int64 bindings_attribclass;
        int64 bindings_attribtype;
        int64 bindings_attribsize;
        bool bindings_readable;
        bool bindings_writeable;
        bool bindings_optional;


        Bindings()
        {
            bindings_name = ""_sh;
            bindings_type = 0;
            bindings_intval = 0;
            bindings_fval = 0;
            bindings_v3val = UT_Vector3D(0,0,0);
            bindings_v4val = UT_Vector4D(0,0,0,0);
            bindings_timescale = 0;
            bindings_ramp = UT_SharedPtr<UT_Ramp>(0);
            bindings_rampsize = 1024;
            bindings_volume = ""_sh;
            bindings_forcealign = false;
            bindings_resolution = false;
            bindings_voxelsize = false;
            bindings_xformtoworld = false;
            bindings_xformtovoxel = false;
            bindings_attribute = ""_sh;
            bindings_attribclass = 2;
            bindings_attribtype = 0;
            bindings_attribsize = 1;
            bindings_readable = false;
            bindings_writeable = false;
            bindings_optional = false;

        }

        bool operator==(const Bindings &src) const
        {
            if (bindings_name != src.bindings_name) return false;
            if (bindings_type != src.bindings_type) return false;
            if (bindings_intval != src.bindings_intval) return false;
            if (bindings_fval != src.bindings_fval) return false;
            if (bindings_v3val != src.bindings_v3val) return false;
            if (bindings_v4val != src.bindings_v4val) return false;
            if (bindings_timescale != src.bindings_timescale) return false;
            if (bindings_ramp != src.bindings_ramp)
            { if (!bindings_ramp || !src.bindings_ramp || !(*bindings_ramp == *src.bindings_ramp)) return false; }
            if (bindings_rampsize != src.bindings_rampsize) return false;
            if (bindings_volume != src.bindings_volume) return false;
            if (bindings_forcealign != src.bindings_forcealign) return false;
            if (bindings_resolution != src.bindings_resolution) return false;
            if (bindings_voxelsize != src.bindings_voxelsize) return false;
            if (bindings_xformtoworld != src.bindings_xformtoworld) return false;
            if (bindings_xformtovoxel != src.bindings_xformtovoxel) return false;
            if (bindings_attribute != src.bindings_attribute) return false;
            if (bindings_attribclass != src.bindings_attribclass) return false;
            if (bindings_attribtype != src.bindings_attribtype) return false;
            if (bindings_attribsize != src.bindings_attribsize) return false;
            if (bindings_readable != src.bindings_readable) return false;
            if (bindings_writeable != src.bindings_writeable) return false;
            if (bindings_optional != src.bindings_optional) return false;

            return true;
        }
        bool operator!=(const Bindings &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Bindings> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            { UT_String tmp; tmp = UT_StringWrap(list(i).bindings_name).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).bindings_type);
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).bindings_intval);
            buf.append(", ");
            buf.appendSprintf("%f", (list(i).bindings_fval));
            buf.append(", ");
            buf.appendSprintf("(%f, %f, %f)", list(i).bindings_v3val.x(), list(i).bindings_v3val.y(), list(i).bindings_v3val.z());
            buf.append(", ");
            buf.appendSprintf("(%f, %f, %f, %f)", list(i).bindings_v4val.x(), list(i).bindings_v4val.y(), list(i).bindings_v4val.z(), list(i).bindings_v4val.w());
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).bindings_timescale);
            buf.append(", ");
            if (list(i).bindings_ramp)
            {
                UT_OStringStream os;
                UT_String tmp;
                list(i).bindings_ramp->save(os);
                tmp = UT_StringWrap(os.str().buffer()).makeQuotedString('"');
                buf.strcat(tmp);
            }
            else buf.strcat("""");
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).bindings_rampsize);
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).bindings_volume).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            buf.appendSprintf("%s", (list(i).bindings_forcealign) ? "true" : "false");
            buf.append(", ");
            buf.appendSprintf("%s", (list(i).bindings_resolution) ? "true" : "false");
            buf.append(", ");
            buf.appendSprintf("%s", (list(i).bindings_voxelsize) ? "true" : "false");
            buf.append(", ");
            buf.appendSprintf("%s", (list(i).bindings_xformtoworld) ? "true" : "false");
            buf.append(", ");
            buf.appendSprintf("%s", (list(i).bindings_xformtovoxel) ? "true" : "false");
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).bindings_attribute).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).bindings_attribclass);
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).bindings_attribtype);
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).bindings_attribsize);
            buf.append(", ");
            buf.appendSprintf("%s", (list(i).bindings_readable) ? "true" : "false");
            buf.append(", ");
            buf.appendSprintf("%s", (list(i).bindings_writeable) ? "true" : "false");
            buf.append(", ");
            buf.appendSprintf("%s", (list(i).bindings_optional) ? "true" : "false");

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }

    SOP_OpenCLParms()
    {
        myKernelname = "kernelName"_sh;
        myUsecode = false;
        myKernelfile = ""_sh;
        myKernelcode = ""_sh;
        myKerneloptions = ""_sh;
        myUsewritebackkernel = false;
        myWritebackkernelname = "writeBack"_sh;
        myRecompile = false;
        myRunOver = 0;
        myIterations = 1;
        myWorksets_begin = ""_sh;
        myWorksets_length = ""_sh;
        myFinish = true;
        myTime = false;
        myTimeinc = false;
        myTimescale = 1;
        myTimemethod = 0;
        myXnoise = false;

    }

    explicit SOP_OpenCLParms(const SOP_OpenCLParms &) = default;

    virtual ~SOP_OpenCLParms() {}

    bool operator==(const SOP_OpenCLParms &src) const
    {
        if (myKernelname != src.myKernelname) return false;
        if (myUsecode != src.myUsecode) return false;
        if (myKernelfile != src.myKernelfile) return false;
        if (myKernelcode != src.myKernelcode) return false;
        if (myKerneloptions != src.myKerneloptions) return false;
        if (myUsewritebackkernel != src.myUsewritebackkernel) return false;
        if (myWritebackkernelname != src.myWritebackkernelname) return false;
        if (myRecompile != src.myRecompile) return false;
        if (myRunOver != src.myRunOver) return false;
        if (myIterations != src.myIterations) return false;
        if (myWorksets_begin != src.myWorksets_begin) return false;
        if (myWorksets_length != src.myWorksets_length) return false;
        if (myFinish != src.myFinish) return false;
        if (myTime != src.myTime) return false;
        if (myTimeinc != src.myTimeinc) return false;
        if (myTimescale != src.myTimescale) return false;
        if (myTimemethod != src.myTimemethod) return false;
        if (myXnoise != src.myXnoise) return false;
        if (myBindings != src.myBindings) return false;

        return true;
    }
    bool operator!=(const SOP_OpenCLParms &src) const
    {
        return !operator==(src);
    }
    using RunOver = SOP_OpenCLEnums::RunOver;
    using Timemethod = SOP_OpenCLEnums::Timemethod;
    using Bindings_type = SOP_OpenCLEnums::Bindings_type;
    using Bindings_timescale = SOP_OpenCLEnums::Bindings_timescale;
    using Bindings_attribclass = SOP_OpenCLEnums::Bindings_attribclass;
    using Bindings_attribtype = SOP_OpenCLEnums::Bindings_attribtype;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myKernelname, node, "kernelname", time, 0);
        else myKernelname = "kernelName"_sh;
        if (true)
            OP_Utils::evalOpParm(myUsecode, node, "usecode", time, 0);
        else myUsecode = false;
        if (true && ( (!(((getUsecode()!=0)))) ) )
            OP_Utils::evalOpParm(myKernelfile, node, "kernelfile", time, 0);
        else myKernelfile = ""_sh;
        if (true && ( (!(((getUsecode()==0)))) ) )
            OP_Utils::evalOpParm(myKernelcode, node, "kernelcode", time, 0);
        else myKernelcode = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myKerneloptions, node, "kerneloptions", time, 0);
        else myKerneloptions = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUsewritebackkernel, node, "usewritebackkernel", time, 0);
        else myUsewritebackkernel = false;
        if (true && ( (!(((getUsewritebackkernel()==0)))) ) )
            OP_Utils::evalOpParm(myWritebackkernelname, node, "writebackkernelname", time, 0);
        else myWritebackkernelname = "writeBack"_sh;
        if (true)
            OP_Utils::evalOpParm(myRecompile, node, "recompile", time, 0);
        else myRecompile = false;
        if (true)
            OP_Utils::evalOpParm(myRunOver, node, "runover", time, 0);
        else myRunOver = 0;
        if (true)
            OP_Utils::evalOpParm(myIterations, node, "iterations", time, 0);
        else myIterations = 1;
        if (true && ( (!(((int64(getRunOver())!=2)))) ) )
            OP_Utils::evalOpParm(myWorksets_begin, node, "worksets_begin", time, 0);
        else myWorksets_begin = ""_sh;
        if (true && ( (!(((int64(getRunOver())!=2)))) ) )
            OP_Utils::evalOpParm(myWorksets_length, node, "worksets_length", time, 0);
        else myWorksets_length = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myFinish, node, "finish", time, 0);
        else myFinish = true;
        if (true)
            OP_Utils::evalOpParm(myTime, node, "time", time, 0);
        else myTime = false;
        if (true)
            OP_Utils::evalOpParm(myTimeinc, node, "timeinc", time, 0);
        else myTimeinc = false;
        if (true && ( (!(((getTimeinc()==0)))) ) )
            OP_Utils::evalOpParm(myTimescale, node, "timescale", time, 0);
        else myTimescale = 1;
        if (true && ( (!(((getTimeinc()==0)))) ) )
            OP_Utils::evalOpParm(myTimemethod, node, "timemethod", time, 0);
        else myTimemethod = 0;
        if (true)
            OP_Utils::evalOpParm(myXnoise, node, "xnoise", time, 0);
        else myXnoise = false;
            if (true)
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "bindings", time, 0);
                myBindings.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+1;
                    auto && _curentry = myBindings(i);
                    (void) _curentry;
                    if (true)
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_name, node, "bindings#_name", &parmidx, time, 0);
                    else myBindings(i).bindings_name = ""_sh;
                    if (true)
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_type, node, "bindings#_type", &parmidx, time, 0);
                    else myBindings(i).bindings_type = 0;
                    if (true && ( (!(((_curentry.bindings_type!=0)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_intval, node, "bindings#_intval", &parmidx, time, 0);
                    else myBindings(i).bindings_intval = 0;
                    if (true && ( (!(((_curentry.bindings_type!=1)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_fval, node, "bindings#_fval", &parmidx, time, 0);
                    else myBindings(i).bindings_fval = 0;
                    if (true && ( (!(((_curentry.bindings_type!=2)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_v3val, node, "bindings#_v3val", &parmidx, time, 0);
                    else myBindings(i).bindings_v3val = UT_Vector3D(0,0,0);
                    if (true && ( (!(((_curentry.bindings_type!=3)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_v4val, node, "bindings#_v4val", &parmidx, time, 0);
                    else myBindings(i).bindings_v4val = UT_Vector4D(0,0,0,0);
                    if (true && ( (!(((_curentry.bindings_type!=1)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_timescale, node, "bindings#_timescale", &parmidx, time, 0);
                    else myBindings(i).bindings_timescale = 0;
                    if (true && ( (!(((_curentry.bindings_type!=4)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_ramp, node, "bindings#_ramp", &parmidx, time, 0);
                    else myBindings(i).bindings_ramp = UT_SharedPtr<UT_Ramp>(0);
                    if (true && ( (!(((_curentry.bindings_type!=4)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_rampsize, node, "bindings#_rampsize", &parmidx, time, 0);
                    else myBindings(i).bindings_rampsize = 1024;
                    if (true && ( (!(((_curentry.bindings_type!=6)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_volume, node, "bindings#_volume", &parmidx, time, 0);
                    else myBindings(i).bindings_volume = ""_sh;
                    if (true && ( (!(((_curentry.bindings_type!=6)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_forcealign, node, "bindings#_forcealign", &parmidx, time, 0);
                    else myBindings(i).bindings_forcealign = false;
                    if (true && ( (!(((_curentry.bindings_type!=6))||((_curentry.bindings_forcealign==1)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_resolution, node, "bindings#_resolution", &parmidx, time, 0);
                    else myBindings(i).bindings_resolution = false;
                    if (true && ( (!(((_curentry.bindings_type!=6))||((_curentry.bindings_forcealign==1)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_voxelsize, node, "bindings#_voxelsize", &parmidx, time, 0);
                    else myBindings(i).bindings_voxelsize = false;
                    if (true && ( (!(((_curentry.bindings_type!=6))||((_curentry.bindings_forcealign==1)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_xformtoworld, node, "bindings#_xformtoworld", &parmidx, time, 0);
                    else myBindings(i).bindings_xformtoworld = false;
                    if (true && ( (!(((_curentry.bindings_type!=6))||((_curentry.bindings_forcealign==1)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_xformtovoxel, node, "bindings#_xformtovoxel", &parmidx, time, 0);
                    else myBindings(i).bindings_xformtovoxel = false;
                    if (true && ( (!(((_curentry.bindings_type!=5)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_attribute, node, "bindings#_attribute", &parmidx, time, 0);
                    else myBindings(i).bindings_attribute = ""_sh;
                    if (true && ( (!(((_curentry.bindings_type!=5)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_attribclass, node, "bindings#_attribclass", &parmidx, time, 0);
                    else myBindings(i).bindings_attribclass = 2;
                    if (true && ( (!(((_curentry.bindings_type!=5)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_attribtype, node, "bindings#_attribtype", &parmidx, time, 0);
                    else myBindings(i).bindings_attribtype = 0;
                    if (true && ( (!(((_curentry.bindings_type!=5)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_attribsize, node, "bindings#_attribsize", &parmidx, time, 0);
                    else myBindings(i).bindings_attribsize = 1;
                    if (true && ( (!(((_curentry.bindings_type!=5)&&(_curentry.bindings_type!=6)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_readable, node, "bindings#_readable", &parmidx, time, 0);
                    else myBindings(i).bindings_readable = false;
                    if (true && ( (!(((_curentry.bindings_type!=5)&&(_curentry.bindings_type!=6)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_writeable, node, "bindings#_writeable", &parmidx, time, 0);
                    else myBindings(i).bindings_writeable = false;
                    if (true && ( (!(((_curentry.bindings_type!=5)&&(_curentry.bindings_type!=6)))) ) )
                        OP_Utils::evalOpParmInst(myBindings(i).bindings_optional, node, "bindings#_optional", &parmidx, time, 0);
                    else myBindings(i).bindings_optional = false;

                }
            }
            else
                myBindings.clear();

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_OpenCLParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myKernelname);
                break;
            case 1:
                coerceValue(value, myUsecode);
                break;
            case 2:
                coerceValue(value, myKernelfile);
                break;
            case 3:
                coerceValue(value, myKernelcode);
                break;
            case 4:
                coerceValue(value, myKerneloptions);
                break;
            case 5:
                coerceValue(value, myUsewritebackkernel);
                break;
            case 6:
                coerceValue(value, myWritebackkernelname);
                break;
            case 7:
                coerceValue(value, myRecompile);
                break;
            case 8:
                coerceValue(value, myRunOver);
                break;
            case 9:
                coerceValue(value, myIterations);
                break;
            case 10:
                coerceValue(value, myWorksets_begin);
                break;
            case 11:
                coerceValue(value, myWorksets_length);
                break;
            case 12:
                coerceValue(value, myFinish);
                break;
            case 13:
                coerceValue(value, myTime);
                break;
            case 14:
                coerceValue(value, myTimeinc);
                break;
            case 15:
                coerceValue(value, myTimescale);
                break;
            case 16:
                coerceValue(value, myTimemethod);
                break;
            case 17:
                coerceValue(value, myXnoise);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myKernelname, value);
                break;
            case 1:
                coerceValue(myUsecode, value);
                break;
            case 2:
                coerceValue(myKernelfile, value);
                break;
            case 3:
                coerceValue(myKernelcode, value);
                break;
            case 4:
                coerceValue(myKerneloptions, value);
                break;
            case 5:
                coerceValue(myUsewritebackkernel, value);
                break;
            case 6:
                coerceValue(myWritebackkernelname, value);
                break;
            case 7:
                coerceValue(myRecompile, value);
                break;
            case 8:
                coerceValue(myRunOver, value);
                break;
            case 9:
                coerceValue(myIterations, value);
                break;
            case 10:
                coerceValue(myWorksets_begin, value);
                break;
            case 11:
                coerceValue(myWorksets_length, value);
                break;
            case 12:
                coerceValue(myFinish, value);
                break;
            case 13:
                coerceValue(myTime, value);
                break;
            case 14:
                coerceValue(myTimeinc, value);
                break;
            case 15:
                coerceValue(myTimescale, value);
                break;
            case 16:
                coerceValue(myTimemethod, value);
                break;
            case 17:
                coerceValue(myXnoise, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 19;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "kernelname";
            case 1:
                return "usecode";
            case 2:
                return "kernelfile";
            case 3:
                return "kernelcode";
            case 4:
                return "kerneloptions";
            case 5:
                return "usewritebackkernel";
            case 6:
                return "writebackkernelname";
            case 7:
                return "recompile";
            case 8:
                return "runover";
            case 9:
                return "iterations";
            case 10:
                return "worksets_begin";
            case 11:
                return "worksets_length";
            case 12:
                return "finish";
            case 13:
                return "time";
            case 14:
                return "timeinc";
            case 15:
                return "timescale";
            case 16:
                return "timemethod";
            case 17:
                return "xnoise";
                case 18:
                    return "bindings";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_STRING;
                case 3:
                    return PARM_STRING;
                case 4:
                    return PARM_STRING;
                case 5:
                    return PARM_INTEGER;
                case 6:
                    return PARM_STRING;
                case 7:
                    return PARM_INTEGER;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_STRING;
                case 11:
                    return PARM_STRING;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_INTEGER;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_FLOAT;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_INTEGER;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myKernelname);
        saveData(os, myUsecode);
        saveData(os, myKernelfile);
        saveData(os, myKernelcode);
        saveData(os, myKerneloptions);
        saveData(os, myUsewritebackkernel);
        saveData(os, myWritebackkernelname);
        saveData(os, myRecompile);
        saveData(os, myRunOver);
        saveData(os, myIterations);
        saveData(os, myWorksets_begin);
        saveData(os, myWorksets_length);
        saveData(os, myFinish);
        saveData(os, myTime);
        saveData(os, myTimeinc);
        saveData(os, myTimescale);
        saveData(os, myTimemethod);
        saveData(os, myXnoise);
        {
            int64   length = myBindings.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myBindings(i).bindings_name);
                saveData(os, myBindings(i).bindings_type);
                saveData(os, myBindings(i).bindings_intval);
                saveData(os, myBindings(i).bindings_fval);
                saveData(os, myBindings(i).bindings_v3val);
                saveData(os, myBindings(i).bindings_v4val);
                saveData(os, myBindings(i).bindings_timescale);
                saveData(os, myBindings(i).bindings_ramp);
                saveData(os, myBindings(i).bindings_rampsize);
                saveData(os, myBindings(i).bindings_volume);
                saveData(os, myBindings(i).bindings_forcealign);
                saveData(os, myBindings(i).bindings_resolution);
                saveData(os, myBindings(i).bindings_voxelsize);
                saveData(os, myBindings(i).bindings_xformtoworld);
                saveData(os, myBindings(i).bindings_xformtovoxel);
                saveData(os, myBindings(i).bindings_attribute);
                saveData(os, myBindings(i).bindings_attribclass);
                saveData(os, myBindings(i).bindings_attribtype);
                saveData(os, myBindings(i).bindings_attribsize);
                saveData(os, myBindings(i).bindings_readable);
                saveData(os, myBindings(i).bindings_writeable);
                saveData(os, myBindings(i).bindings_optional);

            }
        }

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myKernelname);
        loadData(is, myUsecode);
        loadData(is, myKernelfile);
        loadData(is, myKernelcode);
        loadData(is, myKerneloptions);
        loadData(is, myUsewritebackkernel);
        loadData(is, myWritebackkernelname);
        loadData(is, myRecompile);
        loadData(is, myRunOver);
        loadData(is, myIterations);
        loadData(is, myWorksets_begin);
        loadData(is, myWorksets_length);
        loadData(is, myFinish);
        loadData(is, myTime);
        loadData(is, myTimeinc);
        loadData(is, myTimescale);
        loadData(is, myTimemethod);
        loadData(is, myXnoise);
        {
            int64   length;
            is.read(&length, 1);
            myBindings.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myBindings(i).bindings_name);
                loadData(is, myBindings(i).bindings_type);
                loadData(is, myBindings(i).bindings_intval);
                loadData(is, myBindings(i).bindings_fval);
                loadData(is, myBindings(i).bindings_v3val);
                loadData(is, myBindings(i).bindings_v4val);
                loadData(is, myBindings(i).bindings_timescale);
                loadData(is, myBindings(i).bindings_ramp);
                loadData(is, myBindings(i).bindings_rampsize);
                loadData(is, myBindings(i).bindings_volume);
                loadData(is, myBindings(i).bindings_forcealign);
                loadData(is, myBindings(i).bindings_resolution);
                loadData(is, myBindings(i).bindings_voxelsize);
                loadData(is, myBindings(i).bindings_xformtoworld);
                loadData(is, myBindings(i).bindings_xformtovoxel);
                loadData(is, myBindings(i).bindings_attribute);
                loadData(is, myBindings(i).bindings_attribclass);
                loadData(is, myBindings(i).bindings_attribtype);
                loadData(is, myBindings(i).bindings_attribsize);
                loadData(is, myBindings(i).bindings_readable);
                loadData(is, myBindings(i).bindings_writeable);
                loadData(is, myBindings(i).bindings_optional);

            }
        }

        return true;
    }

    const UT_StringHolder & getKernelname() const { return myKernelname; }
    void setKernelname(const UT_StringHolder & val) { myKernelname = val; }
    UT_StringHolder opKernelname(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getKernelname();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "kernelname", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUsecode() const { return myUsecode; }
    void setUsecode(bool val) { myUsecode = val; }
    bool opUsecode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUsecode();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usecode", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getKernelfile() const { return myKernelfile; }
    void setKernelfile(const UT_StringHolder & val) { myKernelfile = val; }
    UT_StringHolder opKernelfile(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getKernelfile();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "kernelfile", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getKernelcode() const { return myKernelcode; }
    void setKernelcode(const UT_StringHolder & val) { myKernelcode = val; }
    UT_StringHolder opKernelcode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getKernelcode();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "kernelcode", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getKerneloptions() const { return myKerneloptions; }
    void setKerneloptions(const UT_StringHolder & val) { myKerneloptions = val; }
    UT_StringHolder opKerneloptions(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getKerneloptions();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "kerneloptions", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUsewritebackkernel() const { return myUsewritebackkernel; }
    void setUsewritebackkernel(bool val) { myUsewritebackkernel = val; }
    bool opUsewritebackkernel(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUsewritebackkernel();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usewritebackkernel", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getWritebackkernelname() const { return myWritebackkernelname; }
    void setWritebackkernelname(const UT_StringHolder & val) { myWritebackkernelname = val; }
    UT_StringHolder opWritebackkernelname(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getWritebackkernelname();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "writebackkernelname", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRecompile() const { return myRecompile; }
    void setRecompile(bool val) { myRecompile = val; }
    bool opRecompile(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRecompile();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "recompile", cookparms.getCookTime(), 0);
        return result;
    }
    RunOver getRunOver() const { return RunOver(myRunOver); }
    void setRunOver(RunOver val) { myRunOver = int64(val); }
    RunOver opRunOver(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRunOver();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "runover", cookparms.getCookTime(), 0);
        return RunOver(result);
    }
    int64 getIterations() const { return myIterations; }
    void setIterations(int64 val) { myIterations = val; }
    int64 opIterations(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIterations();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "iterations", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getWorksets_begin() const { return myWorksets_begin; }
    void setWorksets_begin(const UT_StringHolder & val) { myWorksets_begin = val; }
    UT_StringHolder opWorksets_begin(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getWorksets_begin();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "worksets_begin", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getWorksets_length() const { return myWorksets_length; }
    void setWorksets_length(const UT_StringHolder & val) { myWorksets_length = val; }
    UT_StringHolder opWorksets_length(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getWorksets_length();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "worksets_length", cookparms.getCookTime(), 0);
        return result;
    }
    bool getFinish() const { return myFinish; }
    void setFinish(bool val) { myFinish = val; }
    bool opFinish(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getFinish();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "finish", cookparms.getCookTime(), 0);
        return result;
    }
    bool getTime() const { return myTime; }
    void setTime(bool val) { myTime = val; }
    bool opTime(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTime();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "time", cookparms.getCookTime(), 0);
        return result;
    }
    bool getTimeinc() const { return myTimeinc; }
    void setTimeinc(bool val) { myTimeinc = val; }
    bool opTimeinc(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTimeinc();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "timeinc", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getTimescale() const { return myTimescale; }
    void setTimescale(fpreal64 val) { myTimescale = val; }
    fpreal64 opTimescale(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTimescale();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "timescale", cookparms.getCookTime(), 0);
        return result;
    }
    Timemethod getTimemethod() const { return Timemethod(myTimemethod); }
    void setTimemethod(Timemethod val) { myTimemethod = int64(val); }
    Timemethod opTimemethod(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTimemethod();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "timemethod", cookparms.getCookTime(), 0);
        return Timemethod(result);
    }
    bool getXnoise() const { return myXnoise; }
    void setXnoise(bool val) { myXnoise = val; }
    bool opXnoise(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getXnoise();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "xnoise", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Bindings> &getBindings() const { return myBindings; }
    void setBindings(const UT_Array<Bindings> &val) { myBindings = val; }
    exint opBindings(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBindings().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "bindings", cookparms.getCookTime(), 0);
        return result;
    }
            UT_StringHolder opBindings_bindings_name(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_name);
            int _parmidx = _idx + 1;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_name", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opBindings_bindings_type(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_type);
            int _parmidx = _idx + 1;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_type", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opBindings_bindings_intval(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_intval);
            int _parmidx = _idx + 1;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_intval", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        fpreal64 opBindings_bindings_fval(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_fval);
            int _parmidx = _idx + 1;
            fpreal64 result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_fval", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_Vector3D opBindings_bindings_v3val(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_v3val);
            int _parmidx = _idx + 1;
            UT_Vector3D result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_v3val", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_Vector4D opBindings_bindings_v4val(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_v4val);
            int _parmidx = _idx + 1;
            UT_Vector4D result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_v4val", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opBindings_bindings_timescale(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_timescale);
            int _parmidx = _idx + 1;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_timescale", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_SharedPtr<UT_Ramp> opBindings_bindings_ramp(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_ramp);
            int _parmidx = _idx + 1;
            UT_SharedPtr<UT_Ramp> result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_ramp", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opBindings_bindings_rampsize(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_rampsize);
            int _parmidx = _idx + 1;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_rampsize", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opBindings_bindings_volume(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_volume);
            int _parmidx = _idx + 1;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_volume", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        bool opBindings_bindings_forcealign(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_forcealign);
            int _parmidx = _idx + 1;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_forcealign", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        bool opBindings_bindings_resolution(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_resolution);
            int _parmidx = _idx + 1;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_resolution", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        bool opBindings_bindings_voxelsize(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_voxelsize);
            int _parmidx = _idx + 1;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_voxelsize", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        bool opBindings_bindings_xformtoworld(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_xformtoworld);
            int _parmidx = _idx + 1;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_xformtoworld", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        bool opBindings_bindings_xformtovoxel(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_xformtovoxel);
            int _parmidx = _idx + 1;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_xformtovoxel", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opBindings_bindings_attribute(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_attribute);
            int _parmidx = _idx + 1;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_attribute", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opBindings_bindings_attribclass(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_attribclass);
            int _parmidx = _idx + 1;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_attribclass", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opBindings_bindings_attribtype(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_attribtype);
            int _parmidx = _idx + 1;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_attribtype", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opBindings_bindings_attribsize(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_attribsize);
            int _parmidx = _idx + 1;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_attribsize", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        bool opBindings_bindings_readable(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_readable);
            int _parmidx = _idx + 1;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_readable", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        bool opBindings_bindings_writeable(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_writeable);
            int _parmidx = _idx + 1;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_writeable", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        bool opBindings_bindings_optional(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myBindings(_idx).bindings_optional);
            int _parmidx = _idx + 1;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "bindings#_optional", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }


private:
    UT_StringHolder myKernelname;
    bool myUsecode;
    UT_StringHolder myKernelfile;
    UT_StringHolder myKernelcode;
    UT_StringHolder myKerneloptions;
    bool myUsewritebackkernel;
    UT_StringHolder myWritebackkernelname;
    bool myRecompile;
    int64 myRunOver;
    int64 myIterations;
    UT_StringHolder myWorksets_begin;
    UT_StringHolder myWorksets_length;
    bool myFinish;
    bool myTime;
    bool myTimeinc;
    fpreal64 myTimescale;
    int64 myTimemethod;
    bool myXnoise;
    UT_Array<Bindings> myBindings;

};
