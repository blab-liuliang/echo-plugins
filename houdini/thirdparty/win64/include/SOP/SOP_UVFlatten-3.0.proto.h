/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_UVFlatten_3_0Enums
{
    enum class Method
    {
        SCP = 0,
        ABF
    };
    enum class Align_axis
    {
        UAXIS = 0,
        VAXIS
    };
    enum class Lalign_axis
    {
        UAXIS = 0,
        VAXIS
    };
}


class SOP_API SOP_UVFlatten_3_0Parms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }
    struct Pins
    {
        bool usepin;
        UT_Vector2D primvert;
        UT_Vector2D pinuv;
        UT_Vector2D pinrefuv;


        Pins()
        {
            usepin = false;
            primvert = UT_Vector2D(0,0);
            pinuv = UT_Vector2D(0,0);
            pinrefuv = UT_Vector2D(0,0);

        }

        bool operator==(const Pins &src) const
        {
            if (usepin != src.usepin) return false;
            if (primvert != src.primvert) return false;
            if (pinuv != src.pinuv) return false;
            if (pinrefuv != src.pinrefuv) return false;

            return true;
        }
        bool operator!=(const Pins &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Pins> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            buf.appendSprintf("%s", (list(i).usepin) ? "true" : "false");
            buf.append(", ");
            buf.appendSprintf("(%f, %f)", list(i).primvert.x(), list(i).primvert.y());
            buf.append(", ");
            buf.appendSprintf("(%f, %f)", list(i).pinuv.x(), list(i).pinuv.y());
            buf.append(", ");
            buf.appendSprintf("(%f, %f)", list(i).pinrefuv.x(), list(i).pinrefuv.y());

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }
    struct Alignments
    {
        bool align_enabled;
        UT_StringHolder align_group;
        int64 align_axis;


        Alignments()
        {
            align_enabled = false;
            align_group = ""_sh;
            align_axis = 0;

        }

        bool operator==(const Alignments &src) const
        {
            if (align_enabled != src.align_enabled) return false;
            if (align_group != src.align_group) return false;
            if (align_axis != src.align_axis) return false;

            return true;
        }
        bool operator!=(const Alignments &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Alignments> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            buf.appendSprintf("%s", (list(i).align_enabled) ? "true" : "false");
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).align_group).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).align_axis);

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }
    struct Straightenings
    {
        bool straight_enabled;
        UT_StringHolder straight_group;


        Straightenings()
        {
            straight_enabled = false;
            straight_group = ""_sh;

        }

        bool operator==(const Straightenings &src) const
        {
            if (straight_enabled != src.straight_enabled) return false;
            if (straight_group != src.straight_group) return false;

            return true;
        }
        bool operator!=(const Straightenings &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Straightenings> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            buf.appendSprintf("%s", (list(i).straight_enabled) ? "true" : "false");
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).straight_group).makeQuotedString('"'); buf.strcat(tmp); }

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }
    struct Lpins
    {
        UT_Vector2D lprimvert;
        UT_Vector2D lpinuv;
        UT_Vector2D lpinrefuv;


        Lpins()
        {
            lprimvert = UT_Vector2D(0,0);
            lpinuv = UT_Vector2D(0,0);
            lpinrefuv = UT_Vector2D(0,0);

        }

        bool operator==(const Lpins &src) const
        {
            if (lprimvert != src.lprimvert) return false;
            if (lpinuv != src.lpinuv) return false;
            if (lpinrefuv != src.lpinrefuv) return false;

            return true;
        }
        bool operator!=(const Lpins &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Lpins> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            buf.appendSprintf("(%f, %f)", list(i).lprimvert.x(), list(i).lprimvert.y());
            buf.append(", ");
            buf.appendSprintf("(%f, %f)", list(i).lpinuv.x(), list(i).lpinuv.y());
            buf.append(", ");
            buf.appendSprintf("(%f, %f)", list(i).lpinrefuv.x(), list(i).lpinrefuv.y());

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }
    struct Lalignments
    {
        UT_StringHolder lalign_group;
        int64 lalign_axis;


        Lalignments()
        {
            lalign_group = ""_sh;
            lalign_axis = 0;

        }

        bool operator==(const Lalignments &src) const
        {
            if (lalign_group != src.lalign_group) return false;
            if (lalign_axis != src.lalign_axis) return false;

            return true;
        }
        bool operator!=(const Lalignments &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Lalignments> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            { UT_String tmp; tmp = UT_StringWrap(list(i).lalign_group).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).lalign_axis);

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }
    struct Lstraightenings
    {
        UT_StringHolder lstraight_group;


        Lstraightenings()
        {
            lstraight_group = ""_sh;

        }

        bool operator==(const Lstraightenings &src) const
        {
            if (lstraight_group != src.lstraight_group) return false;

            return true;
        }
        bool operator!=(const Lstraightenings &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Lstraightenings> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            { UT_String tmp; tmp = UT_StringWrap(list(i).lstraight_group).makeQuotedString('"'); buf.strcat(tmp); }

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }

    SOP_UVFlatten_3_0Parms()
    {
        myGroup = ""_sh;
        myUVAttrib = "uv"_sh;
        myMethod = 0;
        myKeepExistingSeams = false;
        myKeepExistingLayout = false;
        myPinBoundaries = false;
        mySeams = ""_sh;
        myRectifyGroup = ""_sh;
        myUsePins = false;
        myUseAlignments = false;
        myUseStraightenings = false;
        myManualLayout = false;
        myLayoutSeams = ""_sh;
        myLayoutRectifyGroup = ""_sh;
        myUseOutputSeams = false;
        myOutputSeams = "outputseams"_sh;
        myUseOutputConstrIslands = false;
        myOutputConstrIslands = "constrainedprims"_sh;
        myBboxCenter = UT_Vector2D(0.5,0.5);
        myBboxSize = UT_Vector2D(1,1);

    }

    explicit SOP_UVFlatten_3_0Parms(const SOP_UVFlatten_3_0Parms &) = default;

    virtual ~SOP_UVFlatten_3_0Parms() {}

    bool operator==(const SOP_UVFlatten_3_0Parms &src) const
    {
        if (myGroup != src.myGroup) return false;
        if (myUVAttrib != src.myUVAttrib) return false;
        if (myMethod != src.myMethod) return false;
        if (myKeepExistingSeams != src.myKeepExistingSeams) return false;
        if (myKeepExistingLayout != src.myKeepExistingLayout) return false;
        if (myPinBoundaries != src.myPinBoundaries) return false;
        if (mySeams != src.mySeams) return false;
        if (myRectifyGroup != src.myRectifyGroup) return false;
        if (myUsePins != src.myUsePins) return false;
        if (myPins != src.myPins) return false;
        if (myUseAlignments != src.myUseAlignments) return false;
        if (myAlignments != src.myAlignments) return false;
        if (myUseStraightenings != src.myUseStraightenings) return false;
        if (myStraightenings != src.myStraightenings) return false;
        if (myManualLayout != src.myManualLayout) return false;
        if (myLayoutSeams != src.myLayoutSeams) return false;
        if (myLayoutRectifyGroup != src.myLayoutRectifyGroup) return false;
        if (myLpins != src.myLpins) return false;
        if (myLalignments != src.myLalignments) return false;
        if (myLstraightenings != src.myLstraightenings) return false;
        if (myUseOutputSeams != src.myUseOutputSeams) return false;
        if (myOutputSeams != src.myOutputSeams) return false;
        if (myUseOutputConstrIslands != src.myUseOutputConstrIslands) return false;
        if (myOutputConstrIslands != src.myOutputConstrIslands) return false;
        if (myBboxCenter != src.myBboxCenter) return false;
        if (myBboxSize != src.myBboxSize) return false;

        return true;
    }
    bool operator!=(const SOP_UVFlatten_3_0Parms &src) const
    {
        return !operator==(src);
    }
    using Method = SOP_UVFlatten_3_0Enums::Method;
    using Align_axis = SOP_UVFlatten_3_0Enums::Align_axis;
    using Lalign_axis = SOP_UVFlatten_3_0Enums::Lalign_axis;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myGroup, node, "group", time, 0);
        else myGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUVAttrib, node, "uvattrib", time, 0);
        else myUVAttrib = "uv"_sh;
        if (true)
            OP_Utils::evalOpParm(myMethod, node, "method", time, 0);
        else myMethod = 0;
        if (true)
            OP_Utils::evalOpParm(myKeepExistingSeams, node, "keepexistingseams", time, 0);
        else myKeepExistingSeams = false;
        if (true && ( (!(((getKeepExistingSeams()==0)))) ) )
            OP_Utils::evalOpParm(myKeepExistingLayout, node, "keepexistinglayout", time, 0);
        else myKeepExistingLayout = false;
        if (true && ( (!(((getKeepExistingSeams()==0))||((int64(getMethod())!=0)))) ) )
            OP_Utils::evalOpParm(myPinBoundaries, node, "pinboundaries", time, 0);
        else myPinBoundaries = false;
        if (true)
            OP_Utils::evalOpParm(mySeams, node, "seamgroup", time, 0);
        else mySeams = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myRectifyGroup, node, "rectifygroup", time, 0);
        else myRectifyGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUsePins, node, "usepins", time, 0);
        else myUsePins = false;
            if (true && ( (!(((getUsePins()==0)))) ) )
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "pins", time, 0);
                myPins.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myPins(i);
                    (void) _curentry;
                    if (true && ( (!(((getUsePins()==0)))) ) )
                        OP_Utils::evalOpParmInst(myPins(i).usepin, node, "usepin#", &parmidx, time, 0);
                    else myPins(i).usepin = false;
                    if (true && ( (!(((getUsePins()==0)))) ) )
                        OP_Utils::evalOpParmInst(myPins(i).primvert, node, "primvert#", &parmidx, time, 0);
                    else myPins(i).primvert = UT_Vector2D(0,0);
                    if (true && ( (!(((getUsePins()==0)))) ) )
                        OP_Utils::evalOpParmInst(myPins(i).pinuv, node, "pinuv#", &parmidx, time, 0);
                    else myPins(i).pinuv = UT_Vector2D(0,0);
                    if (true && ( (!(((getUsePins()==0)))) ) )
                        OP_Utils::evalOpParmInst(myPins(i).pinrefuv, node, "pinrefuv#", &parmidx, time, 0);
                    else myPins(i).pinrefuv = UT_Vector2D(0,0);

                }
            }
            else
                myPins.clear();
        if (true)
            OP_Utils::evalOpParm(myUseAlignments, node, "usealignments", time, 0);
        else myUseAlignments = false;
            if (true && ( (!(((getUseAlignments()==0)))) ) )
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "alignments", time, 0);
                myAlignments.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myAlignments(i);
                    (void) _curentry;
                    if (true && ( (!(((getUseAlignments()==0)))) ) )
                        OP_Utils::evalOpParmInst(myAlignments(i).align_enabled, node, "align_enabled#", &parmidx, time, 0);
                    else myAlignments(i).align_enabled = false;
                    if (true && ( (!(((getUseAlignments()==0)))) ) )
                        OP_Utils::evalOpParmInst(myAlignments(i).align_group, node, "align_group#", &parmidx, time, 0);
                    else myAlignments(i).align_group = ""_sh;
                    if (true && ( (!(((getUseAlignments()==0)))) ) )
                        OP_Utils::evalOpParmInst(myAlignments(i).align_axis, node, "align_axis#", &parmidx, time, 0);
                    else myAlignments(i).align_axis = 0;

                }
            }
            else
                myAlignments.clear();
        if (true)
            OP_Utils::evalOpParm(myUseStraightenings, node, "usestraightenings", time, 0);
        else myUseStraightenings = false;
            if (true && ( (!(((getUseStraightenings()==0)))) ) )
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "straightenings", time, 0);
                myStraightenings.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myStraightenings(i);
                    (void) _curentry;
                    if (true && ( (!(((getUseStraightenings()==0)))) ) )
                        OP_Utils::evalOpParmInst(myStraightenings(i).straight_enabled, node, "straight_enabled#", &parmidx, time, 0);
                    else myStraightenings(i).straight_enabled = false;
                    if (true && ( (!(((getUseStraightenings()==0)))) ) )
                        OP_Utils::evalOpParmInst(myStraightenings(i).straight_group, node, "straight_group#", &parmidx, time, 0);
                    else myStraightenings(i).straight_group = ""_sh;

                }
            }
            else
                myStraightenings.clear();
        if (true)
            OP_Utils::evalOpParm(myManualLayout, node, "manuallayout", time, 0);
        else myManualLayout = false;
        if (true && ( (!(((getManualLayout()==0)))) ) )
            OP_Utils::evalOpParm(myLayoutSeams, node, "layoutseamgroup", time, 0);
        else myLayoutSeams = ""_sh;
        if (true && ( (!(((getManualLayout()==0)))) ) )
            OP_Utils::evalOpParm(myLayoutRectifyGroup, node, "layoutrectifygroup", time, 0);
        else myLayoutRectifyGroup = ""_sh;
            if (true && ( (!(((getManualLayout()==0))||((getManualLayout()==0)))) ) )
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "lpins", time, 0);
                myLpins.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myLpins(i);
                    (void) _curentry;
                    if (true && ( (!(((getManualLayout()==0))||((getManualLayout()==0)))) )  && ( (!(((getManualLayout()==0)))) ) )
                        OP_Utils::evalOpParmInst(myLpins(i).lprimvert, node, "lprimvert#", &parmidx, time, 0);
                    else myLpins(i).lprimvert = UT_Vector2D(0,0);
                    if (true && ( (!(((getManualLayout()==0))||((getManualLayout()==0)))) )  && ( (!(((getManualLayout()==0)))) ) )
                        OP_Utils::evalOpParmInst(myLpins(i).lpinuv, node, "lpinuv#", &parmidx, time, 0);
                    else myLpins(i).lpinuv = UT_Vector2D(0,0);
                    if (true && ( (!(((getManualLayout()==0))||((getManualLayout()==0)))) )  && ( (!(((getManualLayout()==0)))) ) )
                        OP_Utils::evalOpParmInst(myLpins(i).lpinrefuv, node, "lpinrefuv#", &parmidx, time, 0);
                    else myLpins(i).lpinrefuv = UT_Vector2D(0,0);

                }
            }
            else
                myLpins.clear();
            if (true && ( (!(((getManualLayout()==0))||((getManualLayout()==0)))) ) )
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "lalignments", time, 0);
                myLalignments.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myLalignments(i);
                    (void) _curentry;
                    if (true && ( (!(((getManualLayout()==0))||((getManualLayout()==0)))) )  && ( (!(((getManualLayout()==0)))) ) )
                        OP_Utils::evalOpParmInst(myLalignments(i).lalign_group, node, "lalign_group#", &parmidx, time, 0);
                    else myLalignments(i).lalign_group = ""_sh;
                    if (true && ( (!(((getManualLayout()==0))||((getManualLayout()==0)))) )  && ( (!(((getManualLayout()==0)))) ) )
                        OP_Utils::evalOpParmInst(myLalignments(i).lalign_axis, node, "lalign_axis#", &parmidx, time, 0);
                    else myLalignments(i).lalign_axis = 0;

                }
            }
            else
                myLalignments.clear();
            if (true && ( (!(((getManualLayout()==0))||((getManualLayout()==0)))) ) )
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "lstraightenings", time, 0);
                myLstraightenings.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myLstraightenings(i);
                    (void) _curentry;
                    if (true && ( (!(((getManualLayout()==0))||((getManualLayout()==0)))) )  && ( (!(((getManualLayout()==0)))) ) )
                        OP_Utils::evalOpParmInst(myLstraightenings(i).lstraight_group, node, "lstraight_group#", &parmidx, time, 0);
                    else myLstraightenings(i).lstraight_group = ""_sh;

                }
            }
            else
                myLstraightenings.clear();
        if (true)
            OP_Utils::evalOpParm(myUseOutputSeams, node, "useoutputseams", time, 0);
        else myUseOutputSeams = false;
        if (true && ( (!(((getUseOutputSeams()==0)))) ) )
            OP_Utils::evalOpParm(myOutputSeams, node, "outputseams", time, 0);
        else myOutputSeams = "outputseams"_sh;
        if (true)
            OP_Utils::evalOpParm(myUseOutputConstrIslands, node, "useoutputconstrislands", time, 0);
        else myUseOutputConstrIslands = false;
        if (true && ( (!(((getUseOutputConstrIslands()==0)))) ) )
            OP_Utils::evalOpParm(myOutputConstrIslands, node, "outputconstrislands", time, 0);
        else myOutputConstrIslands = "constrainedprims"_sh;
        if (true)
            OP_Utils::evalOpParm(myBboxCenter, node, "bboxcenter", time, 0);
        else myBboxCenter = UT_Vector2D(0.5,0.5);
        if (true)
            OP_Utils::evalOpParm(myBboxSize, node, "bboxsize", time, 0);
        else myBboxSize = UT_Vector2D(1,1);

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_UVFlatten_3_0Parms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myGroup);
                break;
            case 1:
                coerceValue(value, myUVAttrib);
                break;
            case 2:
                coerceValue(value, myMethod);
                break;
            case 3:
                coerceValue(value, myKeepExistingSeams);
                break;
            case 4:
                coerceValue(value, myKeepExistingLayout);
                break;
            case 5:
                coerceValue(value, myPinBoundaries);
                break;
            case 6:
                coerceValue(value, mySeams);
                break;
            case 7:
                coerceValue(value, myRectifyGroup);
                break;
            case 8:
                coerceValue(value, myUsePins);
                break;
            case 10:
                coerceValue(value, myUseAlignments);
                break;
            case 12:
                coerceValue(value, myUseStraightenings);
                break;
            case 14:
                coerceValue(value, myManualLayout);
                break;
            case 15:
                coerceValue(value, myLayoutSeams);
                break;
            case 16:
                coerceValue(value, myLayoutRectifyGroup);
                break;
            case 20:
                coerceValue(value, myUseOutputSeams);
                break;
            case 21:
                coerceValue(value, myOutputSeams);
                break;
            case 22:
                coerceValue(value, myUseOutputConstrIslands);
                break;
            case 23:
                coerceValue(value, myOutputConstrIslands);
                break;
            case 24:
                coerceValue(value, myBboxCenter);
                break;
            case 25:
                coerceValue(value, myBboxSize);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myGroup, value);
                break;
            case 1:
                coerceValue(myUVAttrib, value);
                break;
            case 2:
                coerceValue(myMethod, value);
                break;
            case 3:
                coerceValue(myKeepExistingSeams, value);
                break;
            case 4:
                coerceValue(myKeepExistingLayout, value);
                break;
            case 5:
                coerceValue(myPinBoundaries, value);
                break;
            case 6:
                coerceValue(mySeams, value);
                break;
            case 7:
                coerceValue(myRectifyGroup, value);
                break;
            case 8:
                coerceValue(myUsePins, value);
                break;
            case 10:
                coerceValue(myUseAlignments, value);
                break;
            case 12:
                coerceValue(myUseStraightenings, value);
                break;
            case 14:
                coerceValue(myManualLayout, value);
                break;
            case 15:
                coerceValue(myLayoutSeams, value);
                break;
            case 16:
                coerceValue(myLayoutRectifyGroup, value);
                break;
            case 20:
                coerceValue(myUseOutputSeams, value);
                break;
            case 21:
                coerceValue(myOutputSeams, value);
                break;
            case 22:
                coerceValue(myUseOutputConstrIslands, value);
                break;
            case 23:
                coerceValue(myOutputConstrIslands, value);
                break;
            case 24:
                coerceValue(myBboxCenter, value);
                break;
            case 25:
                coerceValue(myBboxSize, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 26;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "group";
            case 1:
                return "uvattrib";
            case 2:
                return "method";
            case 3:
                return "keepexistingseams";
            case 4:
                return "keepexistinglayout";
            case 5:
                return "pinboundaries";
            case 6:
                return "seamgroup";
            case 7:
                return "rectifygroup";
            case 8:
                return "usepins";
                case 9:
                    return "pins";
            case 10:
                return "usealignments";
                case 11:
                    return "alignments";
            case 12:
                return "usestraightenings";
                case 13:
                    return "straightenings";
            case 14:
                return "manuallayout";
            case 15:
                return "layoutseamgroup";
            case 16:
                return "layoutrectifygroup";
                case 17:
                    return "lpins";
                case 18:
                    return "lalignments";
                case 19:
                    return "lstraightenings";
            case 20:
                return "useoutputseams";
            case 21:
                return "outputseams";
            case 22:
                return "useoutputconstrislands";
            case 23:
                return "outputconstrislands";
            case 24:
                return "bboxcenter";
            case 25:
                return "bboxsize";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_STRING;
                case 2:
                    return PARM_INTEGER;
                case 3:
                    return PARM_INTEGER;
                case 4:
                    return PARM_INTEGER;
                case 5:
                    return PARM_INTEGER;
                case 6:
                    return PARM_STRING;
                case 7:
                    return PARM_STRING;
                case 8:
                    return PARM_INTEGER;
                case 10:
                    return PARM_INTEGER;
                case 12:
                    return PARM_INTEGER;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_STRING;
                case 16:
                    return PARM_STRING;
                case 20:
                    return PARM_INTEGER;
                case 21:
                    return PARM_STRING;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_STRING;
                case 24:
                    return PARM_VECTOR2;
                case 25:
                    return PARM_VECTOR2;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myGroup);
        saveData(os, myUVAttrib);
        saveData(os, myMethod);
        saveData(os, myKeepExistingSeams);
        saveData(os, myKeepExistingLayout);
        saveData(os, myPinBoundaries);
        saveData(os, mySeams);
        saveData(os, myRectifyGroup);
        saveData(os, myUsePins);
        {
            int64   length = myPins.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myPins(i).usepin);
                saveData(os, myPins(i).primvert);
                saveData(os, myPins(i).pinuv);
                saveData(os, myPins(i).pinrefuv);

            }
        }
        saveData(os, myUseAlignments);
        {
            int64   length = myAlignments.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myAlignments(i).align_enabled);
                saveData(os, myAlignments(i).align_group);
                saveData(os, myAlignments(i).align_axis);

            }
        }
        saveData(os, myUseStraightenings);
        {
            int64   length = myStraightenings.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myStraightenings(i).straight_enabled);
                saveData(os, myStraightenings(i).straight_group);

            }
        }
        saveData(os, myManualLayout);
        saveData(os, myLayoutSeams);
        saveData(os, myLayoutRectifyGroup);
        {
            int64   length = myLpins.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myLpins(i).lprimvert);
                saveData(os, myLpins(i).lpinuv);
                saveData(os, myLpins(i).lpinrefuv);

            }
        }
        {
            int64   length = myLalignments.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myLalignments(i).lalign_group);
                saveData(os, myLalignments(i).lalign_axis);

            }
        }
        {
            int64   length = myLstraightenings.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myLstraightenings(i).lstraight_group);

            }
        }
        saveData(os, myUseOutputSeams);
        saveData(os, myOutputSeams);
        saveData(os, myUseOutputConstrIslands);
        saveData(os, myOutputConstrIslands);
        saveData(os, myBboxCenter);
        saveData(os, myBboxSize);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myGroup);
        loadData(is, myUVAttrib);
        loadData(is, myMethod);
        loadData(is, myKeepExistingSeams);
        loadData(is, myKeepExistingLayout);
        loadData(is, myPinBoundaries);
        loadData(is, mySeams);
        loadData(is, myRectifyGroup);
        loadData(is, myUsePins);
        {
            int64   length;
            is.read(&length, 1);
            myPins.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myPins(i).usepin);
                loadData(is, myPins(i).primvert);
                loadData(is, myPins(i).pinuv);
                loadData(is, myPins(i).pinrefuv);

            }
        }
        loadData(is, myUseAlignments);
        {
            int64   length;
            is.read(&length, 1);
            myAlignments.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myAlignments(i).align_enabled);
                loadData(is, myAlignments(i).align_group);
                loadData(is, myAlignments(i).align_axis);

            }
        }
        loadData(is, myUseStraightenings);
        {
            int64   length;
            is.read(&length, 1);
            myStraightenings.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myStraightenings(i).straight_enabled);
                loadData(is, myStraightenings(i).straight_group);

            }
        }
        loadData(is, myManualLayout);
        loadData(is, myLayoutSeams);
        loadData(is, myLayoutRectifyGroup);
        {
            int64   length;
            is.read(&length, 1);
            myLpins.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myLpins(i).lprimvert);
                loadData(is, myLpins(i).lpinuv);
                loadData(is, myLpins(i).lpinrefuv);

            }
        }
        {
            int64   length;
            is.read(&length, 1);
            myLalignments.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myLalignments(i).lalign_group);
                loadData(is, myLalignments(i).lalign_axis);

            }
        }
        {
            int64   length;
            is.read(&length, 1);
            myLstraightenings.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myLstraightenings(i).lstraight_group);

            }
        }
        loadData(is, myUseOutputSeams);
        loadData(is, myOutputSeams);
        loadData(is, myUseOutputConstrIslands);
        loadData(is, myOutputConstrIslands);
        loadData(is, myBboxCenter);
        loadData(is, myBboxSize);

        return true;
    }

    const UT_StringHolder & getGroup() const { return myGroup; }
    void setGroup(const UT_StringHolder & val) { myGroup = val; }
    UT_StringHolder opGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "group", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getUVAttrib() const { return myUVAttrib; }
    void setUVAttrib(const UT_StringHolder & val) { myUVAttrib = val; }
    UT_StringHolder opUVAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUVAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "uvattrib", cookparms.getCookTime(), 0);
        return result;
    }
    Method getMethod() const { return Method(myMethod); }
    void setMethod(Method val) { myMethod = int64(val); }
    Method opMethod(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMethod();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "method", cookparms.getCookTime(), 0);
        return Method(result);
    }
    bool getKeepExistingSeams() const { return myKeepExistingSeams; }
    void setKeepExistingSeams(bool val) { myKeepExistingSeams = val; }
    bool opKeepExistingSeams(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getKeepExistingSeams();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "keepexistingseams", cookparms.getCookTime(), 0);
        return result;
    }
    bool getKeepExistingLayout() const { return myKeepExistingLayout; }
    void setKeepExistingLayout(bool val) { myKeepExistingLayout = val; }
    bool opKeepExistingLayout(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getKeepExistingLayout();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "keepexistinglayout", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPinBoundaries() const { return myPinBoundaries; }
    void setPinBoundaries(bool val) { myPinBoundaries = val; }
    bool opPinBoundaries(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPinBoundaries();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "pinboundaries", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getSeams() const { return mySeams; }
    void setSeams(const UT_StringHolder & val) { mySeams = val; }
    UT_StringHolder opSeams(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSeams();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "seamgroup", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getRectifyGroup() const { return myRectifyGroup; }
    void setRectifyGroup(const UT_StringHolder & val) { myRectifyGroup = val; }
    UT_StringHolder opRectifyGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRectifyGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "rectifygroup", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUsePins() const { return myUsePins; }
    void setUsePins(bool val) { myUsePins = val; }
    bool opUsePins(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUsePins();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usepins", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Pins> &getPins() const { return myPins; }
    void setPins(const UT_Array<Pins> &val) { myPins = val; }
    exint opPins(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPins().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "pins", cookparms.getCookTime(), 0);
        return result;
    }
            bool opPins_usepin(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myPins(_idx).usepin);
            int _parmidx = _idx + 0;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "usepin#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_Vector2D opPins_primvert(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myPins(_idx).primvert);
            int _parmidx = _idx + 0;
            UT_Vector2D result;
            OP_Utils::evalOpParmInst(result, thissop, "primvert#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_Vector2D opPins_pinuv(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myPins(_idx).pinuv);
            int _parmidx = _idx + 0;
            UT_Vector2D result;
            OP_Utils::evalOpParmInst(result, thissop, "pinuv#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_Vector2D opPins_pinrefuv(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myPins(_idx).pinrefuv);
            int _parmidx = _idx + 0;
            UT_Vector2D result;
            OP_Utils::evalOpParmInst(result, thissop, "pinrefuv#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    bool getUseAlignments() const { return myUseAlignments; }
    void setUseAlignments(bool val) { myUseAlignments = val; }
    bool opUseAlignments(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAlignments();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usealignments", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Alignments> &getAlignments() const { return myAlignments; }
    void setAlignments(const UT_Array<Alignments> &val) { myAlignments = val; }
    exint opAlignments(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAlignments().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "alignments", cookparms.getCookTime(), 0);
        return result;
    }
            bool opAlignments_align_enabled(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myAlignments(_idx).align_enabled);
            int _parmidx = _idx + 0;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "align_enabled#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opAlignments_align_group(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myAlignments(_idx).align_group);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "align_group#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opAlignments_align_axis(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myAlignments(_idx).align_axis);
            int _parmidx = _idx + 0;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "align_axis#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    bool getUseStraightenings() const { return myUseStraightenings; }
    void setUseStraightenings(bool val) { myUseStraightenings = val; }
    bool opUseStraightenings(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseStraightenings();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usestraightenings", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Straightenings> &getStraightenings() const { return myStraightenings; }
    void setStraightenings(const UT_Array<Straightenings> &val) { myStraightenings = val; }
    exint opStraightenings(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStraightenings().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "straightenings", cookparms.getCookTime(), 0);
        return result;
    }
            bool opStraightenings_straight_enabled(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myStraightenings(_idx).straight_enabled);
            int _parmidx = _idx + 0;
            bool result;
            OP_Utils::evalOpParmInst(result, thissop, "straight_enabled#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opStraightenings_straight_group(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myStraightenings(_idx).straight_group);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "straight_group#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    bool getManualLayout() const { return myManualLayout; }
    void setManualLayout(bool val) { myManualLayout = val; }
    bool opManualLayout(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getManualLayout();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "manuallayout", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLayoutSeams() const { return myLayoutSeams; }
    void setLayoutSeams(const UT_StringHolder & val) { myLayoutSeams = val; }
    UT_StringHolder opLayoutSeams(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLayoutSeams();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "layoutseamgroup", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLayoutRectifyGroup() const { return myLayoutRectifyGroup; }
    void setLayoutRectifyGroup(const UT_StringHolder & val) { myLayoutRectifyGroup = val; }
    UT_StringHolder opLayoutRectifyGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLayoutRectifyGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "layoutrectifygroup", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Lpins> &getLpins() const { return myLpins; }
    void setLpins(const UT_Array<Lpins> &val) { myLpins = val; }
    exint opLpins(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLpins().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "lpins", cookparms.getCookTime(), 0);
        return result;
    }
            UT_Vector2D opLpins_lprimvert(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myLpins(_idx).lprimvert);
            int _parmidx = _idx + 0;
            UT_Vector2D result;
            OP_Utils::evalOpParmInst(result, thissop, "lprimvert#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_Vector2D opLpins_lpinuv(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myLpins(_idx).lpinuv);
            int _parmidx = _idx + 0;
            UT_Vector2D result;
            OP_Utils::evalOpParmInst(result, thissop, "lpinuv#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_Vector2D opLpins_lpinrefuv(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myLpins(_idx).lpinrefuv);
            int _parmidx = _idx + 0;
            UT_Vector2D result;
            OP_Utils::evalOpParmInst(result, thissop, "lpinrefuv#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    const UT_Array<Lalignments> &getLalignments() const { return myLalignments; }
    void setLalignments(const UT_Array<Lalignments> &val) { myLalignments = val; }
    exint opLalignments(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLalignments().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "lalignments", cookparms.getCookTime(), 0);
        return result;
    }
            UT_StringHolder opLalignments_lalign_group(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myLalignments(_idx).lalign_group);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "lalign_group#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opLalignments_lalign_axis(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myLalignments(_idx).lalign_axis);
            int _parmidx = _idx + 0;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "lalign_axis#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    const UT_Array<Lstraightenings> &getLstraightenings() const { return myLstraightenings; }
    void setLstraightenings(const UT_Array<Lstraightenings> &val) { myLstraightenings = val; }
    exint opLstraightenings(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLstraightenings().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "lstraightenings", cookparms.getCookTime(), 0);
        return result;
    }
            UT_StringHolder opLstraightenings_lstraight_group(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myLstraightenings(_idx).lstraight_group);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "lstraight_group#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    bool getUseOutputSeams() const { return myUseOutputSeams; }
    void setUseOutputSeams(bool val) { myUseOutputSeams = val; }
    bool opUseOutputSeams(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseOutputSeams();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useoutputseams", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getOutputSeams() const { return myOutputSeams; }
    void setOutputSeams(const UT_StringHolder & val) { myOutputSeams = val; }
    UT_StringHolder opOutputSeams(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputSeams();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "outputseams", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseOutputConstrIslands() const { return myUseOutputConstrIslands; }
    void setUseOutputConstrIslands(bool val) { myUseOutputConstrIslands = val; }
    bool opUseOutputConstrIslands(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseOutputConstrIslands();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useoutputconstrislands", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getOutputConstrIslands() const { return myOutputConstrIslands; }
    void setOutputConstrIslands(const UT_StringHolder & val) { myOutputConstrIslands = val; }
    UT_StringHolder opOutputConstrIslands(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputConstrIslands();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "outputconstrislands", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector2D getBboxCenter() const { return myBboxCenter; }
    void setBboxCenter(UT_Vector2D val) { myBboxCenter = val; }
    UT_Vector2D opBboxCenter(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBboxCenter();
        UT_Vector2D result;
        OP_Utils::evalOpParm(result, thissop, "bboxcenter", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector2D getBboxSize() const { return myBboxSize; }
    void setBboxSize(UT_Vector2D val) { myBboxSize = val; }
    UT_Vector2D opBboxSize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBboxSize();
        UT_Vector2D result;
        OP_Utils::evalOpParm(result, thissop, "bboxsize", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myGroup;
    UT_StringHolder myUVAttrib;
    int64 myMethod;
    bool myKeepExistingSeams;
    bool myKeepExistingLayout;
    bool myPinBoundaries;
    UT_StringHolder mySeams;
    UT_StringHolder myRectifyGroup;
    bool myUsePins;
    UT_Array<Pins> myPins;
    bool myUseAlignments;
    UT_Array<Alignments> myAlignments;
    bool myUseStraightenings;
    UT_Array<Straightenings> myStraightenings;
    bool myManualLayout;
    UT_StringHolder myLayoutSeams;
    UT_StringHolder myLayoutRectifyGroup;
    UT_Array<Lpins> myLpins;
    UT_Array<Lalignments> myLalignments;
    UT_Array<Lstraightenings> myLstraightenings;
    bool myUseOutputSeams;
    UT_StringHolder myOutputSeams;
    bool myUseOutputConstrIslands;
    UT_StringHolder myOutputConstrIslands;
    UT_Vector2D myBboxCenter;
    UT_Vector2D myBboxSize;

};
