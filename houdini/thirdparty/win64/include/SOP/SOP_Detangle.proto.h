/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;

class SOP_API SOP_DetangleParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_DetangleParms()
    {
        myPrevpos = ""_sh;
        myDisableSelfAttr = "disableself"_sh;
        myDisableExternalAttr = "disableexternal"_sh;
        myWeldAttr = "weld"_sh;
        myThickness = 0.05;
        myDoSelf = false;
        myDoTet = false;
        myUpdateDisable = false;
        myResetDetangledPoints = false;
        myDoMark = false;
        myMarkAttr = "changed"_sh;
        myDoresolve = false;
        myMaxWeight = 1.0;
        myCapDisplace = false;
        myMaxDisplace = 0.5;
        myResolveAll = false;
        myResolveAllMax = 10;
        myResolveFreeEdges = false;
        myLayerAttr = "layer"_sh;
        myLayerShock = 4.0;
        myExternalFriction = 1.0;
        mySelfFriction = 1.0;
        myStaticThreshold = 0.5;
        myKineticScale = 0.1;
        myConstantCollisionTopology = true;
        mySharedCache = ""_sh;
        myResetKey = -1;
        myUpdateOverlap = false;

    }

    explicit SOP_DetangleParms(const SOP_DetangleParms &) = default;

    virtual ~SOP_DetangleParms() {}

    bool operator==(const SOP_DetangleParms &src) const
    {
        if (myPrevpos != src.myPrevpos) return false;
        if (myDisableSelfAttr != src.myDisableSelfAttr) return false;
        if (myDisableExternalAttr != src.myDisableExternalAttr) return false;
        if (myWeldAttr != src.myWeldAttr) return false;
        if (myThickness != src.myThickness) return false;
        if (myDoSelf != src.myDoSelf) return false;
        if (myDoTet != src.myDoTet) return false;
        if (myUpdateDisable != src.myUpdateDisable) return false;
        if (myResetDetangledPoints != src.myResetDetangledPoints) return false;
        if (myDoMark != src.myDoMark) return false;
        if (myMarkAttr != src.myMarkAttr) return false;
        if (myDoresolve != src.myDoresolve) return false;
        if (myMaxWeight != src.myMaxWeight) return false;
        if (myCapDisplace != src.myCapDisplace) return false;
        if (myMaxDisplace != src.myMaxDisplace) return false;
        if (myResolveAll != src.myResolveAll) return false;
        if (myResolveAllMax != src.myResolveAllMax) return false;
        if (myResolveFreeEdges != src.myResolveFreeEdges) return false;
        if (myLayerAttr != src.myLayerAttr) return false;
        if (myLayerShock != src.myLayerShock) return false;
        if (myExternalFriction != src.myExternalFriction) return false;
        if (mySelfFriction != src.mySelfFriction) return false;
        if (myStaticThreshold != src.myStaticThreshold) return false;
        if (myKineticScale != src.myKineticScale) return false;
        if (myConstantCollisionTopology != src.myConstantCollisionTopology) return false;
        if (mySharedCache != src.mySharedCache) return false;
        if (myResetKey != src.myResetKey) return false;
        if (myUpdateOverlap != src.myUpdateOverlap) return false;

        return true;
    }
    bool operator!=(const SOP_DetangleParms &src) const
    {
        return !operator==(src);
    }



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myPrevpos, node, "prevpos", time, 0);
        else myPrevpos = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myDisableSelfAttr, node, "disableselfattr", time, 0);
        else myDisableSelfAttr = "disableself"_sh;
        if (true)
            OP_Utils::evalOpParm(myDisableExternalAttr, node, "disableexternalattr", time, 0);
        else myDisableExternalAttr = "disableexternal"_sh;
        if (true)
            OP_Utils::evalOpParm(myWeldAttr, node, "weldattr", time, 0);
        else myWeldAttr = "weld"_sh;
        if (true)
            OP_Utils::evalOpParm(myThickness, node, "thickness", time, 0);
        else myThickness = 0.05;
        if (true)
            OP_Utils::evalOpParm(myDoSelf, node, "doself", time, 0);
        else myDoSelf = false;
        if (true)
            OP_Utils::evalOpParm(myDoTet, node, "dotet", time, 0);
        else myDoTet = false;
        if (true)
            OP_Utils::evalOpParm(myUpdateDisable, node, "updatedisable", time, 0);
        else myUpdateDisable = false;
        if (true && ( (!(((getUpdateDisable()==0)))) ) )
            OP_Utils::evalOpParm(myResetDetangledPoints, node, "resetdetangled", time, 0);
        else myResetDetangledPoints = false;
        if (true)
            OP_Utils::evalOpParm(myDoMark, node, "domark", time, 0);
        else myDoMark = false;
        if (true && ( (!(((getDoMark()==0)))) ) )
            OP_Utils::evalOpParm(myMarkAttr, node, "markattr", time, 0);
        else myMarkAttr = "changed"_sh;
        if (true && ( (!(((getUpdateDisable()==1)))) ) )
            OP_Utils::evalOpParm(myDoresolve, node, "doresolve", time, 0);
        else myDoresolve = false;
        if (true)
            OP_Utils::evalOpParm(myMaxWeight, node, "maxweight", time, 0);
        else myMaxWeight = 1.0;
        if (true)
            OP_Utils::evalOpParm(myCapDisplace, node, "capdisplace", time, 0);
        else myCapDisplace = false;
        if (true && ( (!(((getCapDisplace()==0)))) ) )
            OP_Utils::evalOpParm(myMaxDisplace, node, "maxdisplace", time, 0);
        else myMaxDisplace = 0.5;
        if (true && ( (!(((getUpdateDisable()==1))||((getDoresolve()==0)))) ) )
            OP_Utils::evalOpParm(myResolveAll, node, "resolveall", time, 0);
        else myResolveAll = false;
        if (true && ( (!(((getUpdateDisable()==1))||((getDoresolve()==0))||((getResolveAll()==0)))) ) )
            OP_Utils::evalOpParm(myResolveAllMax, node, "resolveallmax", time, 0);
        else myResolveAllMax = 10;
        if (true && ( (!(((getUpdateDisable()==1))||((getDoresolve()==0))||((getResolveAll()==0)))) ) )
            OP_Utils::evalOpParm(myResolveFreeEdges, node, "resolvealledges", time, 0);
        else myResolveFreeEdges = false;
        if (true && ( (!(((getUpdateDisable()==1))||((getDoresolve()==0)))) ) )
            OP_Utils::evalOpParm(myLayerAttr, node, "layerattr", time, 0);
        else myLayerAttr = "layer"_sh;
        if (true && ( (!(((getUpdateDisable()==1))||((getDoresolve()==0)))) ) )
            OP_Utils::evalOpParm(myLayerShock, node, "layershock", time, 0);
        else myLayerShock = 4.0;
        if (true && ( (!(((getDoresolve()==0)))) ) )
            OP_Utils::evalOpParm(myExternalFriction, node, "externalfriction", time, 0);
        else myExternalFriction = 1.0;
        if (true && ( (!(((getDoresolve()==0)))) ) )
            OP_Utils::evalOpParm(mySelfFriction, node, "selffriction", time, 0);
        else mySelfFriction = 1.0;
        if (true && ( (!(((getDoresolve()==0)))) ) )
            OP_Utils::evalOpParm(myStaticThreshold, node, "static_threshold", time, 0);
        else myStaticThreshold = 0.5;
        if (true && ( (!(((getDoresolve()==0)))) ) )
            OP_Utils::evalOpParm(myKineticScale, node, "kinetic_scale", time, 0);
        else myKineticScale = 0.1;
        if (true)
            OP_Utils::evalOpParm(myConstantCollisionTopology, node, "constantcollisiontopology", time, 0);
        else myConstantCollisionTopology = true;
        if (true)
            OP_Utils::evalOpParm(mySharedCache, node, "sharedcache", time, 0);
        else mySharedCache = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myResetKey, node, "resetkey", time, 0);
        else myResetKey = -1;
        if (true && ( (!(((getUpdateDisable()==0)&&(getDoresolve()==1)))) ) )
            OP_Utils::evalOpParm(myUpdateOverlap, node, "updateoverlap", time, 0);
        else myUpdateOverlap = false;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_DetangleParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myPrevpos);
                break;
            case 1:
                coerceValue(value, myDisableSelfAttr);
                break;
            case 2:
                coerceValue(value, myDisableExternalAttr);
                break;
            case 3:
                coerceValue(value, myWeldAttr);
                break;
            case 4:
                coerceValue(value, myThickness);
                break;
            case 5:
                coerceValue(value, myDoSelf);
                break;
            case 6:
                coerceValue(value, myDoTet);
                break;
            case 7:
                coerceValue(value, myUpdateDisable);
                break;
            case 8:
                coerceValue(value, myResetDetangledPoints);
                break;
            case 9:
                coerceValue(value, myDoMark);
                break;
            case 10:
                coerceValue(value, myMarkAttr);
                break;
            case 11:
                coerceValue(value, myDoresolve);
                break;
            case 12:
                coerceValue(value, myMaxWeight);
                break;
            case 13:
                coerceValue(value, myCapDisplace);
                break;
            case 14:
                coerceValue(value, myMaxDisplace);
                break;
            case 15:
                coerceValue(value, myResolveAll);
                break;
            case 16:
                coerceValue(value, myResolveAllMax);
                break;
            case 17:
                coerceValue(value, myResolveFreeEdges);
                break;
            case 18:
                coerceValue(value, myLayerAttr);
                break;
            case 19:
                coerceValue(value, myLayerShock);
                break;
            case 20:
                coerceValue(value, myExternalFriction);
                break;
            case 21:
                coerceValue(value, mySelfFriction);
                break;
            case 22:
                coerceValue(value, myStaticThreshold);
                break;
            case 23:
                coerceValue(value, myKineticScale);
                break;
            case 24:
                coerceValue(value, myConstantCollisionTopology);
                break;
            case 25:
                coerceValue(value, mySharedCache);
                break;
            case 26:
                coerceValue(value, myResetKey);
                break;
            case 27:
                coerceValue(value, myUpdateOverlap);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myPrevpos, value);
                break;
            case 1:
                coerceValue(myDisableSelfAttr, value);
                break;
            case 2:
                coerceValue(myDisableExternalAttr, value);
                break;
            case 3:
                coerceValue(myWeldAttr, value);
                break;
            case 4:
                coerceValue(myThickness, value);
                break;
            case 5:
                coerceValue(myDoSelf, value);
                break;
            case 6:
                coerceValue(myDoTet, value);
                break;
            case 7:
                coerceValue(myUpdateDisable, value);
                break;
            case 8:
                coerceValue(myResetDetangledPoints, value);
                break;
            case 9:
                coerceValue(myDoMark, value);
                break;
            case 10:
                coerceValue(myMarkAttr, value);
                break;
            case 11:
                coerceValue(myDoresolve, value);
                break;
            case 12:
                coerceValue(myMaxWeight, value);
                break;
            case 13:
                coerceValue(myCapDisplace, value);
                break;
            case 14:
                coerceValue(myMaxDisplace, value);
                break;
            case 15:
                coerceValue(myResolveAll, value);
                break;
            case 16:
                coerceValue(myResolveAllMax, value);
                break;
            case 17:
                coerceValue(myResolveFreeEdges, value);
                break;
            case 18:
                coerceValue(myLayerAttr, value);
                break;
            case 19:
                coerceValue(myLayerShock, value);
                break;
            case 20:
                coerceValue(myExternalFriction, value);
                break;
            case 21:
                coerceValue(mySelfFriction, value);
                break;
            case 22:
                coerceValue(myStaticThreshold, value);
                break;
            case 23:
                coerceValue(myKineticScale, value);
                break;
            case 24:
                coerceValue(myConstantCollisionTopology, value);
                break;
            case 25:
                coerceValue(mySharedCache, value);
                break;
            case 26:
                coerceValue(myResetKey, value);
                break;
            case 27:
                coerceValue(myUpdateOverlap, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 28;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "prevpos";
            case 1:
                return "disableselfattr";
            case 2:
                return "disableexternalattr";
            case 3:
                return "weldattr";
            case 4:
                return "thickness";
            case 5:
                return "doself";
            case 6:
                return "dotet";
            case 7:
                return "updatedisable";
            case 8:
                return "resetdetangled";
            case 9:
                return "domark";
            case 10:
                return "markattr";
            case 11:
                return "doresolve";
            case 12:
                return "maxweight";
            case 13:
                return "capdisplace";
            case 14:
                return "maxdisplace";
            case 15:
                return "resolveall";
            case 16:
                return "resolveallmax";
            case 17:
                return "resolvealledges";
            case 18:
                return "layerattr";
            case 19:
                return "layershock";
            case 20:
                return "externalfriction";
            case 21:
                return "selffriction";
            case 22:
                return "static_threshold";
            case 23:
                return "kinetic_scale";
            case 24:
                return "constantcollisiontopology";
            case 25:
                return "sharedcache";
            case 26:
                return "resetkey";
            case 27:
                return "updateoverlap";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_STRING;
                case 2:
                    return PARM_STRING;
                case 3:
                    return PARM_STRING;
                case 4:
                    return PARM_FLOAT;
                case 5:
                    return PARM_INTEGER;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_INTEGER;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_STRING;
                case 11:
                    return PARM_INTEGER;
                case 12:
                    return PARM_FLOAT;
                case 13:
                    return PARM_INTEGER;
                case 14:
                    return PARM_FLOAT;
                case 15:
                    return PARM_INTEGER;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_INTEGER;
                case 18:
                    return PARM_STRING;
                case 19:
                    return PARM_FLOAT;
                case 20:
                    return PARM_FLOAT;
                case 21:
                    return PARM_FLOAT;
                case 22:
                    return PARM_FLOAT;
                case 23:
                    return PARM_FLOAT;
                case 24:
                    return PARM_INTEGER;
                case 25:
                    return PARM_STRING;
                case 26:
                    return PARM_FLOAT;
                case 27:
                    return PARM_INTEGER;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myPrevpos);
        saveData(os, myDisableSelfAttr);
        saveData(os, myDisableExternalAttr);
        saveData(os, myWeldAttr);
        saveData(os, myThickness);
        saveData(os, myDoSelf);
        saveData(os, myDoTet);
        saveData(os, myUpdateDisable);
        saveData(os, myResetDetangledPoints);
        saveData(os, myDoMark);
        saveData(os, myMarkAttr);
        saveData(os, myDoresolve);
        saveData(os, myMaxWeight);
        saveData(os, myCapDisplace);
        saveData(os, myMaxDisplace);
        saveData(os, myResolveAll);
        saveData(os, myResolveAllMax);
        saveData(os, myResolveFreeEdges);
        saveData(os, myLayerAttr);
        saveData(os, myLayerShock);
        saveData(os, myExternalFriction);
        saveData(os, mySelfFriction);
        saveData(os, myStaticThreshold);
        saveData(os, myKineticScale);
        saveData(os, myConstantCollisionTopology);
        saveData(os, mySharedCache);
        saveData(os, myResetKey);
        saveData(os, myUpdateOverlap);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myPrevpos);
        loadData(is, myDisableSelfAttr);
        loadData(is, myDisableExternalAttr);
        loadData(is, myWeldAttr);
        loadData(is, myThickness);
        loadData(is, myDoSelf);
        loadData(is, myDoTet);
        loadData(is, myUpdateDisable);
        loadData(is, myResetDetangledPoints);
        loadData(is, myDoMark);
        loadData(is, myMarkAttr);
        loadData(is, myDoresolve);
        loadData(is, myMaxWeight);
        loadData(is, myCapDisplace);
        loadData(is, myMaxDisplace);
        loadData(is, myResolveAll);
        loadData(is, myResolveAllMax);
        loadData(is, myResolveFreeEdges);
        loadData(is, myLayerAttr);
        loadData(is, myLayerShock);
        loadData(is, myExternalFriction);
        loadData(is, mySelfFriction);
        loadData(is, myStaticThreshold);
        loadData(is, myKineticScale);
        loadData(is, myConstantCollisionTopology);
        loadData(is, mySharedCache);
        loadData(is, myResetKey);
        loadData(is, myUpdateOverlap);

        return true;
    }

    const UT_StringHolder & getPrevpos() const { return myPrevpos; }
    void setPrevpos(const UT_StringHolder & val) { myPrevpos = val; }
    UT_StringHolder opPrevpos(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrevpos();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "prevpos", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getDisableSelfAttr() const { return myDisableSelfAttr; }
    void setDisableSelfAttr(const UT_StringHolder & val) { myDisableSelfAttr = val; }
    UT_StringHolder opDisableSelfAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDisableSelfAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "disableselfattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getDisableExternalAttr() const { return myDisableExternalAttr; }
    void setDisableExternalAttr(const UT_StringHolder & val) { myDisableExternalAttr = val; }
    UT_StringHolder opDisableExternalAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDisableExternalAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "disableexternalattr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getWeldAttr() const { return myWeldAttr; }
    void setWeldAttr(const UT_StringHolder & val) { myWeldAttr = val; }
    UT_StringHolder opWeldAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getWeldAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "weldattr", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getThickness() const { return myThickness; }
    void setThickness(fpreal64 val) { myThickness = val; }
    fpreal64 opThickness(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getThickness();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "thickness", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDoSelf() const { return myDoSelf; }
    void setDoSelf(bool val) { myDoSelf = val; }
    bool opDoSelf(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoSelf();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "doself", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDoTet() const { return myDoTet; }
    void setDoTet(bool val) { myDoTet = val; }
    bool opDoTet(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoTet();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dotet", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUpdateDisable() const { return myUpdateDisable; }
    void setUpdateDisable(bool val) { myUpdateDisable = val; }
    bool opUpdateDisable(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUpdateDisable();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "updatedisable", cookparms.getCookTime(), 0);
        return result;
    }
    bool getResetDetangledPoints() const { return myResetDetangledPoints; }
    void setResetDetangledPoints(bool val) { myResetDetangledPoints = val; }
    bool opResetDetangledPoints(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getResetDetangledPoints();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "resetdetangled", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDoMark() const { return myDoMark; }
    void setDoMark(bool val) { myDoMark = val; }
    bool opDoMark(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoMark();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "domark", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getMarkAttr() const { return myMarkAttr; }
    void setMarkAttr(const UT_StringHolder & val) { myMarkAttr = val; }
    UT_StringHolder opMarkAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMarkAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "markattr", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDoresolve() const { return myDoresolve; }
    void setDoresolve(bool val) { myDoresolve = val; }
    bool opDoresolve(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoresolve();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "doresolve", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getMaxWeight() const { return myMaxWeight; }
    void setMaxWeight(fpreal64 val) { myMaxWeight = val; }
    fpreal64 opMaxWeight(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxWeight();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "maxweight", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCapDisplace() const { return myCapDisplace; }
    void setCapDisplace(bool val) { myCapDisplace = val; }
    bool opCapDisplace(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCapDisplace();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "capdisplace", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getMaxDisplace() const { return myMaxDisplace; }
    void setMaxDisplace(fpreal64 val) { myMaxDisplace = val; }
    fpreal64 opMaxDisplace(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxDisplace();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "maxdisplace", cookparms.getCookTime(), 0);
        return result;
    }
    bool getResolveAll() const { return myResolveAll; }
    void setResolveAll(bool val) { myResolveAll = val; }
    bool opResolveAll(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getResolveAll();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "resolveall", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getResolveAllMax() const { return myResolveAllMax; }
    void setResolveAllMax(int64 val) { myResolveAllMax = val; }
    int64 opResolveAllMax(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getResolveAllMax();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "resolveallmax", cookparms.getCookTime(), 0);
        return result;
    }
    bool getResolveFreeEdges() const { return myResolveFreeEdges; }
    void setResolveFreeEdges(bool val) { myResolveFreeEdges = val; }
    bool opResolveFreeEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getResolveFreeEdges();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "resolvealledges", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLayerAttr() const { return myLayerAttr; }
    void setLayerAttr(const UT_StringHolder & val) { myLayerAttr = val; }
    UT_StringHolder opLayerAttr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLayerAttr();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "layerattr", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getLayerShock() const { return myLayerShock; }
    void setLayerShock(fpreal64 val) { myLayerShock = val; }
    fpreal64 opLayerShock(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLayerShock();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "layershock", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getExternalFriction() const { return myExternalFriction; }
    void setExternalFriction(fpreal64 val) { myExternalFriction = val; }
    fpreal64 opExternalFriction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getExternalFriction();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "externalfriction", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getSelfFriction() const { return mySelfFriction; }
    void setSelfFriction(fpreal64 val) { mySelfFriction = val; }
    fpreal64 opSelfFriction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSelfFriction();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "selffriction", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getStaticThreshold() const { return myStaticThreshold; }
    void setStaticThreshold(fpreal64 val) { myStaticThreshold = val; }
    fpreal64 opStaticThreshold(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStaticThreshold();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "static_threshold", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getKineticScale() const { return myKineticScale; }
    void setKineticScale(fpreal64 val) { myKineticScale = val; }
    fpreal64 opKineticScale(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getKineticScale();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "kinetic_scale", cookparms.getCookTime(), 0);
        return result;
    }
    bool getConstantCollisionTopology() const { return myConstantCollisionTopology; }
    void setConstantCollisionTopology(bool val) { myConstantCollisionTopology = val; }
    bool opConstantCollisionTopology(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getConstantCollisionTopology();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "constantcollisiontopology", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getSharedCache() const { return mySharedCache; }
    void setSharedCache(const UT_StringHolder & val) { mySharedCache = val; }
    UT_StringHolder opSharedCache(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSharedCache();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "sharedcache", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getResetKey() const { return myResetKey; }
    void setResetKey(fpreal64 val) { myResetKey = val; }
    fpreal64 opResetKey(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getResetKey();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "resetkey", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUpdateOverlap() const { return myUpdateOverlap; }
    void setUpdateOverlap(bool val) { myUpdateOverlap = val; }
    bool opUpdateOverlap(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUpdateOverlap();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "updateoverlap", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myPrevpos;
    UT_StringHolder myDisableSelfAttr;
    UT_StringHolder myDisableExternalAttr;
    UT_StringHolder myWeldAttr;
    fpreal64 myThickness;
    bool myDoSelf;
    bool myDoTet;
    bool myUpdateDisable;
    bool myResetDetangledPoints;
    bool myDoMark;
    UT_StringHolder myMarkAttr;
    bool myDoresolve;
    fpreal64 myMaxWeight;
    bool myCapDisplace;
    fpreal64 myMaxDisplace;
    bool myResolveAll;
    int64 myResolveAllMax;
    bool myResolveFreeEdges;
    UT_StringHolder myLayerAttr;
    fpreal64 myLayerShock;
    fpreal64 myExternalFriction;
    fpreal64 mySelfFriction;
    fpreal64 myStaticThreshold;
    fpreal64 myKineticScale;
    bool myConstantCollisionTopology;
    UT_StringHolder mySharedCache;
    fpreal64 myResetKey;
    bool myUpdateOverlap;

};
