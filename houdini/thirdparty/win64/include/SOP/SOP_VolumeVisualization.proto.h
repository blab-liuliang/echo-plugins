/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_VolumeVisualizationEnums
{
    enum class VisMode
    {
        NONE = 0,
        SMOKE,
        HEIGHTFIELD
    };
    enum class Densityrampmode
    {
        NONE = 0,
        CLAMP,
        PERIODIC
    };
    enum class Densitypreset
    {
        NONE = 0,
        INCREASING,
        DESCREASING,
        HILL,
        VALLEY,
        STEP,
        SQUARE
    };
    enum class Cdrampmode
    {
        NONE = 0,
        CLAMP,
        PERIODIC
    };
    enum class Cdpreset
    {
        NONE = 0,
        _FALSE,
        PINK,
        MONO,
        BLACKBODY,
        BIPARTITE
    };
    enum class Emitrampmode
    {
        NONE = 0,
        CLAMP,
        PERIODIC
    };
    enum class Emitpreset
    {
        NONE = 0,
        INCREASING,
        DESCREASING,
        HILL,
        VALLEY,
        STEP,
        SQUARE
    };
    enum class Emitcdrampmode
    {
        NONE = 0,
        CLAMP,
        PERIODIC
    };
    enum class Emitcdpreset
    {
        NONE = 0,
        _FALSE,
        PINK,
        MONO,
        BLACKBODY,
        BIPARTITE
    };
}


class SOP_API SOP_VolumeVisualizationParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_VolumeVisualizationParms()
    {
        myVisMode = 1;
        myRangemin = 0;
        myRangemax = 1;
        myDensityscale = 1;
        myShadowscale = 1;
        mySetmaxres = false;
        myMaxres = 128;
        myDensityfield = ""_sh;
        myDensityrampmode = 1;
        myDensitypreset = 0;
        myDensityramp = UT_SharedPtr<UT_Ramp>(0);
        myCdfield = ""_sh;
        myCdrangeoverride = false;
        myCdrange = UT_Vector2D(0,1);
        myCdrampmode = 1;
        myCdpreset = 0;
        myCdramp = UT_SharedPtr<UT_Ramp>(0);
        myEmitscale = 0;
        myEmitfield = ""_sh;
        myEmitrangeoverride = false;
        myEmitrange = UT_Vector2D(0,1);
        myEmitrampmode = 1;
        myEmitpreset = 0;
        myEmitramp = UT_SharedPtr<UT_Ramp>(0);
        myEmitcdfield = ""_sh;
        myEmitcdrangeoverride = false;
        myEmitcdrange = UT_Vector2D(0,1);
        myEmitcdrampmode = 1;
        myEmitcdpreset = 0;
        myEmitcdramp = UT_SharedPtr<UT_Ramp>(0);

    }

    explicit SOP_VolumeVisualizationParms(const SOP_VolumeVisualizationParms &) = default;

    virtual ~SOP_VolumeVisualizationParms() {}

    bool operator==(const SOP_VolumeVisualizationParms &src) const
    {
        if (myVisMode != src.myVisMode) return false;
        if (myRangemin != src.myRangemin) return false;
        if (myRangemax != src.myRangemax) return false;
        if (myDensityscale != src.myDensityscale) return false;
        if (myShadowscale != src.myShadowscale) return false;
        if (mySetmaxres != src.mySetmaxres) return false;
        if (myMaxres != src.myMaxres) return false;
        if (myDensityfield != src.myDensityfield) return false;
        if (myDensityrampmode != src.myDensityrampmode) return false;
        if (myDensitypreset != src.myDensitypreset) return false;
        if (myDensityramp != src.myDensityramp) return false;
        if (myCdfield != src.myCdfield) return false;
        if (myCdrangeoverride != src.myCdrangeoverride) return false;
        if (myCdrange != src.myCdrange) return false;
        if (myCdrampmode != src.myCdrampmode) return false;
        if (myCdpreset != src.myCdpreset) return false;
        if (myCdramp != src.myCdramp) return false;
        if (myEmitscale != src.myEmitscale) return false;
        if (myEmitfield != src.myEmitfield) return false;
        if (myEmitrangeoverride != src.myEmitrangeoverride) return false;
        if (myEmitrange != src.myEmitrange) return false;
        if (myEmitrampmode != src.myEmitrampmode) return false;
        if (myEmitpreset != src.myEmitpreset) return false;
        if (myEmitramp != src.myEmitramp) return false;
        if (myEmitcdfield != src.myEmitcdfield) return false;
        if (myEmitcdrangeoverride != src.myEmitcdrangeoverride) return false;
        if (myEmitcdrange != src.myEmitcdrange) return false;
        if (myEmitcdrampmode != src.myEmitcdrampmode) return false;
        if (myEmitcdpreset != src.myEmitcdpreset) return false;
        if (myEmitcdramp != src.myEmitcdramp) return false;

        return true;
    }
    bool operator!=(const SOP_VolumeVisualizationParms &src) const
    {
        return !operator==(src);
    }
    using VisMode = SOP_VolumeVisualizationEnums::VisMode;
    using Densityrampmode = SOP_VolumeVisualizationEnums::Densityrampmode;
    using Densitypreset = SOP_VolumeVisualizationEnums::Densitypreset;
    using Cdrampmode = SOP_VolumeVisualizationEnums::Cdrampmode;
    using Cdpreset = SOP_VolumeVisualizationEnums::Cdpreset;
    using Emitrampmode = SOP_VolumeVisualizationEnums::Emitrampmode;
    using Emitpreset = SOP_VolumeVisualizationEnums::Emitpreset;
    using Emitcdrampmode = SOP_VolumeVisualizationEnums::Emitcdrampmode;
    using Emitcdpreset = SOP_VolumeVisualizationEnums::Emitcdpreset;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myVisMode, node, "vismode", time, 0);
        else myVisMode = 1;
        if (true)
            OP_Utils::evalOpParm(myRangemin, node, "rangemin", time, 0);
        else myRangemin = 0;
        if (true)
            OP_Utils::evalOpParm(myRangemax, node, "rangemax", time, 0);
        else myRangemax = 1;
        if (true)
            OP_Utils::evalOpParm(myDensityscale, node, "densityscale", time, 0);
        else myDensityscale = 1;
        if (true)
            OP_Utils::evalOpParm(myShadowscale, node, "shadowscale", time, 0);
        else myShadowscale = 1;
        if (true)
            OP_Utils::evalOpParm(mySetmaxres, node, "setmaxres", time, 0);
        else mySetmaxres = false;
        if (true && ( (!(((getSetmaxres()==0)))) ) )
            OP_Utils::evalOpParm(myMaxres, node, "maxres", time, 0);
        else myMaxres = 128;
        if (true)
            OP_Utils::evalOpParm(myDensityfield, node, "densityfield", time, 0);
        else myDensityfield = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myDensityrampmode, node, "densityrampmode", time, 0);
        else myDensityrampmode = 1;
        if (true)
            OP_Utils::evalOpParm(myDensitypreset, node, "densitypreset", time, 0);
        else myDensitypreset = 0;
        if (true && ( (!(((int64(getDensityrampmode())==0)))) ) )
            OP_Utils::evalOpParm(myDensityramp, node, "densityramp", time, 0);
        else myDensityramp = UT_SharedPtr<UT_Ramp>(0);
        if (true)
            OP_Utils::evalOpParm(myCdfield, node, "cdfield", time, 0);
        else myCdfield = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myCdrangeoverride, node, "cdrangeoverride", time, 0);
        else myCdrangeoverride = false;
        if (true && ( (!(((getCdrangeoverride()==0)))) ) )
            OP_Utils::evalOpParm(myCdrange, node, "cdrange", time, 0);
        else myCdrange = UT_Vector2D(0,1);
        if (true)
            OP_Utils::evalOpParm(myCdrampmode, node, "cdrampmode", time, 0);
        else myCdrampmode = 1;
        if (true)
            OP_Utils::evalOpParm(myCdpreset, node, "cdpreset", time, 0);
        else myCdpreset = 0;
        if (true && ( (!(((int64(getCdrampmode())==0)))) ) )
            OP_Utils::evalOpParm(myCdramp, node, "cdramp", time, 0);
        else myCdramp = UT_SharedPtr<UT_Ramp>(0);
        if (true)
            OP_Utils::evalOpParm(myEmitscale, node, "emitscale", time, 0);
        else myEmitscale = 0;
        if (true)
            OP_Utils::evalOpParm(myEmitfield, node, "emitfield", time, 0);
        else myEmitfield = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myEmitrangeoverride, node, "emitrangeoverride", time, 0);
        else myEmitrangeoverride = false;
        if (true && ( (!(((getEmitrangeoverride()==0)))) ) )
            OP_Utils::evalOpParm(myEmitrange, node, "emitrange", time, 0);
        else myEmitrange = UT_Vector2D(0,1);
        if (true)
            OP_Utils::evalOpParm(myEmitrampmode, node, "emitrampmode", time, 0);
        else myEmitrampmode = 1;
        if (true)
            OP_Utils::evalOpParm(myEmitpreset, node, "emitpreset", time, 0);
        else myEmitpreset = 0;
        if (true && ( (!(((int64(getEmitrampmode())==0)))) ) )
            OP_Utils::evalOpParm(myEmitramp, node, "emitramp", time, 0);
        else myEmitramp = UT_SharedPtr<UT_Ramp>(0);
        if (true)
            OP_Utils::evalOpParm(myEmitcdfield, node, "emitcdfield", time, 0);
        else myEmitcdfield = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myEmitcdrangeoverride, node, "emitcdrangeoverride", time, 0);
        else myEmitcdrangeoverride = false;
        if (true && ( (!(((getEmitcdrangeoverride()==0)))) ) )
            OP_Utils::evalOpParm(myEmitcdrange, node, "emitcdrange", time, 0);
        else myEmitcdrange = UT_Vector2D(0,1);
        if (true)
            OP_Utils::evalOpParm(myEmitcdrampmode, node, "emitcdrampmode", time, 0);
        else myEmitcdrampmode = 1;
        if (true)
            OP_Utils::evalOpParm(myEmitcdpreset, node, "emitcdpreset", time, 0);
        else myEmitcdpreset = 0;
        if (true && ( (!(((int64(getEmitcdrampmode())==0)))) ) )
            OP_Utils::evalOpParm(myEmitcdramp, node, "emitcdramp", time, 0);
        else myEmitcdramp = UT_SharedPtr<UT_Ramp>(0);

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_VolumeVisualizationParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myVisMode);
                break;
            case 1:
                coerceValue(value, myRangemin);
                break;
            case 2:
                coerceValue(value, myRangemax);
                break;
            case 3:
                coerceValue(value, myDensityscale);
                break;
            case 4:
                coerceValue(value, myShadowscale);
                break;
            case 5:
                coerceValue(value, mySetmaxres);
                break;
            case 6:
                coerceValue(value, myMaxres);
                break;
            case 7:
                coerceValue(value, myDensityfield);
                break;
            case 8:
                coerceValue(value, myDensityrampmode);
                break;
            case 9:
                coerceValue(value, myDensitypreset);
                break;
            case 10:
                coerceValue(value, myDensityramp);
                break;
            case 11:
                coerceValue(value, myCdfield);
                break;
            case 12:
                coerceValue(value, myCdrangeoverride);
                break;
            case 13:
                coerceValue(value, myCdrange);
                break;
            case 14:
                coerceValue(value, myCdrampmode);
                break;
            case 15:
                coerceValue(value, myCdpreset);
                break;
            case 16:
                coerceValue(value, myCdramp);
                break;
            case 17:
                coerceValue(value, myEmitscale);
                break;
            case 18:
                coerceValue(value, myEmitfield);
                break;
            case 19:
                coerceValue(value, myEmitrangeoverride);
                break;
            case 20:
                coerceValue(value, myEmitrange);
                break;
            case 21:
                coerceValue(value, myEmitrampmode);
                break;
            case 22:
                coerceValue(value, myEmitpreset);
                break;
            case 23:
                coerceValue(value, myEmitramp);
                break;
            case 24:
                coerceValue(value, myEmitcdfield);
                break;
            case 25:
                coerceValue(value, myEmitcdrangeoverride);
                break;
            case 26:
                coerceValue(value, myEmitcdrange);
                break;
            case 27:
                coerceValue(value, myEmitcdrampmode);
                break;
            case 28:
                coerceValue(value, myEmitcdpreset);
                break;
            case 29:
                coerceValue(value, myEmitcdramp);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myVisMode, value);
                break;
            case 1:
                coerceValue(myRangemin, value);
                break;
            case 2:
                coerceValue(myRangemax, value);
                break;
            case 3:
                coerceValue(myDensityscale, value);
                break;
            case 4:
                coerceValue(myShadowscale, value);
                break;
            case 5:
                coerceValue(mySetmaxres, value);
                break;
            case 6:
                coerceValue(myMaxres, value);
                break;
            case 7:
                coerceValue(myDensityfield, value);
                break;
            case 8:
                coerceValue(myDensityrampmode, value);
                break;
            case 9:
                coerceValue(myDensitypreset, value);
                break;
            case 10:
                coerceValue(myDensityramp, value);
                break;
            case 11:
                coerceValue(myCdfield, value);
                break;
            case 12:
                coerceValue(myCdrangeoverride, value);
                break;
            case 13:
                coerceValue(myCdrange, value);
                break;
            case 14:
                coerceValue(myCdrampmode, value);
                break;
            case 15:
                coerceValue(myCdpreset, value);
                break;
            case 16:
                coerceValue(myCdramp, value);
                break;
            case 17:
                coerceValue(myEmitscale, value);
                break;
            case 18:
                coerceValue(myEmitfield, value);
                break;
            case 19:
                coerceValue(myEmitrangeoverride, value);
                break;
            case 20:
                coerceValue(myEmitrange, value);
                break;
            case 21:
                coerceValue(myEmitrampmode, value);
                break;
            case 22:
                coerceValue(myEmitpreset, value);
                break;
            case 23:
                coerceValue(myEmitramp, value);
                break;
            case 24:
                coerceValue(myEmitcdfield, value);
                break;
            case 25:
                coerceValue(myEmitcdrangeoverride, value);
                break;
            case 26:
                coerceValue(myEmitcdrange, value);
                break;
            case 27:
                coerceValue(myEmitcdrampmode, value);
                break;
            case 28:
                coerceValue(myEmitcdpreset, value);
                break;
            case 29:
                coerceValue(myEmitcdramp, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 30;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "vismode";
            case 1:
                return "rangemin";
            case 2:
                return "rangemax";
            case 3:
                return "densityscale";
            case 4:
                return "shadowscale";
            case 5:
                return "setmaxres";
            case 6:
                return "maxres";
            case 7:
                return "densityfield";
            case 8:
                return "densityrampmode";
            case 9:
                return "densitypreset";
            case 10:
                return "densityramp";
            case 11:
                return "cdfield";
            case 12:
                return "cdrangeoverride";
            case 13:
                return "cdrange";
            case 14:
                return "cdrampmode";
            case 15:
                return "cdpreset";
            case 16:
                return "cdramp";
            case 17:
                return "emitscale";
            case 18:
                return "emitfield";
            case 19:
                return "emitrangeoverride";
            case 20:
                return "emitrange";
            case 21:
                return "emitrampmode";
            case 22:
                return "emitpreset";
            case 23:
                return "emitramp";
            case 24:
                return "emitcdfield";
            case 25:
                return "emitcdrangeoverride";
            case 26:
                return "emitcdrange";
            case 27:
                return "emitcdrampmode";
            case 28:
                return "emitcdpreset";
            case 29:
                return "emitcdramp";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_INTEGER;
                case 1:
                    return PARM_FLOAT;
                case 2:
                    return PARM_FLOAT;
                case 3:
                    return PARM_FLOAT;
                case 4:
                    return PARM_FLOAT;
                case 5:
                    return PARM_INTEGER;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_STRING;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_RAMP;
                case 11:
                    return PARM_STRING;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_VECTOR2;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_INTEGER;
                case 16:
                    return PARM_RAMP;
                case 17:
                    return PARM_FLOAT;
                case 18:
                    return PARM_STRING;
                case 19:
                    return PARM_INTEGER;
                case 20:
                    return PARM_VECTOR2;
                case 21:
                    return PARM_INTEGER;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_RAMP;
                case 24:
                    return PARM_STRING;
                case 25:
                    return PARM_INTEGER;
                case 26:
                    return PARM_VECTOR2;
                case 27:
                    return PARM_INTEGER;
                case 28:
                    return PARM_INTEGER;
                case 29:
                    return PARM_RAMP;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myVisMode);
        saveData(os, myRangemin);
        saveData(os, myRangemax);
        saveData(os, myDensityscale);
        saveData(os, myShadowscale);
        saveData(os, mySetmaxres);
        saveData(os, myMaxres);
        saveData(os, myDensityfield);
        saveData(os, myDensityrampmode);
        saveData(os, myDensitypreset);
        saveData(os, myDensityramp);
        saveData(os, myCdfield);
        saveData(os, myCdrangeoverride);
        saveData(os, myCdrange);
        saveData(os, myCdrampmode);
        saveData(os, myCdpreset);
        saveData(os, myCdramp);
        saveData(os, myEmitscale);
        saveData(os, myEmitfield);
        saveData(os, myEmitrangeoverride);
        saveData(os, myEmitrange);
        saveData(os, myEmitrampmode);
        saveData(os, myEmitpreset);
        saveData(os, myEmitramp);
        saveData(os, myEmitcdfield);
        saveData(os, myEmitcdrangeoverride);
        saveData(os, myEmitcdrange);
        saveData(os, myEmitcdrampmode);
        saveData(os, myEmitcdpreset);
        saveData(os, myEmitcdramp);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myVisMode);
        loadData(is, myRangemin);
        loadData(is, myRangemax);
        loadData(is, myDensityscale);
        loadData(is, myShadowscale);
        loadData(is, mySetmaxres);
        loadData(is, myMaxres);
        loadData(is, myDensityfield);
        loadData(is, myDensityrampmode);
        loadData(is, myDensitypreset);
        loadData(is, myDensityramp);
        loadData(is, myCdfield);
        loadData(is, myCdrangeoverride);
        loadData(is, myCdrange);
        loadData(is, myCdrampmode);
        loadData(is, myCdpreset);
        loadData(is, myCdramp);
        loadData(is, myEmitscale);
        loadData(is, myEmitfield);
        loadData(is, myEmitrangeoverride);
        loadData(is, myEmitrange);
        loadData(is, myEmitrampmode);
        loadData(is, myEmitpreset);
        loadData(is, myEmitramp);
        loadData(is, myEmitcdfield);
        loadData(is, myEmitcdrangeoverride);
        loadData(is, myEmitcdrange);
        loadData(is, myEmitcdrampmode);
        loadData(is, myEmitcdpreset);
        loadData(is, myEmitcdramp);

        return true;
    }

    VisMode getVisMode() const { return VisMode(myVisMode); }
    void setVisMode(VisMode val) { myVisMode = int64(val); }
    VisMode opVisMode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVisMode();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "vismode", cookparms.getCookTime(), 0);
        return VisMode(result);
    }
    fpreal64 getRangemin() const { return myRangemin; }
    void setRangemin(fpreal64 val) { myRangemin = val; }
    fpreal64 opRangemin(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRangemin();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "rangemin", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getRangemax() const { return myRangemax; }
    void setRangemax(fpreal64 val) { myRangemax = val; }
    fpreal64 opRangemax(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRangemax();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "rangemax", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getDensityscale() const { return myDensityscale; }
    void setDensityscale(fpreal64 val) { myDensityscale = val; }
    fpreal64 opDensityscale(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDensityscale();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "densityscale", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getShadowscale() const { return myShadowscale; }
    void setShadowscale(fpreal64 val) { myShadowscale = val; }
    fpreal64 opShadowscale(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getShadowscale();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "shadowscale", cookparms.getCookTime(), 0);
        return result;
    }
    bool getSetmaxres() const { return mySetmaxres; }
    void setSetmaxres(bool val) { mySetmaxres = val; }
    bool opSetmaxres(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSetmaxres();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "setmaxres", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getMaxres() const { return myMaxres; }
    void setMaxres(int64 val) { myMaxres = val; }
    int64 opMaxres(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxres();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "maxres", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getDensityfield() const { return myDensityfield; }
    void setDensityfield(const UT_StringHolder & val) { myDensityfield = val; }
    UT_StringHolder opDensityfield(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDensityfield();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "densityfield", cookparms.getCookTime(), 0);
        return result;
    }
    Densityrampmode getDensityrampmode() const { return Densityrampmode(myDensityrampmode); }
    void setDensityrampmode(Densityrampmode val) { myDensityrampmode = int64(val); }
    Densityrampmode opDensityrampmode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDensityrampmode();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "densityrampmode", cookparms.getCookTime(), 0);
        return Densityrampmode(result);
    }
    Densitypreset getDensitypreset() const { return Densitypreset(myDensitypreset); }
    void setDensitypreset(Densitypreset val) { myDensitypreset = int64(val); }
    Densitypreset opDensitypreset(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDensitypreset();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "densitypreset", cookparms.getCookTime(), 0);
        return Densitypreset(result);
    }
    UT_SharedPtr<UT_Ramp> getDensityramp() const { return myDensityramp; }
    void setDensityramp(UT_SharedPtr<UT_Ramp> val) { myDensityramp = val; }
    UT_SharedPtr<UT_Ramp> opDensityramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDensityramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "densityramp", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getCdfield() const { return myCdfield; }
    void setCdfield(const UT_StringHolder & val) { myCdfield = val; }
    UT_StringHolder opCdfield(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCdfield();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "cdfield", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCdrangeoverride() const { return myCdrangeoverride; }
    void setCdrangeoverride(bool val) { myCdrangeoverride = val; }
    bool opCdrangeoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCdrangeoverride();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "cdrangeoverride", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector2D getCdrange() const { return myCdrange; }
    void setCdrange(UT_Vector2D val) { myCdrange = val; }
    UT_Vector2D opCdrange(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCdrange();
        UT_Vector2D result;
        OP_Utils::evalOpParm(result, thissop, "cdrange", cookparms.getCookTime(), 0);
        return result;
    }
    Cdrampmode getCdrampmode() const { return Cdrampmode(myCdrampmode); }
    void setCdrampmode(Cdrampmode val) { myCdrampmode = int64(val); }
    Cdrampmode opCdrampmode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCdrampmode();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "cdrampmode", cookparms.getCookTime(), 0);
        return Cdrampmode(result);
    }
    Cdpreset getCdpreset() const { return Cdpreset(myCdpreset); }
    void setCdpreset(Cdpreset val) { myCdpreset = int64(val); }
    Cdpreset opCdpreset(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCdpreset();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "cdpreset", cookparms.getCookTime(), 0);
        return Cdpreset(result);
    }
    UT_SharedPtr<UT_Ramp> getCdramp() const { return myCdramp; }
    void setCdramp(UT_SharedPtr<UT_Ramp> val) { myCdramp = val; }
    UT_SharedPtr<UT_Ramp> opCdramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCdramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "cdramp", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getEmitscale() const { return myEmitscale; }
    void setEmitscale(fpreal64 val) { myEmitscale = val; }
    fpreal64 opEmitscale(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitscale();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "emitscale", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getEmitfield() const { return myEmitfield; }
    void setEmitfield(const UT_StringHolder & val) { myEmitfield = val; }
    UT_StringHolder opEmitfield(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitfield();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "emitfield", cookparms.getCookTime(), 0);
        return result;
    }
    bool getEmitrangeoverride() const { return myEmitrangeoverride; }
    void setEmitrangeoverride(bool val) { myEmitrangeoverride = val; }
    bool opEmitrangeoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitrangeoverride();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "emitrangeoverride", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector2D getEmitrange() const { return myEmitrange; }
    void setEmitrange(UT_Vector2D val) { myEmitrange = val; }
    UT_Vector2D opEmitrange(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitrange();
        UT_Vector2D result;
        OP_Utils::evalOpParm(result, thissop, "emitrange", cookparms.getCookTime(), 0);
        return result;
    }
    Emitrampmode getEmitrampmode() const { return Emitrampmode(myEmitrampmode); }
    void setEmitrampmode(Emitrampmode val) { myEmitrampmode = int64(val); }
    Emitrampmode opEmitrampmode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitrampmode();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "emitrampmode", cookparms.getCookTime(), 0);
        return Emitrampmode(result);
    }
    Emitpreset getEmitpreset() const { return Emitpreset(myEmitpreset); }
    void setEmitpreset(Emitpreset val) { myEmitpreset = int64(val); }
    Emitpreset opEmitpreset(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitpreset();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "emitpreset", cookparms.getCookTime(), 0);
        return Emitpreset(result);
    }
    UT_SharedPtr<UT_Ramp> getEmitramp() const { return myEmitramp; }
    void setEmitramp(UT_SharedPtr<UT_Ramp> val) { myEmitramp = val; }
    UT_SharedPtr<UT_Ramp> opEmitramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "emitramp", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getEmitcdfield() const { return myEmitcdfield; }
    void setEmitcdfield(const UT_StringHolder & val) { myEmitcdfield = val; }
    UT_StringHolder opEmitcdfield(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitcdfield();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "emitcdfield", cookparms.getCookTime(), 0);
        return result;
    }
    bool getEmitcdrangeoverride() const { return myEmitcdrangeoverride; }
    void setEmitcdrangeoverride(bool val) { myEmitcdrangeoverride = val; }
    bool opEmitcdrangeoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitcdrangeoverride();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "emitcdrangeoverride", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector2D getEmitcdrange() const { return myEmitcdrange; }
    void setEmitcdrange(UT_Vector2D val) { myEmitcdrange = val; }
    UT_Vector2D opEmitcdrange(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitcdrange();
        UT_Vector2D result;
        OP_Utils::evalOpParm(result, thissop, "emitcdrange", cookparms.getCookTime(), 0);
        return result;
    }
    Emitcdrampmode getEmitcdrampmode() const { return Emitcdrampmode(myEmitcdrampmode); }
    void setEmitcdrampmode(Emitcdrampmode val) { myEmitcdrampmode = int64(val); }
    Emitcdrampmode opEmitcdrampmode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitcdrampmode();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "emitcdrampmode", cookparms.getCookTime(), 0);
        return Emitcdrampmode(result);
    }
    Emitcdpreset getEmitcdpreset() const { return Emitcdpreset(myEmitcdpreset); }
    void setEmitcdpreset(Emitcdpreset val) { myEmitcdpreset = int64(val); }
    Emitcdpreset opEmitcdpreset(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitcdpreset();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "emitcdpreset", cookparms.getCookTime(), 0);
        return Emitcdpreset(result);
    }
    UT_SharedPtr<UT_Ramp> getEmitcdramp() const { return myEmitcdramp; }
    void setEmitcdramp(UT_SharedPtr<UT_Ramp> val) { myEmitcdramp = val; }
    UT_SharedPtr<UT_Ramp> opEmitcdramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEmitcdramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "emitcdramp", cookparms.getCookTime(), 0);
        return result;
    }

private:
    int64 myVisMode;
    fpreal64 myRangemin;
    fpreal64 myRangemax;
    fpreal64 myDensityscale;
    fpreal64 myShadowscale;
    bool mySetmaxres;
    int64 myMaxres;
    UT_StringHolder myDensityfield;
    int64 myDensityrampmode;
    int64 myDensitypreset;
    UT_SharedPtr<UT_Ramp> myDensityramp;
    UT_StringHolder myCdfield;
    bool myCdrangeoverride;
    UT_Vector2D myCdrange;
    int64 myCdrampmode;
    int64 myCdpreset;
    UT_SharedPtr<UT_Ramp> myCdramp;
    fpreal64 myEmitscale;
    UT_StringHolder myEmitfield;
    bool myEmitrangeoverride;
    UT_Vector2D myEmitrange;
    int64 myEmitrampmode;
    int64 myEmitpreset;
    UT_SharedPtr<UT_Ramp> myEmitramp;
    UT_StringHolder myEmitcdfield;
    bool myEmitcdrangeoverride;
    UT_Vector2D myEmitcdrange;
    int64 myEmitcdrampmode;
    int64 myEmitcdpreset;
    UT_SharedPtr<UT_Ramp> myEmitcdramp;

};
