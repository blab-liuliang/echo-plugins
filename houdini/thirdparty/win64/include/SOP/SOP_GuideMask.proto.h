/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_GuideMaskEnums
{
    enum class Grouptype
    {
        PRIMITIVE = 0,
        POINT,
        EDGE
    };
    enum class Inputmaskoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Outattribtype
    {
        PRIM = 0,
        POINT
    };
    enum class Noisemaskamountoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Noisemaskgainoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Noisemaskbiasoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Noisemaskroughoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Lengthmode
    {
        LONGER = 0,
        SAMEAS,
        SHORTER,
        NORMRAMP,
        RANGERAMP
    };
    enum class Lengthrefoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Lengthfalloffrangeoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Lengthfalloffdecayoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Lengthpresets
    {
        SHORT = 0,
        MEDIUM,
        LONG
    };
    enum class Skincurvpresets
    {
        FLAT = 0,
        CONCAVECONVEX,
        CONCAVE,
        CONCAVEFLAT,
        CONVEX,
        CONVEXFLAT
    };
    enum class Geodepthramppresets
    {
        INSIDE = 0,
        OUTSIDE,
        SURFACE
    };
    enum class Randommaskcombine
    {
        MULTFRACANDVALUE = 0,
        MULTFRAC,
        MULTVALUE
    };
}


class SOP_API SOP_GuideMaskParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_GuideMaskParms()
    {
        myUvattrib = "uv"_sh;
        myGrouptype = 0;
        myGroup = ""_sh;
        myZeroungrouped = false;
        myInputmask = 1;
        myInputmaskoverride = 0;
        myInputmaskcurveattrib = "mask"_sh;
        myInputmaskattrib = "mask"_sh;
        myInputmasktexture = ""_sh;
        myVismasks = false;
        myOutattribtype = 0;
        myOutattrib = "mask"_sh;
        myCreateprimgroup = false;
        myOutprimgroup = "affected"_sh;
        myCreateintattrib = false;
        myIntattrib = "class"_sh;
        myIntattribvalue = 1;
        myIntattribthresh = 0.5;
        myUsenoisemask = false;
        myNoisemaskamount = 1;
        myNoisemaskamountoverride = 0;
        myNoisemaskamountcurveattrib = "noiseamount"_sh;
        myNoisemaskamountattrib = "noiseamount"_sh;
        myNoisemaskamounttexture = ""_sh;
        myNoisemaskfreq = 20;
        myNoisemaskgain = 0.5;
        myNoisemaskgainoverride = 0;
        myNoisemaskgaincurveattrib = "noisegain"_sh;
        myNoisemaskgainattrib = "noisegain"_sh;
        myNoisemaskgaintexture = ""_sh;
        myNoisemaskbias = 0.5;
        myNoisemaskbiasoverride = 0;
        myNoisemaskbiascurveattrib = "noisebias"_sh;
        myNoisemaskbiasattrib = "noisebias"_sh;
        myNoisemaskbiastexture = ""_sh;
        myNoisemaskcenterone = false;
        myNoisemaskfractal = false;
        myNoisemaskoct = 8;
        myNoisemasklac = 2.01234;
        myNoisemaskrough = 0.5;
        myNoisemaskroughoverride = 0;
        myNoisemaskroughcurveattrib = "noiserough"_sh;
        myNoisemaskroughattrib = "noiserough"_sh;
        myNoisemaskroughtexture = ""_sh;
        myUselengthmask = false;
        myLengthmode = 3;
        myLengthref = 0.1;
        myLengthrefoverride = 0;
        myLengthrefcurveattrib = "lengthscale"_sh;
        myLengthrefattrib = "lengthscale"_sh;
        myLengthreftexture = ""_sh;
        myLengthfalloffrange = 0.05;
        myLengthfalloffrangeoverride = 0;
        myLengthfalloffrangecurveattrib = "lengthfalloffrange"_sh;
        myLengthfalloffrangeattrib = "lengthfalloffrange"_sh;
        myLengthfalloffrangetexture = ""_sh;
        myLengthfalloffdecay = 1;
        myLengthfalloffdecayoverride = 0;
        myLengthfalloffdecaycurveattrib = "lengthfalloffdecay"_sh;
        myLengthfalloffdecayattrib = "lengthfalloffdecay"_sh;
        myLengthfalloffdecaytexture = ""_sh;
        myLengthrangemin = 0;
        myLengthrangemax = 0.1;
        myLengthpresets = 2;
        myLengthramp = UT_SharedPtr<UT_Ramp>(0);
        myUseskincurvmask = false;
        mySkincurvconcavemax = 0.25;
        mySkincurvconvexmax = 0.25;
        mySkincurvesmoothstrength = 10;
        mySkincurvpresets = 1;
        mySkincurvramp = UT_SharedPtr<UT_Ramp>(0);
        myUsegeomask = false;
        myGeovoxelsize = 0.1;
        myGeointrange = 1e-05;
        myGeoextrange = 1e-05;
        myGeodepthramppresets = 0;
        myGeodepthramp = UT_SharedPtr<UT_Ramp>(0);
        myGeodoblur = false;
        myGeoblurradius = 0;
        myGeobluriters = 1;
        myUserandommask = false;
        myRandommaskcombine = 0;
        myRandommaskseed = 0;
        myRandommaskfrac = 0.1;
        myRandommaskvar = 0;
        myRandommaskvargain = 0.5;
        myUsecurvemask = false;
        myCurvemaskabsrange = false;
        myCurvemaskrangemin = 0;
        myCurvemaskrangemax = 1;
        myCurvemaskeffectpos = 1;
        myCurvemaskfalloff = 0.5;
        myCurvemaskwidth = 1;
        myCurvemaskramp = UT_SharedPtr<UT_Ramp>(0);
        myUseskinlookupattribs = false;

    }

    explicit SOP_GuideMaskParms(const SOP_GuideMaskParms &) = default;

    virtual ~SOP_GuideMaskParms() {}

    bool operator==(const SOP_GuideMaskParms &src) const
    {
        if (myUvattrib != src.myUvattrib) return false;
        if (myGrouptype != src.myGrouptype) return false;
        if (myGroup != src.myGroup) return false;
        if (myZeroungrouped != src.myZeroungrouped) return false;
        if (myInputmask != src.myInputmask) return false;
        if (myInputmaskoverride != src.myInputmaskoverride) return false;
        if (myInputmaskcurveattrib != src.myInputmaskcurveattrib) return false;
        if (myInputmaskattrib != src.myInputmaskattrib) return false;
        if (myInputmasktexture != src.myInputmasktexture) return false;
        if (myVismasks != src.myVismasks) return false;
        if (myOutattribtype != src.myOutattribtype) return false;
        if (myOutattrib != src.myOutattrib) return false;
        if (myCreateprimgroup != src.myCreateprimgroup) return false;
        if (myOutprimgroup != src.myOutprimgroup) return false;
        if (myCreateintattrib != src.myCreateintattrib) return false;
        if (myIntattrib != src.myIntattrib) return false;
        if (myIntattribvalue != src.myIntattribvalue) return false;
        if (myIntattribthresh != src.myIntattribthresh) return false;
        if (myUsenoisemask != src.myUsenoisemask) return false;
        if (myNoisemaskamount != src.myNoisemaskamount) return false;
        if (myNoisemaskamountoverride != src.myNoisemaskamountoverride) return false;
        if (myNoisemaskamountcurveattrib != src.myNoisemaskamountcurveattrib) return false;
        if (myNoisemaskamountattrib != src.myNoisemaskamountattrib) return false;
        if (myNoisemaskamounttexture != src.myNoisemaskamounttexture) return false;
        if (myNoisemaskfreq != src.myNoisemaskfreq) return false;
        if (myNoisemaskgain != src.myNoisemaskgain) return false;
        if (myNoisemaskgainoverride != src.myNoisemaskgainoverride) return false;
        if (myNoisemaskgaincurveattrib != src.myNoisemaskgaincurveattrib) return false;
        if (myNoisemaskgainattrib != src.myNoisemaskgainattrib) return false;
        if (myNoisemaskgaintexture != src.myNoisemaskgaintexture) return false;
        if (myNoisemaskbias != src.myNoisemaskbias) return false;
        if (myNoisemaskbiasoverride != src.myNoisemaskbiasoverride) return false;
        if (myNoisemaskbiascurveattrib != src.myNoisemaskbiascurveattrib) return false;
        if (myNoisemaskbiasattrib != src.myNoisemaskbiasattrib) return false;
        if (myNoisemaskbiastexture != src.myNoisemaskbiastexture) return false;
        if (myNoisemaskcenterone != src.myNoisemaskcenterone) return false;
        if (myNoisemaskfractal != src.myNoisemaskfractal) return false;
        if (myNoisemaskoct != src.myNoisemaskoct) return false;
        if (myNoisemasklac != src.myNoisemasklac) return false;
        if (myNoisemaskrough != src.myNoisemaskrough) return false;
        if (myNoisemaskroughoverride != src.myNoisemaskroughoverride) return false;
        if (myNoisemaskroughcurveattrib != src.myNoisemaskroughcurveattrib) return false;
        if (myNoisemaskroughattrib != src.myNoisemaskroughattrib) return false;
        if (myNoisemaskroughtexture != src.myNoisemaskroughtexture) return false;
        if (myUselengthmask != src.myUselengthmask) return false;
        if (myLengthmode != src.myLengthmode) return false;
        if (myLengthref != src.myLengthref) return false;
        if (myLengthrefoverride != src.myLengthrefoverride) return false;
        if (myLengthrefcurveattrib != src.myLengthrefcurveattrib) return false;
        if (myLengthrefattrib != src.myLengthrefattrib) return false;
        if (myLengthreftexture != src.myLengthreftexture) return false;
        if (myLengthfalloffrange != src.myLengthfalloffrange) return false;
        if (myLengthfalloffrangeoverride != src.myLengthfalloffrangeoverride) return false;
        if (myLengthfalloffrangecurveattrib != src.myLengthfalloffrangecurveattrib) return false;
        if (myLengthfalloffrangeattrib != src.myLengthfalloffrangeattrib) return false;
        if (myLengthfalloffrangetexture != src.myLengthfalloffrangetexture) return false;
        if (myLengthfalloffdecay != src.myLengthfalloffdecay) return false;
        if (myLengthfalloffdecayoverride != src.myLengthfalloffdecayoverride) return false;
        if (myLengthfalloffdecaycurveattrib != src.myLengthfalloffdecaycurveattrib) return false;
        if (myLengthfalloffdecayattrib != src.myLengthfalloffdecayattrib) return false;
        if (myLengthfalloffdecaytexture != src.myLengthfalloffdecaytexture) return false;
        if (myLengthrangemin != src.myLengthrangemin) return false;
        if (myLengthrangemax != src.myLengthrangemax) return false;
        if (myLengthpresets != src.myLengthpresets) return false;
        if (myLengthramp != src.myLengthramp) return false;
        if (myUseskincurvmask != src.myUseskincurvmask) return false;
        if (mySkincurvconcavemax != src.mySkincurvconcavemax) return false;
        if (mySkincurvconvexmax != src.mySkincurvconvexmax) return false;
        if (mySkincurvesmoothstrength != src.mySkincurvesmoothstrength) return false;
        if (mySkincurvpresets != src.mySkincurvpresets) return false;
        if (mySkincurvramp != src.mySkincurvramp) return false;
        if (myUsegeomask != src.myUsegeomask) return false;
        if (myGeovoxelsize != src.myGeovoxelsize) return false;
        if (myGeointrange != src.myGeointrange) return false;
        if (myGeoextrange != src.myGeoextrange) return false;
        if (myGeodepthramppresets != src.myGeodepthramppresets) return false;
        if (myGeodepthramp != src.myGeodepthramp) return false;
        if (myGeodoblur != src.myGeodoblur) return false;
        if (myGeoblurradius != src.myGeoblurradius) return false;
        if (myGeobluriters != src.myGeobluriters) return false;
        if (myUserandommask != src.myUserandommask) return false;
        if (myRandommaskcombine != src.myRandommaskcombine) return false;
        if (myRandommaskseed != src.myRandommaskseed) return false;
        if (myRandommaskfrac != src.myRandommaskfrac) return false;
        if (myRandommaskvar != src.myRandommaskvar) return false;
        if (myRandommaskvargain != src.myRandommaskvargain) return false;
        if (myUsecurvemask != src.myUsecurvemask) return false;
        if (myCurvemaskabsrange != src.myCurvemaskabsrange) return false;
        if (myCurvemaskrangemin != src.myCurvemaskrangemin) return false;
        if (myCurvemaskrangemax != src.myCurvemaskrangemax) return false;
        if (myCurvemaskeffectpos != src.myCurvemaskeffectpos) return false;
        if (myCurvemaskfalloff != src.myCurvemaskfalloff) return false;
        if (myCurvemaskwidth != src.myCurvemaskwidth) return false;
        if (myCurvemaskramp != src.myCurvemaskramp) return false;
        if (myUseskinlookupattribs != src.myUseskinlookupattribs) return false;

        return true;
    }
    bool operator!=(const SOP_GuideMaskParms &src) const
    {
        return !operator==(src);
    }
    using Grouptype = SOP_GuideMaskEnums::Grouptype;
    using Inputmaskoverride = SOP_GuideMaskEnums::Inputmaskoverride;
    using Outattribtype = SOP_GuideMaskEnums::Outattribtype;
    using Noisemaskamountoverride = SOP_GuideMaskEnums::Noisemaskamountoverride;
    using Noisemaskgainoverride = SOP_GuideMaskEnums::Noisemaskgainoverride;
    using Noisemaskbiasoverride = SOP_GuideMaskEnums::Noisemaskbiasoverride;
    using Noisemaskroughoverride = SOP_GuideMaskEnums::Noisemaskroughoverride;
    using Lengthmode = SOP_GuideMaskEnums::Lengthmode;
    using Lengthrefoverride = SOP_GuideMaskEnums::Lengthrefoverride;
    using Lengthfalloffrangeoverride = SOP_GuideMaskEnums::Lengthfalloffrangeoverride;
    using Lengthfalloffdecayoverride = SOP_GuideMaskEnums::Lengthfalloffdecayoverride;
    using Lengthpresets = SOP_GuideMaskEnums::Lengthpresets;
    using Skincurvpresets = SOP_GuideMaskEnums::Skincurvpresets;
    using Geodepthramppresets = SOP_GuideMaskEnums::Geodepthramppresets;
    using Randommaskcombine = SOP_GuideMaskEnums::Randommaskcombine;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myUvattrib, node, "uvattrib", time, 0);
        else myUvattrib = "uv"_sh;
        if (true)
            OP_Utils::evalOpParm(myGrouptype, node, "grouptype", time, 0);
        else myGrouptype = 0;
        if (true)
            OP_Utils::evalOpParm(myGroup, node, "group", time, 0);
        else myGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myZeroungrouped, node, "zeroungrouped", time, 0);
        else myZeroungrouped = false;
        if (true)
            OP_Utils::evalOpParm(myInputmask, node, "inputmask", time, 0);
        else myInputmask = 1;
        if (true)
            OP_Utils::evalOpParm(myInputmaskoverride, node, "inputmaskoverride", time, 0);
        else myInputmaskoverride = 0;
        if (true && ( (!(((int64(getInputmaskoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myInputmaskcurveattrib, node, "inputmaskcurveattrib", time, 0);
        else myInputmaskcurveattrib = "mask"_sh;
        if (true && ( (!(((int64(getInputmaskoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myInputmaskattrib, node, "inputmaskattrib", time, 0);
        else myInputmaskattrib = "mask"_sh;
        if (true && ( (!(((int64(getInputmaskoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myInputmasktexture, node, "inputmasktexture", time, 0);
        else myInputmasktexture = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myVismasks, node, "vismasks", time, 0);
        else myVismasks = false;
        if (true)
            OP_Utils::evalOpParm(myOutattribtype, node, "outattribtype", time, 0);
        else myOutattribtype = 0;
        if (true)
            OP_Utils::evalOpParm(myOutattrib, node, "outattrib", time, 0);
        else myOutattrib = "mask"_sh;
        if (true)
            OP_Utils::evalOpParm(myCreateprimgroup, node, "createprimgroup", time, 0);
        else myCreateprimgroup = false;
        if (true && ( (!(((getCreateprimgroup()==0)))) ) )
            OP_Utils::evalOpParm(myOutprimgroup, node, "outprimgroup", time, 0);
        else myOutprimgroup = "affected"_sh;
        if (true && ( (!(((int64(getOutattribtype())!=0)))) ) )
            OP_Utils::evalOpParm(myCreateintattrib, node, "createintattrib", time, 0);
        else myCreateintattrib = false;
        if (true && ( (!(((int64(getOutattribtype())!=0))||((getCreateintattrib()==0)))) ) )
            OP_Utils::evalOpParm(myIntattrib, node, "intattrib", time, 0);
        else myIntattrib = "class"_sh;
        if (true && ( (!(((int64(getOutattribtype())!=0))||((getCreateintattrib()==0)))) ) )
            OP_Utils::evalOpParm(myIntattribvalue, node, "intattribvalue", time, 0);
        else myIntattribvalue = 1;
        if (true && ( (!(((int64(getOutattribtype())!=0))||((getCreateintattrib()==0)))) ) )
            OP_Utils::evalOpParm(myIntattribthresh, node, "intattribthresh", time, 0);
        else myIntattribthresh = 0.5;
        if (true)
            OP_Utils::evalOpParm(myUsenoisemask, node, "usenoisemask", time, 0);
        else myUsenoisemask = false;
        if (true && ( (!(((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskamount, node, "noisemaskamount", time, 0);
        else myNoisemaskamount = 1;
        if (true && ( (!(((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskamountoverride, node, "noisemaskamountoverride", time, 0);
        else myNoisemaskamountoverride = 0;
        if (true && ( (!(((getUsenoisemask()==0))||((int64(getNoisemaskamountoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myNoisemaskamountcurveattrib, node, "noisemaskamountcurveattrib", time, 0);
        else myNoisemaskamountcurveattrib = "noiseamount"_sh;
        if (true && ( (!(((getUsenoisemask()==0))||((int64(getNoisemaskamountoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myNoisemaskamountattrib, node, "noisemaskamountattrib", time, 0);
        else myNoisemaskamountattrib = "noiseamount"_sh;
        if (true && ( (!(((getUsenoisemask()==0))||((int64(getNoisemaskamountoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myNoisemaskamounttexture, node, "noisemaskamounttexture", time, 0);
        else myNoisemaskamounttexture = ""_sh;
        if (true && ( (!(((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskfreq, node, "noisemaskfreq", time, 0);
        else myNoisemaskfreq = 20;
        if (true && ( (!(((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskgain, node, "noisemaskgain", time, 0);
        else myNoisemaskgain = 0.5;
        if (true && ( (!(((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskgainoverride, node, "noisemaskgainoverride", time, 0);
        else myNoisemaskgainoverride = 0;
        if (true && ( (!(((getUsenoisemask()==0))||((int64(getNoisemaskgainoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myNoisemaskgaincurveattrib, node, "noisemaskgaincurveattrib", time, 0);
        else myNoisemaskgaincurveattrib = "noisegain"_sh;
        if (true && ( (!(((getUsenoisemask()==0))||((int64(getNoisemaskgainoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myNoisemaskgainattrib, node, "noisemaskgainattrib", time, 0);
        else myNoisemaskgainattrib = "noisegain"_sh;
        if (true && ( (!(((getUsenoisemask()==0))||((int64(getNoisemaskgainoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myNoisemaskgaintexture, node, "noisemaskgaintexture", time, 0);
        else myNoisemaskgaintexture = ""_sh;
        if (true && ( (!(((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskbias, node, "noisemaskbias", time, 0);
        else myNoisemaskbias = 0.5;
        if (true && ( (!(((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskbiasoverride, node, "noisemaskbiasoverride", time, 0);
        else myNoisemaskbiasoverride = 0;
        if (true && ( (!(((getUsenoisemask()==0))||((int64(getNoisemaskbiasoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myNoisemaskbiascurveattrib, node, "noisemaskbiascurveattrib", time, 0);
        else myNoisemaskbiascurveattrib = "noisebias"_sh;
        if (true && ( (!(((getUsenoisemask()==0))||((int64(getNoisemaskbiasoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myNoisemaskbiasattrib, node, "noisemaskbiasattrib", time, 0);
        else myNoisemaskbiasattrib = "noisebias"_sh;
        if (true && ( (!(((getUsenoisemask()==0))||((int64(getNoisemaskbiasoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myNoisemaskbiastexture, node, "noisemaskbiastexture", time, 0);
        else myNoisemaskbiastexture = ""_sh;
        if (true && ( (!(((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskcenterone, node, "noisemaskcenterone", time, 0);
        else myNoisemaskcenterone = false;
        if (true && ( (!(((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskfractal, node, "noisemaskfractal", time, 0);
        else myNoisemaskfractal = false;
        if (true && ( (!(((getNoisemaskfractal()==0))||((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskoct, node, "noisemaskoct", time, 0);
        else myNoisemaskoct = 8;
        if (true && ( (!(((getNoisemaskfractal()==0))||((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemasklac, node, "noisemasklac", time, 0);
        else myNoisemasklac = 2.01234;
        if (true && ( (!(((getNoisemaskfractal()==0))||((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskrough, node, "noisemaskrough", time, 0);
        else myNoisemaskrough = 0.5;
        if (true && ( (!(((getNoisemaskfractal()==0))||((getUsenoisemask()==0)))) ) )
            OP_Utils::evalOpParm(myNoisemaskroughoverride, node, "noisemaskroughoverride", time, 0);
        else myNoisemaskroughoverride = 0;
        if (true && ( (!(((getNoisemaskfractal()==0))||((getUsenoisemask()==0))||((int64(getNoisemaskroughoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myNoisemaskroughcurveattrib, node, "noisemaskroughcurveattrib", time, 0);
        else myNoisemaskroughcurveattrib = "noiserough"_sh;
        if (true && ( (!(((getNoisemaskfractal()==0))||((getUsenoisemask()==0))||((int64(getNoisemaskroughoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myNoisemaskroughattrib, node, "noisemaskroughattrib", time, 0);
        else myNoisemaskroughattrib = "noiserough"_sh;
        if (true && ( (!(((getNoisemaskfractal()==0))||((getUsenoisemask()==0))||((int64(getNoisemaskroughoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myNoisemaskroughtexture, node, "noisemaskroughtexture", time, 0);
        else myNoisemaskroughtexture = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUselengthmask, node, "uselengthmask", time, 0);
        else myUselengthmask = false;
        if (true && ( (!(((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthmode, node, "lengthmode", time, 0);
        else myLengthmode = 3;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthref, node, "lengthref", time, 0);
        else myLengthref = 0.1;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthrefoverride, node, "lengthrefoverride", time, 0);
        else myLengthrefoverride = 0;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0))||((int64(getLengthrefoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myLengthrefcurveattrib, node, "lengthrefcurveattrib", time, 0);
        else myLengthrefcurveattrib = "lengthscale"_sh;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0))||((int64(getLengthrefoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myLengthrefattrib, node, "lengthrefattrib", time, 0);
        else myLengthrefattrib = "lengthscale"_sh;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0))||((int64(getLengthrefoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myLengthreftexture, node, "lengthreftexture", time, 0);
        else myLengthreftexture = ""_sh;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffrange, node, "lengthfalloffrange", time, 0);
        else myLengthfalloffrange = 0.05;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffrangeoverride, node, "lengthfalloffrangeoverride", time, 0);
        else myLengthfalloffrangeoverride = 0;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0))||((int64(getLengthfalloffrangeoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffrangecurveattrib, node, "lengthfalloffrangecurveattrib", time, 0);
        else myLengthfalloffrangecurveattrib = "lengthfalloffrange"_sh;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0))||((int64(getLengthfalloffrangeoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffrangeattrib, node, "lengthfalloffrangeattrib", time, 0);
        else myLengthfalloffrangeattrib = "lengthfalloffrange"_sh;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0))||((int64(getLengthfalloffrangeoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffrangetexture, node, "lengthfalloffrangetexture", time, 0);
        else myLengthfalloffrangetexture = ""_sh;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffdecay, node, "lengthfalloffdecay", time, 0);
        else myLengthfalloffdecay = 1;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffdecayoverride, node, "lengthfalloffdecayoverride", time, 0);
        else myLengthfalloffdecayoverride = 0;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0))||((int64(getLengthfalloffdecayoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffdecaycurveattrib, node, "lengthfalloffdecaycurveattrib", time, 0);
        else myLengthfalloffdecaycurveattrib = "lengthfalloffdecay"_sh;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0))||((int64(getLengthfalloffdecayoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffdecayattrib, node, "lengthfalloffdecayattrib", time, 0);
        else myLengthfalloffdecayattrib = "lengthfalloffdecay"_sh;
        if (true && ( (!(((int64(getLengthmode())!=2)&&(int64(getLengthmode())!=1)&&(int64(getLengthmode())!=0))||((getUselengthmask()==0))||((int64(getLengthfalloffdecayoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myLengthfalloffdecaytexture, node, "lengthfalloffdecaytexture", time, 0);
        else myLengthfalloffdecaytexture = ""_sh;
        if (true && ( (!(((int64(getLengthmode())!=4))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthrangemin, node, "lengthrangemin", time, 0);
        else myLengthrangemin = 0;
        if (true && ( (!(((int64(getLengthmode())!=4))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthrangemax, node, "lengthrangemax", time, 0);
        else myLengthrangemax = 0.1;
        if (true && ( (!(((int64(getLengthmode())!=3)&&(int64(getLengthmode())!=4))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthpresets, node, "lengthpresets", time, 0);
        else myLengthpresets = 2;
        if (true && ( (!(((int64(getLengthmode())!=3)&&(int64(getLengthmode())!=4))||((getUselengthmask()==0)))) ) )
            OP_Utils::evalOpParm(myLengthramp, node, "lengthramp", time, 0);
        else myLengthramp = UT_SharedPtr<UT_Ramp>(0);
        if (true)
            OP_Utils::evalOpParm(myUseskincurvmask, node, "useskincurvmask", time, 0);
        else myUseskincurvmask = false;
        if (true && ( (!(((getUseskincurvmask()==0)))) ) )
            OP_Utils::evalOpParm(mySkincurvconcavemax, node, "skincurvconcavemax", time, 0);
        else mySkincurvconcavemax = 0.25;
        if (true && ( (!(((getUseskincurvmask()==0)))) ) )
            OP_Utils::evalOpParm(mySkincurvconvexmax, node, "skincurvconvexmax", time, 0);
        else mySkincurvconvexmax = 0.25;
        if (true && ( (!(((getUseskincurvmask()==0)))) ) )
            OP_Utils::evalOpParm(mySkincurvesmoothstrength, node, "skincurvesmoothstrength", time, 0);
        else mySkincurvesmoothstrength = 10;
        if (true && ( (!(((getUseskincurvmask()==0)))) ) )
            OP_Utils::evalOpParm(mySkincurvpresets, node, "skincurvpresets", time, 0);
        else mySkincurvpresets = 1;
        if (true && ( (!(((getUseskincurvmask()==0)))) ) )
            OP_Utils::evalOpParm(mySkincurvramp, node, "skincurvramp", time, 0);
        else mySkincurvramp = UT_SharedPtr<UT_Ramp>(0);
        if (true)
            OP_Utils::evalOpParm(myUsegeomask, node, "usegeomask", time, 0);
        else myUsegeomask = false;
        if (true && ( (!(((getUsegeomask()==0)))) ) )
            OP_Utils::evalOpParm(myGeovoxelsize, node, "geovoxelsize", time, 0);
        else myGeovoxelsize = 0.1;
        if (true && ( (!(((getUsegeomask()==0)))) ) )
            OP_Utils::evalOpParm(myGeointrange, node, "geointrange", time, 0);
        else myGeointrange = 1e-05;
        if (true && ( (!(((getUsegeomask()==0)))) ) )
            OP_Utils::evalOpParm(myGeoextrange, node, "geoextrange", time, 0);
        else myGeoextrange = 1e-05;
        if (true && ( (!(((getUsegeomask()==0)))) ) )
            OP_Utils::evalOpParm(myGeodepthramppresets, node, "geodepthramppresets", time, 0);
        else myGeodepthramppresets = 0;
        if (true && ( (!(((getUsegeomask()==0)))) ) )
            OP_Utils::evalOpParm(myGeodepthramp, node, "geodepthramp", time, 0);
        else myGeodepthramp = UT_SharedPtr<UT_Ramp>(0);
        if (true && ( (!(((getUsegeomask()==0)))) ) )
            OP_Utils::evalOpParm(myGeodoblur, node, "geodoblur", time, 0);
        else myGeodoblur = false;
        if (true && ( (!(((getGeodoblur()==0))||((getUsegeomask()==0)))) ) )
            OP_Utils::evalOpParm(myGeoblurradius, node, "geoblurradius", time, 0);
        else myGeoblurradius = 0;
        if (true && ( (!(((getGeodoblur()==0))||((getUsegeomask()==0)))) ) )
            OP_Utils::evalOpParm(myGeobluriters, node, "geobluriters", time, 0);
        else myGeobluriters = 1;
        if (true)
            OP_Utils::evalOpParm(myUserandommask, node, "userandommask", time, 0);
        else myUserandommask = false;
        if (true && ( (!(((getUserandommask()==0)))) ) )
            OP_Utils::evalOpParm(myRandommaskcombine, node, "randommaskcombine", time, 0);
        else myRandommaskcombine = 0;
        if (true && ( (!(((getUserandommask()==0)))) ) )
            OP_Utils::evalOpParm(myRandommaskseed, node, "randommaskseed", time, 0);
        else myRandommaskseed = 0;
        if (true && ( (!(((getUserandommask()==0)))) ) )
            OP_Utils::evalOpParm(myRandommaskfrac, node, "randommaskfrac", time, 0);
        else myRandommaskfrac = 0.1;
        if (true && ( (!(((getUserandommask()==0)))) ) )
            OP_Utils::evalOpParm(myRandommaskvar, node, "randommaskvar", time, 0);
        else myRandommaskvar = 0;
        if (true && ( (!(((getRandommaskvar()==0))||((getUserandommask()==0)))) ) )
            OP_Utils::evalOpParm(myRandommaskvargain, node, "randommaskvargain", time, 0);
        else myRandommaskvargain = 0.5;
        if (true && ( (!(((int64(getOutattribtype())==0)))) ) )
            OP_Utils::evalOpParm(myUsecurvemask, node, "usecurvemask", time, 0);
        else myUsecurvemask = false;
        if (true && ( (!(((int64(getOutattribtype())==0))||((getUsecurvemask()==0)))) ) )
            OP_Utils::evalOpParm(myCurvemaskabsrange, node, "curvemaskabsrange", time, 0);
        else myCurvemaskabsrange = false;
        if (true && ( (!(((int64(getOutattribtype())==0))||((getUsecurvemask()==0)))) ) )
            OP_Utils::evalOpParm(myCurvemaskrangemin, node, "curvemaskrangemin", time, 0);
        else myCurvemaskrangemin = 0;
        if (true && ( (!(((int64(getOutattribtype())==0))||((getUsecurvemask()==0)))) ) )
            OP_Utils::evalOpParm(myCurvemaskrangemax, node, "curvemaskrangemax", time, 0);
        else myCurvemaskrangemax = 1;
        if (true && ( (!(((int64(getOutattribtype())==0))||((getUsecurvemask()==0)))) ) )
            OP_Utils::evalOpParm(myCurvemaskeffectpos, node, "curvemaskeffectpos", time, 0);
        else myCurvemaskeffectpos = 1;
        if (true && ( (!(((int64(getOutattribtype())==0))||((getUsecurvemask()==0)))) ) )
            OP_Utils::evalOpParm(myCurvemaskfalloff, node, "curvemaskfalloff", time, 0);
        else myCurvemaskfalloff = 0.5;
        if (true && ( (!(((int64(getOutattribtype())==0))||((getUsecurvemask()==0)))) ) )
            OP_Utils::evalOpParm(myCurvemaskwidth, node, "curvemaskwidth", time, 0);
        else myCurvemaskwidth = 1;
        if (true && ( (!(((int64(getOutattribtype())==0))||((getUsecurvemask()==0)))) ) )
            OP_Utils::evalOpParm(myCurvemaskramp, node, "curvemaskramp", time, 0);
        else myCurvemaskramp = UT_SharedPtr<UT_Ramp>(0);
        if (true)
            OP_Utils::evalOpParm(myUseskinlookupattribs, node, "useskinlookupattribs", time, 0);
        else myUseskinlookupattribs = false;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_GuideMaskParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myUvattrib);
                break;
            case 1:
                coerceValue(value, myGrouptype);
                break;
            case 2:
                coerceValue(value, myGroup);
                break;
            case 3:
                coerceValue(value, myZeroungrouped);
                break;
            case 4:
                coerceValue(value, myInputmask);
                break;
            case 5:
                coerceValue(value, myInputmaskoverride);
                break;
            case 6:
                coerceValue(value, myInputmaskcurveattrib);
                break;
            case 7:
                coerceValue(value, myInputmaskattrib);
                break;
            case 8:
                coerceValue(value, myInputmasktexture);
                break;
            case 9:
                coerceValue(value, myVismasks);
                break;
            case 10:
                coerceValue(value, myOutattribtype);
                break;
            case 11:
                coerceValue(value, myOutattrib);
                break;
            case 12:
                coerceValue(value, myCreateprimgroup);
                break;
            case 13:
                coerceValue(value, myOutprimgroup);
                break;
            case 14:
                coerceValue(value, myCreateintattrib);
                break;
            case 15:
                coerceValue(value, myIntattrib);
                break;
            case 16:
                coerceValue(value, myIntattribvalue);
                break;
            case 17:
                coerceValue(value, myIntattribthresh);
                break;
            case 18:
                coerceValue(value, myUsenoisemask);
                break;
            case 19:
                coerceValue(value, myNoisemaskamount);
                break;
            case 20:
                coerceValue(value, myNoisemaskamountoverride);
                break;
            case 21:
                coerceValue(value, myNoisemaskamountcurveattrib);
                break;
            case 22:
                coerceValue(value, myNoisemaskamountattrib);
                break;
            case 23:
                coerceValue(value, myNoisemaskamounttexture);
                break;
            case 24:
                coerceValue(value, myNoisemaskfreq);
                break;
            case 25:
                coerceValue(value, myNoisemaskgain);
                break;
            case 26:
                coerceValue(value, myNoisemaskgainoverride);
                break;
            case 27:
                coerceValue(value, myNoisemaskgaincurveattrib);
                break;
            case 28:
                coerceValue(value, myNoisemaskgainattrib);
                break;
            case 29:
                coerceValue(value, myNoisemaskgaintexture);
                break;
            case 30:
                coerceValue(value, myNoisemaskbias);
                break;
            case 31:
                coerceValue(value, myNoisemaskbiasoverride);
                break;
            case 32:
                coerceValue(value, myNoisemaskbiascurveattrib);
                break;
            case 33:
                coerceValue(value, myNoisemaskbiasattrib);
                break;
            case 34:
                coerceValue(value, myNoisemaskbiastexture);
                break;
            case 35:
                coerceValue(value, myNoisemaskcenterone);
                break;
            case 36:
                coerceValue(value, myNoisemaskfractal);
                break;
            case 37:
                coerceValue(value, myNoisemaskoct);
                break;
            case 38:
                coerceValue(value, myNoisemasklac);
                break;
            case 39:
                coerceValue(value, myNoisemaskrough);
                break;
            case 40:
                coerceValue(value, myNoisemaskroughoverride);
                break;
            case 41:
                coerceValue(value, myNoisemaskroughcurveattrib);
                break;
            case 42:
                coerceValue(value, myNoisemaskroughattrib);
                break;
            case 43:
                coerceValue(value, myNoisemaskroughtexture);
                break;
            case 44:
                coerceValue(value, myUselengthmask);
                break;
            case 45:
                coerceValue(value, myLengthmode);
                break;
            case 46:
                coerceValue(value, myLengthref);
                break;
            case 47:
                coerceValue(value, myLengthrefoverride);
                break;
            case 48:
                coerceValue(value, myLengthrefcurveattrib);
                break;
            case 49:
                coerceValue(value, myLengthrefattrib);
                break;
            case 50:
                coerceValue(value, myLengthreftexture);
                break;
            case 51:
                coerceValue(value, myLengthfalloffrange);
                break;
            case 52:
                coerceValue(value, myLengthfalloffrangeoverride);
                break;
            case 53:
                coerceValue(value, myLengthfalloffrangecurveattrib);
                break;
            case 54:
                coerceValue(value, myLengthfalloffrangeattrib);
                break;
            case 55:
                coerceValue(value, myLengthfalloffrangetexture);
                break;
            case 56:
                coerceValue(value, myLengthfalloffdecay);
                break;
            case 57:
                coerceValue(value, myLengthfalloffdecayoverride);
                break;
            case 58:
                coerceValue(value, myLengthfalloffdecaycurveattrib);
                break;
            case 59:
                coerceValue(value, myLengthfalloffdecayattrib);
                break;
            case 60:
                coerceValue(value, myLengthfalloffdecaytexture);
                break;
            case 61:
                coerceValue(value, myLengthrangemin);
                break;
            case 62:
                coerceValue(value, myLengthrangemax);
                break;
            case 63:
                coerceValue(value, myLengthpresets);
                break;
            case 64:
                coerceValue(value, myLengthramp);
                break;
            case 65:
                coerceValue(value, myUseskincurvmask);
                break;
            case 66:
                coerceValue(value, mySkincurvconcavemax);
                break;
            case 67:
                coerceValue(value, mySkincurvconvexmax);
                break;
            case 68:
                coerceValue(value, mySkincurvesmoothstrength);
                break;
            case 69:
                coerceValue(value, mySkincurvpresets);
                break;
            case 70:
                coerceValue(value, mySkincurvramp);
                break;
            case 71:
                coerceValue(value, myUsegeomask);
                break;
            case 72:
                coerceValue(value, myGeovoxelsize);
                break;
            case 73:
                coerceValue(value, myGeointrange);
                break;
            case 74:
                coerceValue(value, myGeoextrange);
                break;
            case 75:
                coerceValue(value, myGeodepthramppresets);
                break;
            case 76:
                coerceValue(value, myGeodepthramp);
                break;
            case 77:
                coerceValue(value, myGeodoblur);
                break;
            case 78:
                coerceValue(value, myGeoblurradius);
                break;
            case 79:
                coerceValue(value, myGeobluriters);
                break;
            case 80:
                coerceValue(value, myUserandommask);
                break;
            case 81:
                coerceValue(value, myRandommaskcombine);
                break;
            case 82:
                coerceValue(value, myRandommaskseed);
                break;
            case 83:
                coerceValue(value, myRandommaskfrac);
                break;
            case 84:
                coerceValue(value, myRandommaskvar);
                break;
            case 85:
                coerceValue(value, myRandommaskvargain);
                break;
            case 86:
                coerceValue(value, myUsecurvemask);
                break;
            case 87:
                coerceValue(value, myCurvemaskabsrange);
                break;
            case 88:
                coerceValue(value, myCurvemaskrangemin);
                break;
            case 89:
                coerceValue(value, myCurvemaskrangemax);
                break;
            case 90:
                coerceValue(value, myCurvemaskeffectpos);
                break;
            case 91:
                coerceValue(value, myCurvemaskfalloff);
                break;
            case 92:
                coerceValue(value, myCurvemaskwidth);
                break;
            case 93:
                coerceValue(value, myCurvemaskramp);
                break;
            case 94:
                coerceValue(value, myUseskinlookupattribs);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myUvattrib, value);
                break;
            case 1:
                coerceValue(myGrouptype, value);
                break;
            case 2:
                coerceValue(myGroup, value);
                break;
            case 3:
                coerceValue(myZeroungrouped, value);
                break;
            case 4:
                coerceValue(myInputmask, value);
                break;
            case 5:
                coerceValue(myInputmaskoverride, value);
                break;
            case 6:
                coerceValue(myInputmaskcurveattrib, value);
                break;
            case 7:
                coerceValue(myInputmaskattrib, value);
                break;
            case 8:
                coerceValue(myInputmasktexture, value);
                break;
            case 9:
                coerceValue(myVismasks, value);
                break;
            case 10:
                coerceValue(myOutattribtype, value);
                break;
            case 11:
                coerceValue(myOutattrib, value);
                break;
            case 12:
                coerceValue(myCreateprimgroup, value);
                break;
            case 13:
                coerceValue(myOutprimgroup, value);
                break;
            case 14:
                coerceValue(myCreateintattrib, value);
                break;
            case 15:
                coerceValue(myIntattrib, value);
                break;
            case 16:
                coerceValue(myIntattribvalue, value);
                break;
            case 17:
                coerceValue(myIntattribthresh, value);
                break;
            case 18:
                coerceValue(myUsenoisemask, value);
                break;
            case 19:
                coerceValue(myNoisemaskamount, value);
                break;
            case 20:
                coerceValue(myNoisemaskamountoverride, value);
                break;
            case 21:
                coerceValue(myNoisemaskamountcurveattrib, value);
                break;
            case 22:
                coerceValue(myNoisemaskamountattrib, value);
                break;
            case 23:
                coerceValue(myNoisemaskamounttexture, value);
                break;
            case 24:
                coerceValue(myNoisemaskfreq, value);
                break;
            case 25:
                coerceValue(myNoisemaskgain, value);
                break;
            case 26:
                coerceValue(myNoisemaskgainoverride, value);
                break;
            case 27:
                coerceValue(myNoisemaskgaincurveattrib, value);
                break;
            case 28:
                coerceValue(myNoisemaskgainattrib, value);
                break;
            case 29:
                coerceValue(myNoisemaskgaintexture, value);
                break;
            case 30:
                coerceValue(myNoisemaskbias, value);
                break;
            case 31:
                coerceValue(myNoisemaskbiasoverride, value);
                break;
            case 32:
                coerceValue(myNoisemaskbiascurveattrib, value);
                break;
            case 33:
                coerceValue(myNoisemaskbiasattrib, value);
                break;
            case 34:
                coerceValue(myNoisemaskbiastexture, value);
                break;
            case 35:
                coerceValue(myNoisemaskcenterone, value);
                break;
            case 36:
                coerceValue(myNoisemaskfractal, value);
                break;
            case 37:
                coerceValue(myNoisemaskoct, value);
                break;
            case 38:
                coerceValue(myNoisemasklac, value);
                break;
            case 39:
                coerceValue(myNoisemaskrough, value);
                break;
            case 40:
                coerceValue(myNoisemaskroughoverride, value);
                break;
            case 41:
                coerceValue(myNoisemaskroughcurveattrib, value);
                break;
            case 42:
                coerceValue(myNoisemaskroughattrib, value);
                break;
            case 43:
                coerceValue(myNoisemaskroughtexture, value);
                break;
            case 44:
                coerceValue(myUselengthmask, value);
                break;
            case 45:
                coerceValue(myLengthmode, value);
                break;
            case 46:
                coerceValue(myLengthref, value);
                break;
            case 47:
                coerceValue(myLengthrefoverride, value);
                break;
            case 48:
                coerceValue(myLengthrefcurveattrib, value);
                break;
            case 49:
                coerceValue(myLengthrefattrib, value);
                break;
            case 50:
                coerceValue(myLengthreftexture, value);
                break;
            case 51:
                coerceValue(myLengthfalloffrange, value);
                break;
            case 52:
                coerceValue(myLengthfalloffrangeoverride, value);
                break;
            case 53:
                coerceValue(myLengthfalloffrangecurveattrib, value);
                break;
            case 54:
                coerceValue(myLengthfalloffrangeattrib, value);
                break;
            case 55:
                coerceValue(myLengthfalloffrangetexture, value);
                break;
            case 56:
                coerceValue(myLengthfalloffdecay, value);
                break;
            case 57:
                coerceValue(myLengthfalloffdecayoverride, value);
                break;
            case 58:
                coerceValue(myLengthfalloffdecaycurveattrib, value);
                break;
            case 59:
                coerceValue(myLengthfalloffdecayattrib, value);
                break;
            case 60:
                coerceValue(myLengthfalloffdecaytexture, value);
                break;
            case 61:
                coerceValue(myLengthrangemin, value);
                break;
            case 62:
                coerceValue(myLengthrangemax, value);
                break;
            case 63:
                coerceValue(myLengthpresets, value);
                break;
            case 64:
                coerceValue(myLengthramp, value);
                break;
            case 65:
                coerceValue(myUseskincurvmask, value);
                break;
            case 66:
                coerceValue(mySkincurvconcavemax, value);
                break;
            case 67:
                coerceValue(mySkincurvconvexmax, value);
                break;
            case 68:
                coerceValue(mySkincurvesmoothstrength, value);
                break;
            case 69:
                coerceValue(mySkincurvpresets, value);
                break;
            case 70:
                coerceValue(mySkincurvramp, value);
                break;
            case 71:
                coerceValue(myUsegeomask, value);
                break;
            case 72:
                coerceValue(myGeovoxelsize, value);
                break;
            case 73:
                coerceValue(myGeointrange, value);
                break;
            case 74:
                coerceValue(myGeoextrange, value);
                break;
            case 75:
                coerceValue(myGeodepthramppresets, value);
                break;
            case 76:
                coerceValue(myGeodepthramp, value);
                break;
            case 77:
                coerceValue(myGeodoblur, value);
                break;
            case 78:
                coerceValue(myGeoblurradius, value);
                break;
            case 79:
                coerceValue(myGeobluriters, value);
                break;
            case 80:
                coerceValue(myUserandommask, value);
                break;
            case 81:
                coerceValue(myRandommaskcombine, value);
                break;
            case 82:
                coerceValue(myRandommaskseed, value);
                break;
            case 83:
                coerceValue(myRandommaskfrac, value);
                break;
            case 84:
                coerceValue(myRandommaskvar, value);
                break;
            case 85:
                coerceValue(myRandommaskvargain, value);
                break;
            case 86:
                coerceValue(myUsecurvemask, value);
                break;
            case 87:
                coerceValue(myCurvemaskabsrange, value);
                break;
            case 88:
                coerceValue(myCurvemaskrangemin, value);
                break;
            case 89:
                coerceValue(myCurvemaskrangemax, value);
                break;
            case 90:
                coerceValue(myCurvemaskeffectpos, value);
                break;
            case 91:
                coerceValue(myCurvemaskfalloff, value);
                break;
            case 92:
                coerceValue(myCurvemaskwidth, value);
                break;
            case 93:
                coerceValue(myCurvemaskramp, value);
                break;
            case 94:
                coerceValue(myUseskinlookupattribs, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 95;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "uvattrib";
            case 1:
                return "grouptype";
            case 2:
                return "group";
            case 3:
                return "zeroungrouped";
            case 4:
                return "inputmask";
            case 5:
                return "inputmaskoverride";
            case 6:
                return "inputmaskcurveattrib";
            case 7:
                return "inputmaskattrib";
            case 8:
                return "inputmasktexture";
            case 9:
                return "vismasks";
            case 10:
                return "outattribtype";
            case 11:
                return "outattrib";
            case 12:
                return "createprimgroup";
            case 13:
                return "outprimgroup";
            case 14:
                return "createintattrib";
            case 15:
                return "intattrib";
            case 16:
                return "intattribvalue";
            case 17:
                return "intattribthresh";
            case 18:
                return "usenoisemask";
            case 19:
                return "noisemaskamount";
            case 20:
                return "noisemaskamountoverride";
            case 21:
                return "noisemaskamountcurveattrib";
            case 22:
                return "noisemaskamountattrib";
            case 23:
                return "noisemaskamounttexture";
            case 24:
                return "noisemaskfreq";
            case 25:
                return "noisemaskgain";
            case 26:
                return "noisemaskgainoverride";
            case 27:
                return "noisemaskgaincurveattrib";
            case 28:
                return "noisemaskgainattrib";
            case 29:
                return "noisemaskgaintexture";
            case 30:
                return "noisemaskbias";
            case 31:
                return "noisemaskbiasoverride";
            case 32:
                return "noisemaskbiascurveattrib";
            case 33:
                return "noisemaskbiasattrib";
            case 34:
                return "noisemaskbiastexture";
            case 35:
                return "noisemaskcenterone";
            case 36:
                return "noisemaskfractal";
            case 37:
                return "noisemaskoct";
            case 38:
                return "noisemasklac";
            case 39:
                return "noisemaskrough";
            case 40:
                return "noisemaskroughoverride";
            case 41:
                return "noisemaskroughcurveattrib";
            case 42:
                return "noisemaskroughattrib";
            case 43:
                return "noisemaskroughtexture";
            case 44:
                return "uselengthmask";
            case 45:
                return "lengthmode";
            case 46:
                return "lengthref";
            case 47:
                return "lengthrefoverride";
            case 48:
                return "lengthrefcurveattrib";
            case 49:
                return "lengthrefattrib";
            case 50:
                return "lengthreftexture";
            case 51:
                return "lengthfalloffrange";
            case 52:
                return "lengthfalloffrangeoverride";
            case 53:
                return "lengthfalloffrangecurveattrib";
            case 54:
                return "lengthfalloffrangeattrib";
            case 55:
                return "lengthfalloffrangetexture";
            case 56:
                return "lengthfalloffdecay";
            case 57:
                return "lengthfalloffdecayoverride";
            case 58:
                return "lengthfalloffdecaycurveattrib";
            case 59:
                return "lengthfalloffdecayattrib";
            case 60:
                return "lengthfalloffdecaytexture";
            case 61:
                return "lengthrangemin";
            case 62:
                return "lengthrangemax";
            case 63:
                return "lengthpresets";
            case 64:
                return "lengthramp";
            case 65:
                return "useskincurvmask";
            case 66:
                return "skincurvconcavemax";
            case 67:
                return "skincurvconvexmax";
            case 68:
                return "skincurvesmoothstrength";
            case 69:
                return "skincurvpresets";
            case 70:
                return "skincurvramp";
            case 71:
                return "usegeomask";
            case 72:
                return "geovoxelsize";
            case 73:
                return "geointrange";
            case 74:
                return "geoextrange";
            case 75:
                return "geodepthramppresets";
            case 76:
                return "geodepthramp";
            case 77:
                return "geodoblur";
            case 78:
                return "geoblurradius";
            case 79:
                return "geobluriters";
            case 80:
                return "userandommask";
            case 81:
                return "randommaskcombine";
            case 82:
                return "randommaskseed";
            case 83:
                return "randommaskfrac";
            case 84:
                return "randommaskvar";
            case 85:
                return "randommaskvargain";
            case 86:
                return "usecurvemask";
            case 87:
                return "curvemaskabsrange";
            case 88:
                return "curvemaskrangemin";
            case 89:
                return "curvemaskrangemax";
            case 90:
                return "curvemaskeffectpos";
            case 91:
                return "curvemaskfalloff";
            case 92:
                return "curvemaskwidth";
            case 93:
                return "curvemaskramp";
            case 94:
                return "useskinlookupattribs";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_STRING;
                case 3:
                    return PARM_INTEGER;
                case 4:
                    return PARM_FLOAT;
                case 5:
                    return PARM_INTEGER;
                case 6:
                    return PARM_STRING;
                case 7:
                    return PARM_STRING;
                case 8:
                    return PARM_STRING;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_INTEGER;
                case 11:
                    return PARM_STRING;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_STRING;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_STRING;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_FLOAT;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_FLOAT;
                case 20:
                    return PARM_INTEGER;
                case 21:
                    return PARM_STRING;
                case 22:
                    return PARM_STRING;
                case 23:
                    return PARM_STRING;
                case 24:
                    return PARM_FLOAT;
                case 25:
                    return PARM_FLOAT;
                case 26:
                    return PARM_INTEGER;
                case 27:
                    return PARM_STRING;
                case 28:
                    return PARM_STRING;
                case 29:
                    return PARM_STRING;
                case 30:
                    return PARM_FLOAT;
                case 31:
                    return PARM_INTEGER;
                case 32:
                    return PARM_STRING;
                case 33:
                    return PARM_STRING;
                case 34:
                    return PARM_STRING;
                case 35:
                    return PARM_INTEGER;
                case 36:
                    return PARM_INTEGER;
                case 37:
                    return PARM_FLOAT;
                case 38:
                    return PARM_FLOAT;
                case 39:
                    return PARM_FLOAT;
                case 40:
                    return PARM_INTEGER;
                case 41:
                    return PARM_STRING;
                case 42:
                    return PARM_STRING;
                case 43:
                    return PARM_STRING;
                case 44:
                    return PARM_INTEGER;
                case 45:
                    return PARM_INTEGER;
                case 46:
                    return PARM_FLOAT;
                case 47:
                    return PARM_INTEGER;
                case 48:
                    return PARM_STRING;
                case 49:
                    return PARM_STRING;
                case 50:
                    return PARM_STRING;
                case 51:
                    return PARM_FLOAT;
                case 52:
                    return PARM_INTEGER;
                case 53:
                    return PARM_STRING;
                case 54:
                    return PARM_STRING;
                case 55:
                    return PARM_STRING;
                case 56:
                    return PARM_FLOAT;
                case 57:
                    return PARM_INTEGER;
                case 58:
                    return PARM_STRING;
                case 59:
                    return PARM_STRING;
                case 60:
                    return PARM_STRING;
                case 61:
                    return PARM_FLOAT;
                case 62:
                    return PARM_FLOAT;
                case 63:
                    return PARM_INTEGER;
                case 64:
                    return PARM_RAMP;
                case 65:
                    return PARM_INTEGER;
                case 66:
                    return PARM_FLOAT;
                case 67:
                    return PARM_FLOAT;
                case 68:
                    return PARM_FLOAT;
                case 69:
                    return PARM_INTEGER;
                case 70:
                    return PARM_RAMP;
                case 71:
                    return PARM_INTEGER;
                case 72:
                    return PARM_FLOAT;
                case 73:
                    return PARM_FLOAT;
                case 74:
                    return PARM_FLOAT;
                case 75:
                    return PARM_INTEGER;
                case 76:
                    return PARM_RAMP;
                case 77:
                    return PARM_INTEGER;
                case 78:
                    return PARM_FLOAT;
                case 79:
                    return PARM_INTEGER;
                case 80:
                    return PARM_INTEGER;
                case 81:
                    return PARM_INTEGER;
                case 82:
                    return PARM_FLOAT;
                case 83:
                    return PARM_FLOAT;
                case 84:
                    return PARM_FLOAT;
                case 85:
                    return PARM_FLOAT;
                case 86:
                    return PARM_INTEGER;
                case 87:
                    return PARM_INTEGER;
                case 88:
                    return PARM_FLOAT;
                case 89:
                    return PARM_FLOAT;
                case 90:
                    return PARM_FLOAT;
                case 91:
                    return PARM_FLOAT;
                case 92:
                    return PARM_FLOAT;
                case 93:
                    return PARM_RAMP;
                case 94:
                    return PARM_INTEGER;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myUvattrib);
        saveData(os, myGrouptype);
        saveData(os, myGroup);
        saveData(os, myZeroungrouped);
        saveData(os, myInputmask);
        saveData(os, myInputmaskoverride);
        saveData(os, myInputmaskcurveattrib);
        saveData(os, myInputmaskattrib);
        saveData(os, myInputmasktexture);
        saveData(os, myVismasks);
        saveData(os, myOutattribtype);
        saveData(os, myOutattrib);
        saveData(os, myCreateprimgroup);
        saveData(os, myOutprimgroup);
        saveData(os, myCreateintattrib);
        saveData(os, myIntattrib);
        saveData(os, myIntattribvalue);
        saveData(os, myIntattribthresh);
        saveData(os, myUsenoisemask);
        saveData(os, myNoisemaskamount);
        saveData(os, myNoisemaskamountoverride);
        saveData(os, myNoisemaskamountcurveattrib);
        saveData(os, myNoisemaskamountattrib);
        saveData(os, myNoisemaskamounttexture);
        saveData(os, myNoisemaskfreq);
        saveData(os, myNoisemaskgain);
        saveData(os, myNoisemaskgainoverride);
        saveData(os, myNoisemaskgaincurveattrib);
        saveData(os, myNoisemaskgainattrib);
        saveData(os, myNoisemaskgaintexture);
        saveData(os, myNoisemaskbias);
        saveData(os, myNoisemaskbiasoverride);
        saveData(os, myNoisemaskbiascurveattrib);
        saveData(os, myNoisemaskbiasattrib);
        saveData(os, myNoisemaskbiastexture);
        saveData(os, myNoisemaskcenterone);
        saveData(os, myNoisemaskfractal);
        saveData(os, myNoisemaskoct);
        saveData(os, myNoisemasklac);
        saveData(os, myNoisemaskrough);
        saveData(os, myNoisemaskroughoverride);
        saveData(os, myNoisemaskroughcurveattrib);
        saveData(os, myNoisemaskroughattrib);
        saveData(os, myNoisemaskroughtexture);
        saveData(os, myUselengthmask);
        saveData(os, myLengthmode);
        saveData(os, myLengthref);
        saveData(os, myLengthrefoverride);
        saveData(os, myLengthrefcurveattrib);
        saveData(os, myLengthrefattrib);
        saveData(os, myLengthreftexture);
        saveData(os, myLengthfalloffrange);
        saveData(os, myLengthfalloffrangeoverride);
        saveData(os, myLengthfalloffrangecurveattrib);
        saveData(os, myLengthfalloffrangeattrib);
        saveData(os, myLengthfalloffrangetexture);
        saveData(os, myLengthfalloffdecay);
        saveData(os, myLengthfalloffdecayoverride);
        saveData(os, myLengthfalloffdecaycurveattrib);
        saveData(os, myLengthfalloffdecayattrib);
        saveData(os, myLengthfalloffdecaytexture);
        saveData(os, myLengthrangemin);
        saveData(os, myLengthrangemax);
        saveData(os, myLengthpresets);
        saveData(os, myLengthramp);
        saveData(os, myUseskincurvmask);
        saveData(os, mySkincurvconcavemax);
        saveData(os, mySkincurvconvexmax);
        saveData(os, mySkincurvesmoothstrength);
        saveData(os, mySkincurvpresets);
        saveData(os, mySkincurvramp);
        saveData(os, myUsegeomask);
        saveData(os, myGeovoxelsize);
        saveData(os, myGeointrange);
        saveData(os, myGeoextrange);
        saveData(os, myGeodepthramppresets);
        saveData(os, myGeodepthramp);
        saveData(os, myGeodoblur);
        saveData(os, myGeoblurradius);
        saveData(os, myGeobluriters);
        saveData(os, myUserandommask);
        saveData(os, myRandommaskcombine);
        saveData(os, myRandommaskseed);
        saveData(os, myRandommaskfrac);
        saveData(os, myRandommaskvar);
        saveData(os, myRandommaskvargain);
        saveData(os, myUsecurvemask);
        saveData(os, myCurvemaskabsrange);
        saveData(os, myCurvemaskrangemin);
        saveData(os, myCurvemaskrangemax);
        saveData(os, myCurvemaskeffectpos);
        saveData(os, myCurvemaskfalloff);
        saveData(os, myCurvemaskwidth);
        saveData(os, myCurvemaskramp);
        saveData(os, myUseskinlookupattribs);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myUvattrib);
        loadData(is, myGrouptype);
        loadData(is, myGroup);
        loadData(is, myZeroungrouped);
        loadData(is, myInputmask);
        loadData(is, myInputmaskoverride);
        loadData(is, myInputmaskcurveattrib);
        loadData(is, myInputmaskattrib);
        loadData(is, myInputmasktexture);
        loadData(is, myVismasks);
        loadData(is, myOutattribtype);
        loadData(is, myOutattrib);
        loadData(is, myCreateprimgroup);
        loadData(is, myOutprimgroup);
        loadData(is, myCreateintattrib);
        loadData(is, myIntattrib);
        loadData(is, myIntattribvalue);
        loadData(is, myIntattribthresh);
        loadData(is, myUsenoisemask);
        loadData(is, myNoisemaskamount);
        loadData(is, myNoisemaskamountoverride);
        loadData(is, myNoisemaskamountcurveattrib);
        loadData(is, myNoisemaskamountattrib);
        loadData(is, myNoisemaskamounttexture);
        loadData(is, myNoisemaskfreq);
        loadData(is, myNoisemaskgain);
        loadData(is, myNoisemaskgainoverride);
        loadData(is, myNoisemaskgaincurveattrib);
        loadData(is, myNoisemaskgainattrib);
        loadData(is, myNoisemaskgaintexture);
        loadData(is, myNoisemaskbias);
        loadData(is, myNoisemaskbiasoverride);
        loadData(is, myNoisemaskbiascurveattrib);
        loadData(is, myNoisemaskbiasattrib);
        loadData(is, myNoisemaskbiastexture);
        loadData(is, myNoisemaskcenterone);
        loadData(is, myNoisemaskfractal);
        loadData(is, myNoisemaskoct);
        loadData(is, myNoisemasklac);
        loadData(is, myNoisemaskrough);
        loadData(is, myNoisemaskroughoverride);
        loadData(is, myNoisemaskroughcurveattrib);
        loadData(is, myNoisemaskroughattrib);
        loadData(is, myNoisemaskroughtexture);
        loadData(is, myUselengthmask);
        loadData(is, myLengthmode);
        loadData(is, myLengthref);
        loadData(is, myLengthrefoverride);
        loadData(is, myLengthrefcurveattrib);
        loadData(is, myLengthrefattrib);
        loadData(is, myLengthreftexture);
        loadData(is, myLengthfalloffrange);
        loadData(is, myLengthfalloffrangeoverride);
        loadData(is, myLengthfalloffrangecurveattrib);
        loadData(is, myLengthfalloffrangeattrib);
        loadData(is, myLengthfalloffrangetexture);
        loadData(is, myLengthfalloffdecay);
        loadData(is, myLengthfalloffdecayoverride);
        loadData(is, myLengthfalloffdecaycurveattrib);
        loadData(is, myLengthfalloffdecayattrib);
        loadData(is, myLengthfalloffdecaytexture);
        loadData(is, myLengthrangemin);
        loadData(is, myLengthrangemax);
        loadData(is, myLengthpresets);
        loadData(is, myLengthramp);
        loadData(is, myUseskincurvmask);
        loadData(is, mySkincurvconcavemax);
        loadData(is, mySkincurvconvexmax);
        loadData(is, mySkincurvesmoothstrength);
        loadData(is, mySkincurvpresets);
        loadData(is, mySkincurvramp);
        loadData(is, myUsegeomask);
        loadData(is, myGeovoxelsize);
        loadData(is, myGeointrange);
        loadData(is, myGeoextrange);
        loadData(is, myGeodepthramppresets);
        loadData(is, myGeodepthramp);
        loadData(is, myGeodoblur);
        loadData(is, myGeoblurradius);
        loadData(is, myGeobluriters);
        loadData(is, myUserandommask);
        loadData(is, myRandommaskcombine);
        loadData(is, myRandommaskseed);
        loadData(is, myRandommaskfrac);
        loadData(is, myRandommaskvar);
        loadData(is, myRandommaskvargain);
        loadData(is, myUsecurvemask);
        loadData(is, myCurvemaskabsrange);
        loadData(is, myCurvemaskrangemin);
        loadData(is, myCurvemaskrangemax);
        loadData(is, myCurvemaskeffectpos);
        loadData(is, myCurvemaskfalloff);
        loadData(is, myCurvemaskwidth);
        loadData(is, myCurvemaskramp);
        loadData(is, myUseskinlookupattribs);

        return true;
    }

    const UT_StringHolder & getUvattrib() const { return myUvattrib; }
    void setUvattrib(const UT_StringHolder & val) { myUvattrib = val; }
    UT_StringHolder opUvattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUvattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "uvattrib", cookparms.getCookTime(), 0);
        return result;
    }
    Grouptype getGrouptype() const { return Grouptype(myGrouptype); }
    void setGrouptype(Grouptype val) { myGrouptype = int64(val); }
    Grouptype opGrouptype(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGrouptype();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "grouptype", cookparms.getCookTime(), 0);
        return Grouptype(result);
    }
    const UT_StringHolder & getGroup() const { return myGroup; }
    void setGroup(const UT_StringHolder & val) { myGroup = val; }
    UT_StringHolder opGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "group", cookparms.getCookTime(), 0);
        return result;
    }
    bool getZeroungrouped() const { return myZeroungrouped; }
    void setZeroungrouped(bool val) { myZeroungrouped = val; }
    bool opZeroungrouped(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getZeroungrouped();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "zeroungrouped", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getInputmask() const { return myInputmask; }
    void setInputmask(fpreal64 val) { myInputmask = val; }
    fpreal64 opInputmask(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInputmask();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "inputmask", cookparms.getCookTime(), 0);
        return result;
    }
    Inputmaskoverride getInputmaskoverride() const { return Inputmaskoverride(myInputmaskoverride); }
    void setInputmaskoverride(Inputmaskoverride val) { myInputmaskoverride = int64(val); }
    Inputmaskoverride opInputmaskoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInputmaskoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "inputmaskoverride", cookparms.getCookTime(), 0);
        return Inputmaskoverride(result);
    }
    const UT_StringHolder & getInputmaskcurveattrib() const { return myInputmaskcurveattrib; }
    void setInputmaskcurveattrib(const UT_StringHolder & val) { myInputmaskcurveattrib = val; }
    UT_StringHolder opInputmaskcurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInputmaskcurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "inputmaskcurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getInputmaskattrib() const { return myInputmaskattrib; }
    void setInputmaskattrib(const UT_StringHolder & val) { myInputmaskattrib = val; }
    UT_StringHolder opInputmaskattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInputmaskattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "inputmaskattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getInputmasktexture() const { return myInputmasktexture; }
    void setInputmasktexture(const UT_StringHolder & val) { myInputmasktexture = val; }
    UT_StringHolder opInputmasktexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInputmasktexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "inputmasktexture", cookparms.getCookTime(), 0);
        return result;
    }
    bool getVismasks() const { return myVismasks; }
    void setVismasks(bool val) { myVismasks = val; }
    bool opVismasks(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVismasks();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "vismasks", cookparms.getCookTime(), 0);
        return result;
    }
    Outattribtype getOutattribtype() const { return Outattribtype(myOutattribtype); }
    void setOutattribtype(Outattribtype val) { myOutattribtype = int64(val); }
    Outattribtype opOutattribtype(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutattribtype();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "outattribtype", cookparms.getCookTime(), 0);
        return Outattribtype(result);
    }
    const UT_StringHolder & getOutattrib() const { return myOutattrib; }
    void setOutattrib(const UT_StringHolder & val) { myOutattrib = val; }
    UT_StringHolder opOutattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "outattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCreateprimgroup() const { return myCreateprimgroup; }
    void setCreateprimgroup(bool val) { myCreateprimgroup = val; }
    bool opCreateprimgroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCreateprimgroup();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "createprimgroup", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getOutprimgroup() const { return myOutprimgroup; }
    void setOutprimgroup(const UT_StringHolder & val) { myOutprimgroup = val; }
    UT_StringHolder opOutprimgroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutprimgroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "outprimgroup", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCreateintattrib() const { return myCreateintattrib; }
    void setCreateintattrib(bool val) { myCreateintattrib = val; }
    bool opCreateintattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCreateintattrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "createintattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getIntattrib() const { return myIntattrib; }
    void setIntattrib(const UT_StringHolder & val) { myIntattrib = val; }
    UT_StringHolder opIntattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIntattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "intattrib", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getIntattribvalue() const { return myIntattribvalue; }
    void setIntattribvalue(int64 val) { myIntattribvalue = val; }
    int64 opIntattribvalue(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIntattribvalue();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "intattribvalue", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getIntattribthresh() const { return myIntattribthresh; }
    void setIntattribthresh(fpreal64 val) { myIntattribthresh = val; }
    fpreal64 opIntattribthresh(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIntattribthresh();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "intattribthresh", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUsenoisemask() const { return myUsenoisemask; }
    void setUsenoisemask(bool val) { myUsenoisemask = val; }
    bool opUsenoisemask(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUsenoisemask();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usenoisemask", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getNoisemaskamount() const { return myNoisemaskamount; }
    void setNoisemaskamount(fpreal64 val) { myNoisemaskamount = val; }
    fpreal64 opNoisemaskamount(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskamount();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskamount", cookparms.getCookTime(), 0);
        return result;
    }
    Noisemaskamountoverride getNoisemaskamountoverride() const { return Noisemaskamountoverride(myNoisemaskamountoverride); }
    void setNoisemaskamountoverride(Noisemaskamountoverride val) { myNoisemaskamountoverride = int64(val); }
    Noisemaskamountoverride opNoisemaskamountoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskamountoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskamountoverride", cookparms.getCookTime(), 0);
        return Noisemaskamountoverride(result);
    }
    const UT_StringHolder & getNoisemaskamountcurveattrib() const { return myNoisemaskamountcurveattrib; }
    void setNoisemaskamountcurveattrib(const UT_StringHolder & val) { myNoisemaskamountcurveattrib = val; }
    UT_StringHolder opNoisemaskamountcurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskamountcurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskamountcurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getNoisemaskamountattrib() const { return myNoisemaskamountattrib; }
    void setNoisemaskamountattrib(const UT_StringHolder & val) { myNoisemaskamountattrib = val; }
    UT_StringHolder opNoisemaskamountattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskamountattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskamountattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getNoisemaskamounttexture() const { return myNoisemaskamounttexture; }
    void setNoisemaskamounttexture(const UT_StringHolder & val) { myNoisemaskamounttexture = val; }
    UT_StringHolder opNoisemaskamounttexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskamounttexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskamounttexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getNoisemaskfreq() const { return myNoisemaskfreq; }
    void setNoisemaskfreq(fpreal64 val) { myNoisemaskfreq = val; }
    fpreal64 opNoisemaskfreq(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskfreq();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskfreq", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getNoisemaskgain() const { return myNoisemaskgain; }
    void setNoisemaskgain(fpreal64 val) { myNoisemaskgain = val; }
    fpreal64 opNoisemaskgain(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskgain();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskgain", cookparms.getCookTime(), 0);
        return result;
    }
    Noisemaskgainoverride getNoisemaskgainoverride() const { return Noisemaskgainoverride(myNoisemaskgainoverride); }
    void setNoisemaskgainoverride(Noisemaskgainoverride val) { myNoisemaskgainoverride = int64(val); }
    Noisemaskgainoverride opNoisemaskgainoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskgainoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskgainoverride", cookparms.getCookTime(), 0);
        return Noisemaskgainoverride(result);
    }
    const UT_StringHolder & getNoisemaskgaincurveattrib() const { return myNoisemaskgaincurveattrib; }
    void setNoisemaskgaincurveattrib(const UT_StringHolder & val) { myNoisemaskgaincurveattrib = val; }
    UT_StringHolder opNoisemaskgaincurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskgaincurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskgaincurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getNoisemaskgainattrib() const { return myNoisemaskgainattrib; }
    void setNoisemaskgainattrib(const UT_StringHolder & val) { myNoisemaskgainattrib = val; }
    UT_StringHolder opNoisemaskgainattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskgainattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskgainattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getNoisemaskgaintexture() const { return myNoisemaskgaintexture; }
    void setNoisemaskgaintexture(const UT_StringHolder & val) { myNoisemaskgaintexture = val; }
    UT_StringHolder opNoisemaskgaintexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskgaintexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskgaintexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getNoisemaskbias() const { return myNoisemaskbias; }
    void setNoisemaskbias(fpreal64 val) { myNoisemaskbias = val; }
    fpreal64 opNoisemaskbias(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskbias();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskbias", cookparms.getCookTime(), 0);
        return result;
    }
    Noisemaskbiasoverride getNoisemaskbiasoverride() const { return Noisemaskbiasoverride(myNoisemaskbiasoverride); }
    void setNoisemaskbiasoverride(Noisemaskbiasoverride val) { myNoisemaskbiasoverride = int64(val); }
    Noisemaskbiasoverride opNoisemaskbiasoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskbiasoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskbiasoverride", cookparms.getCookTime(), 0);
        return Noisemaskbiasoverride(result);
    }
    const UT_StringHolder & getNoisemaskbiascurveattrib() const { return myNoisemaskbiascurveattrib; }
    void setNoisemaskbiascurveattrib(const UT_StringHolder & val) { myNoisemaskbiascurveattrib = val; }
    UT_StringHolder opNoisemaskbiascurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskbiascurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskbiascurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getNoisemaskbiasattrib() const { return myNoisemaskbiasattrib; }
    void setNoisemaskbiasattrib(const UT_StringHolder & val) { myNoisemaskbiasattrib = val; }
    UT_StringHolder opNoisemaskbiasattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskbiasattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskbiasattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getNoisemaskbiastexture() const { return myNoisemaskbiastexture; }
    void setNoisemaskbiastexture(const UT_StringHolder & val) { myNoisemaskbiastexture = val; }
    UT_StringHolder opNoisemaskbiastexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskbiastexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskbiastexture", cookparms.getCookTime(), 0);
        return result;
    }
    bool getNoisemaskcenterone() const { return myNoisemaskcenterone; }
    void setNoisemaskcenterone(bool val) { myNoisemaskcenterone = val; }
    bool opNoisemaskcenterone(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskcenterone();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskcenterone", cookparms.getCookTime(), 0);
        return result;
    }
    bool getNoisemaskfractal() const { return myNoisemaskfractal; }
    void setNoisemaskfractal(bool val) { myNoisemaskfractal = val; }
    bool opNoisemaskfractal(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskfractal();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskfractal", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getNoisemaskoct() const { return myNoisemaskoct; }
    void setNoisemaskoct(fpreal64 val) { myNoisemaskoct = val; }
    fpreal64 opNoisemaskoct(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskoct();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskoct", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getNoisemasklac() const { return myNoisemasklac; }
    void setNoisemasklac(fpreal64 val) { myNoisemasklac = val; }
    fpreal64 opNoisemasklac(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemasklac();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemasklac", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getNoisemaskrough() const { return myNoisemaskrough; }
    void setNoisemaskrough(fpreal64 val) { myNoisemaskrough = val; }
    fpreal64 opNoisemaskrough(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskrough();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskrough", cookparms.getCookTime(), 0);
        return result;
    }
    Noisemaskroughoverride getNoisemaskroughoverride() const { return Noisemaskroughoverride(myNoisemaskroughoverride); }
    void setNoisemaskroughoverride(Noisemaskroughoverride val) { myNoisemaskroughoverride = int64(val); }
    Noisemaskroughoverride opNoisemaskroughoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskroughoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskroughoverride", cookparms.getCookTime(), 0);
        return Noisemaskroughoverride(result);
    }
    const UT_StringHolder & getNoisemaskroughcurveattrib() const { return myNoisemaskroughcurveattrib; }
    void setNoisemaskroughcurveattrib(const UT_StringHolder & val) { myNoisemaskroughcurveattrib = val; }
    UT_StringHolder opNoisemaskroughcurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskroughcurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskroughcurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getNoisemaskroughattrib() const { return myNoisemaskroughattrib; }
    void setNoisemaskroughattrib(const UT_StringHolder & val) { myNoisemaskroughattrib = val; }
    UT_StringHolder opNoisemaskroughattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskroughattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskroughattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getNoisemaskroughtexture() const { return myNoisemaskroughtexture; }
    void setNoisemaskroughtexture(const UT_StringHolder & val) { myNoisemaskroughtexture = val; }
    UT_StringHolder opNoisemaskroughtexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoisemaskroughtexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "noisemaskroughtexture", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUselengthmask() const { return myUselengthmask; }
    void setUselengthmask(bool val) { myUselengthmask = val; }
    bool opUselengthmask(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUselengthmask();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "uselengthmask", cookparms.getCookTime(), 0);
        return result;
    }
    Lengthmode getLengthmode() const { return Lengthmode(myLengthmode); }
    void setLengthmode(Lengthmode val) { myLengthmode = int64(val); }
    Lengthmode opLengthmode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthmode();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthmode", cookparms.getCookTime(), 0);
        return Lengthmode(result);
    }
    fpreal64 getLengthref() const { return myLengthref; }
    void setLengthref(fpreal64 val) { myLengthref = val; }
    fpreal64 opLengthref(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthref();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthref", cookparms.getCookTime(), 0);
        return result;
    }
    Lengthrefoverride getLengthrefoverride() const { return Lengthrefoverride(myLengthrefoverride); }
    void setLengthrefoverride(Lengthrefoverride val) { myLengthrefoverride = int64(val); }
    Lengthrefoverride opLengthrefoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthrefoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthrefoverride", cookparms.getCookTime(), 0);
        return Lengthrefoverride(result);
    }
    const UT_StringHolder & getLengthrefcurveattrib() const { return myLengthrefcurveattrib; }
    void setLengthrefcurveattrib(const UT_StringHolder & val) { myLengthrefcurveattrib = val; }
    UT_StringHolder opLengthrefcurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthrefcurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lengthrefcurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLengthrefattrib() const { return myLengthrefattrib; }
    void setLengthrefattrib(const UT_StringHolder & val) { myLengthrefattrib = val; }
    UT_StringHolder opLengthrefattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthrefattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lengthrefattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLengthreftexture() const { return myLengthreftexture; }
    void setLengthreftexture(const UT_StringHolder & val) { myLengthreftexture = val; }
    UT_StringHolder opLengthreftexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthreftexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lengthreftexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getLengthfalloffrange() const { return myLengthfalloffrange; }
    void setLengthfalloffrange(fpreal64 val) { myLengthfalloffrange = val; }
    fpreal64 opLengthfalloffrange(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffrange();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffrange", cookparms.getCookTime(), 0);
        return result;
    }
    Lengthfalloffrangeoverride getLengthfalloffrangeoverride() const { return Lengthfalloffrangeoverride(myLengthfalloffrangeoverride); }
    void setLengthfalloffrangeoverride(Lengthfalloffrangeoverride val) { myLengthfalloffrangeoverride = int64(val); }
    Lengthfalloffrangeoverride opLengthfalloffrangeoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffrangeoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffrangeoverride", cookparms.getCookTime(), 0);
        return Lengthfalloffrangeoverride(result);
    }
    const UT_StringHolder & getLengthfalloffrangecurveattrib() const { return myLengthfalloffrangecurveattrib; }
    void setLengthfalloffrangecurveattrib(const UT_StringHolder & val) { myLengthfalloffrangecurveattrib = val; }
    UT_StringHolder opLengthfalloffrangecurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffrangecurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffrangecurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLengthfalloffrangeattrib() const { return myLengthfalloffrangeattrib; }
    void setLengthfalloffrangeattrib(const UT_StringHolder & val) { myLengthfalloffrangeattrib = val; }
    UT_StringHolder opLengthfalloffrangeattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffrangeattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffrangeattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLengthfalloffrangetexture() const { return myLengthfalloffrangetexture; }
    void setLengthfalloffrangetexture(const UT_StringHolder & val) { myLengthfalloffrangetexture = val; }
    UT_StringHolder opLengthfalloffrangetexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffrangetexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffrangetexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getLengthfalloffdecay() const { return myLengthfalloffdecay; }
    void setLengthfalloffdecay(fpreal64 val) { myLengthfalloffdecay = val; }
    fpreal64 opLengthfalloffdecay(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffdecay();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffdecay", cookparms.getCookTime(), 0);
        return result;
    }
    Lengthfalloffdecayoverride getLengthfalloffdecayoverride() const { return Lengthfalloffdecayoverride(myLengthfalloffdecayoverride); }
    void setLengthfalloffdecayoverride(Lengthfalloffdecayoverride val) { myLengthfalloffdecayoverride = int64(val); }
    Lengthfalloffdecayoverride opLengthfalloffdecayoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffdecayoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffdecayoverride", cookparms.getCookTime(), 0);
        return Lengthfalloffdecayoverride(result);
    }
    const UT_StringHolder & getLengthfalloffdecaycurveattrib() const { return myLengthfalloffdecaycurveattrib; }
    void setLengthfalloffdecaycurveattrib(const UT_StringHolder & val) { myLengthfalloffdecaycurveattrib = val; }
    UT_StringHolder opLengthfalloffdecaycurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffdecaycurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffdecaycurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLengthfalloffdecayattrib() const { return myLengthfalloffdecayattrib; }
    void setLengthfalloffdecayattrib(const UT_StringHolder & val) { myLengthfalloffdecayattrib = val; }
    UT_StringHolder opLengthfalloffdecayattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffdecayattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffdecayattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLengthfalloffdecaytexture() const { return myLengthfalloffdecaytexture; }
    void setLengthfalloffdecaytexture(const UT_StringHolder & val) { myLengthfalloffdecaytexture = val; }
    UT_StringHolder opLengthfalloffdecaytexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthfalloffdecaytexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lengthfalloffdecaytexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getLengthrangemin() const { return myLengthrangemin; }
    void setLengthrangemin(fpreal64 val) { myLengthrangemin = val; }
    fpreal64 opLengthrangemin(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthrangemin();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthrangemin", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getLengthrangemax() const { return myLengthrangemax; }
    void setLengthrangemax(fpreal64 val) { myLengthrangemax = val; }
    fpreal64 opLengthrangemax(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthrangemax();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthrangemax", cookparms.getCookTime(), 0);
        return result;
    }
    Lengthpresets getLengthpresets() const { return Lengthpresets(myLengthpresets); }
    void setLengthpresets(Lengthpresets val) { myLengthpresets = int64(val); }
    Lengthpresets opLengthpresets(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthpresets();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "lengthpresets", cookparms.getCookTime(), 0);
        return Lengthpresets(result);
    }
    UT_SharedPtr<UT_Ramp> getLengthramp() const { return myLengthramp; }
    void setLengthramp(UT_SharedPtr<UT_Ramp> val) { myLengthramp = val; }
    UT_SharedPtr<UT_Ramp> opLengthramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "lengthramp", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseskincurvmask() const { return myUseskincurvmask; }
    void setUseskincurvmask(bool val) { myUseskincurvmask = val; }
    bool opUseskincurvmask(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseskincurvmask();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useskincurvmask", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getSkincurvconcavemax() const { return mySkincurvconcavemax; }
    void setSkincurvconcavemax(fpreal64 val) { mySkincurvconcavemax = val; }
    fpreal64 opSkincurvconcavemax(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSkincurvconcavemax();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "skincurvconcavemax", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getSkincurvconvexmax() const { return mySkincurvconvexmax; }
    void setSkincurvconvexmax(fpreal64 val) { mySkincurvconvexmax = val; }
    fpreal64 opSkincurvconvexmax(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSkincurvconvexmax();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "skincurvconvexmax", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getSkincurvesmoothstrength() const { return mySkincurvesmoothstrength; }
    void setSkincurvesmoothstrength(fpreal64 val) { mySkincurvesmoothstrength = val; }
    fpreal64 opSkincurvesmoothstrength(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSkincurvesmoothstrength();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "skincurvesmoothstrength", cookparms.getCookTime(), 0);
        return result;
    }
    Skincurvpresets getSkincurvpresets() const { return Skincurvpresets(mySkincurvpresets); }
    void setSkincurvpresets(Skincurvpresets val) { mySkincurvpresets = int64(val); }
    Skincurvpresets opSkincurvpresets(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSkincurvpresets();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "skincurvpresets", cookparms.getCookTime(), 0);
        return Skincurvpresets(result);
    }
    UT_SharedPtr<UT_Ramp> getSkincurvramp() const { return mySkincurvramp; }
    void setSkincurvramp(UT_SharedPtr<UT_Ramp> val) { mySkincurvramp = val; }
    UT_SharedPtr<UT_Ramp> opSkincurvramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSkincurvramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "skincurvramp", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUsegeomask() const { return myUsegeomask; }
    void setUsegeomask(bool val) { myUsegeomask = val; }
    bool opUsegeomask(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUsegeomask();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usegeomask", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getGeovoxelsize() const { return myGeovoxelsize; }
    void setGeovoxelsize(fpreal64 val) { myGeovoxelsize = val; }
    fpreal64 opGeovoxelsize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGeovoxelsize();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "geovoxelsize", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getGeointrange() const { return myGeointrange; }
    void setGeointrange(fpreal64 val) { myGeointrange = val; }
    fpreal64 opGeointrange(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGeointrange();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "geointrange", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getGeoextrange() const { return myGeoextrange; }
    void setGeoextrange(fpreal64 val) { myGeoextrange = val; }
    fpreal64 opGeoextrange(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGeoextrange();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "geoextrange", cookparms.getCookTime(), 0);
        return result;
    }
    Geodepthramppresets getGeodepthramppresets() const { return Geodepthramppresets(myGeodepthramppresets); }
    void setGeodepthramppresets(Geodepthramppresets val) { myGeodepthramppresets = int64(val); }
    Geodepthramppresets opGeodepthramppresets(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGeodepthramppresets();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "geodepthramppresets", cookparms.getCookTime(), 0);
        return Geodepthramppresets(result);
    }
    UT_SharedPtr<UT_Ramp> getGeodepthramp() const { return myGeodepthramp; }
    void setGeodepthramp(UT_SharedPtr<UT_Ramp> val) { myGeodepthramp = val; }
    UT_SharedPtr<UT_Ramp> opGeodepthramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGeodepthramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "geodepthramp", cookparms.getCookTime(), 0);
        return result;
    }
    bool getGeodoblur() const { return myGeodoblur; }
    void setGeodoblur(bool val) { myGeodoblur = val; }
    bool opGeodoblur(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGeodoblur();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "geodoblur", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getGeoblurradius() const { return myGeoblurradius; }
    void setGeoblurradius(fpreal64 val) { myGeoblurradius = val; }
    fpreal64 opGeoblurradius(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGeoblurradius();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "geoblurradius", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getGeobluriters() const { return myGeobluriters; }
    void setGeobluriters(int64 val) { myGeobluriters = val; }
    int64 opGeobluriters(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGeobluriters();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "geobluriters", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUserandommask() const { return myUserandommask; }
    void setUserandommask(bool val) { myUserandommask = val; }
    bool opUserandommask(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUserandommask();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "userandommask", cookparms.getCookTime(), 0);
        return result;
    }
    Randommaskcombine getRandommaskcombine() const { return Randommaskcombine(myRandommaskcombine); }
    void setRandommaskcombine(Randommaskcombine val) { myRandommaskcombine = int64(val); }
    Randommaskcombine opRandommaskcombine(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandommaskcombine();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "randommaskcombine", cookparms.getCookTime(), 0);
        return Randommaskcombine(result);
    }
    fpreal64 getRandommaskseed() const { return myRandommaskseed; }
    void setRandommaskseed(fpreal64 val) { myRandommaskseed = val; }
    fpreal64 opRandommaskseed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandommaskseed();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "randommaskseed", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getRandommaskfrac() const { return myRandommaskfrac; }
    void setRandommaskfrac(fpreal64 val) { myRandommaskfrac = val; }
    fpreal64 opRandommaskfrac(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandommaskfrac();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "randommaskfrac", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getRandommaskvar() const { return myRandommaskvar; }
    void setRandommaskvar(fpreal64 val) { myRandommaskvar = val; }
    fpreal64 opRandommaskvar(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandommaskvar();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "randommaskvar", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getRandommaskvargain() const { return myRandommaskvargain; }
    void setRandommaskvargain(fpreal64 val) { myRandommaskvargain = val; }
    fpreal64 opRandommaskvargain(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandommaskvargain();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "randommaskvargain", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUsecurvemask() const { return myUsecurvemask; }
    void setUsecurvemask(bool val) { myUsecurvemask = val; }
    bool opUsecurvemask(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUsecurvemask();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usecurvemask", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCurvemaskabsrange() const { return myCurvemaskabsrange; }
    void setCurvemaskabsrange(bool val) { myCurvemaskabsrange = val; }
    bool opCurvemaskabsrange(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurvemaskabsrange();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "curvemaskabsrange", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getCurvemaskrangemin() const { return myCurvemaskrangemin; }
    void setCurvemaskrangemin(fpreal64 val) { myCurvemaskrangemin = val; }
    fpreal64 opCurvemaskrangemin(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurvemaskrangemin();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "curvemaskrangemin", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getCurvemaskrangemax() const { return myCurvemaskrangemax; }
    void setCurvemaskrangemax(fpreal64 val) { myCurvemaskrangemax = val; }
    fpreal64 opCurvemaskrangemax(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurvemaskrangemax();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "curvemaskrangemax", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getCurvemaskeffectpos() const { return myCurvemaskeffectpos; }
    void setCurvemaskeffectpos(fpreal64 val) { myCurvemaskeffectpos = val; }
    fpreal64 opCurvemaskeffectpos(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurvemaskeffectpos();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "curvemaskeffectpos", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getCurvemaskfalloff() const { return myCurvemaskfalloff; }
    void setCurvemaskfalloff(fpreal64 val) { myCurvemaskfalloff = val; }
    fpreal64 opCurvemaskfalloff(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurvemaskfalloff();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "curvemaskfalloff", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getCurvemaskwidth() const { return myCurvemaskwidth; }
    void setCurvemaskwidth(fpreal64 val) { myCurvemaskwidth = val; }
    fpreal64 opCurvemaskwidth(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurvemaskwidth();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "curvemaskwidth", cookparms.getCookTime(), 0);
        return result;
    }
    UT_SharedPtr<UT_Ramp> getCurvemaskramp() const { return myCurvemaskramp; }
    void setCurvemaskramp(UT_SharedPtr<UT_Ramp> val) { myCurvemaskramp = val; }
    UT_SharedPtr<UT_Ramp> opCurvemaskramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurvemaskramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "curvemaskramp", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseskinlookupattribs() const { return myUseskinlookupattribs; }
    void setUseskinlookupattribs(bool val) { myUseskinlookupattribs = val; }
    bool opUseskinlookupattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseskinlookupattribs();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useskinlookupattribs", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myUvattrib;
    int64 myGrouptype;
    UT_StringHolder myGroup;
    bool myZeroungrouped;
    fpreal64 myInputmask;
    int64 myInputmaskoverride;
    UT_StringHolder myInputmaskcurveattrib;
    UT_StringHolder myInputmaskattrib;
    UT_StringHolder myInputmasktexture;
    bool myVismasks;
    int64 myOutattribtype;
    UT_StringHolder myOutattrib;
    bool myCreateprimgroup;
    UT_StringHolder myOutprimgroup;
    bool myCreateintattrib;
    UT_StringHolder myIntattrib;
    int64 myIntattribvalue;
    fpreal64 myIntattribthresh;
    bool myUsenoisemask;
    fpreal64 myNoisemaskamount;
    int64 myNoisemaskamountoverride;
    UT_StringHolder myNoisemaskamountcurveattrib;
    UT_StringHolder myNoisemaskamountattrib;
    UT_StringHolder myNoisemaskamounttexture;
    fpreal64 myNoisemaskfreq;
    fpreal64 myNoisemaskgain;
    int64 myNoisemaskgainoverride;
    UT_StringHolder myNoisemaskgaincurveattrib;
    UT_StringHolder myNoisemaskgainattrib;
    UT_StringHolder myNoisemaskgaintexture;
    fpreal64 myNoisemaskbias;
    int64 myNoisemaskbiasoverride;
    UT_StringHolder myNoisemaskbiascurveattrib;
    UT_StringHolder myNoisemaskbiasattrib;
    UT_StringHolder myNoisemaskbiastexture;
    bool myNoisemaskcenterone;
    bool myNoisemaskfractal;
    fpreal64 myNoisemaskoct;
    fpreal64 myNoisemasklac;
    fpreal64 myNoisemaskrough;
    int64 myNoisemaskroughoverride;
    UT_StringHolder myNoisemaskroughcurveattrib;
    UT_StringHolder myNoisemaskroughattrib;
    UT_StringHolder myNoisemaskroughtexture;
    bool myUselengthmask;
    int64 myLengthmode;
    fpreal64 myLengthref;
    int64 myLengthrefoverride;
    UT_StringHolder myLengthrefcurveattrib;
    UT_StringHolder myLengthrefattrib;
    UT_StringHolder myLengthreftexture;
    fpreal64 myLengthfalloffrange;
    int64 myLengthfalloffrangeoverride;
    UT_StringHolder myLengthfalloffrangecurveattrib;
    UT_StringHolder myLengthfalloffrangeattrib;
    UT_StringHolder myLengthfalloffrangetexture;
    fpreal64 myLengthfalloffdecay;
    int64 myLengthfalloffdecayoverride;
    UT_StringHolder myLengthfalloffdecaycurveattrib;
    UT_StringHolder myLengthfalloffdecayattrib;
    UT_StringHolder myLengthfalloffdecaytexture;
    fpreal64 myLengthrangemin;
    fpreal64 myLengthrangemax;
    int64 myLengthpresets;
    UT_SharedPtr<UT_Ramp> myLengthramp;
    bool myUseskincurvmask;
    fpreal64 mySkincurvconcavemax;
    fpreal64 mySkincurvconvexmax;
    fpreal64 mySkincurvesmoothstrength;
    int64 mySkincurvpresets;
    UT_SharedPtr<UT_Ramp> mySkincurvramp;
    bool myUsegeomask;
    fpreal64 myGeovoxelsize;
    fpreal64 myGeointrange;
    fpreal64 myGeoextrange;
    int64 myGeodepthramppresets;
    UT_SharedPtr<UT_Ramp> myGeodepthramp;
    bool myGeodoblur;
    fpreal64 myGeoblurradius;
    int64 myGeobluriters;
    bool myUserandommask;
    int64 myRandommaskcombine;
    fpreal64 myRandommaskseed;
    fpreal64 myRandommaskfrac;
    fpreal64 myRandommaskvar;
    fpreal64 myRandommaskvargain;
    bool myUsecurvemask;
    bool myCurvemaskabsrange;
    fpreal64 myCurvemaskrangemin;
    fpreal64 myCurvemaskrangemax;
    fpreal64 myCurvemaskeffectpos;
    fpreal64 myCurvemaskfalloff;
    fpreal64 myCurvemaskwidth;
    UT_SharedPtr<UT_Ramp> myCurvemaskramp;
    bool myUseskinlookupattribs;

};
