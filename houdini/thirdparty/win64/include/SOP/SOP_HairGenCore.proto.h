/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_HairGenCoreEnums
{
    enum class Mode
    {
        SURFACE = 0,
        POINTS
    };
    enum class Guideblendmethod
    {
        LINEARBLEND = 0,
        EXTRUDEBLEND
    };
    enum class Influenceradiusoverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
    enum class Influencedecayoverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
    enum class Maxguidecountoverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
    enum class Maxguideangleoverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
    enum class Clumpcrossoveroverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
    enum class Unguidedlengthoverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
    enum class Thicknessoverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
}


class SOP_API SOP_HairGenCoreParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_HairGenCoreParms()
    {
        myMode = 0;
        myGroup = ""_sh;
        myUvattrib = "uv"_sh;
        myLimittobbox = false;
        myBboxsize = UT_Vector3D(1,1,1);
        myBboxcenter = UT_Vector3D(0,0,0);
        myPrune = false;
        myPruningratio = 0.9;
        myPrunethicken = false;
        myUseguides = false;
        myUniformguidesegments = false;
        mySkininterp = false;
        myGuideblendmethod = 0;
        myGuidegroup = ""_sh;
        myInfluenceradius = 0.05;
        myInfluenceradiusoverride = 0;
        myInfluenceradiusattrib = "influenceradiusscale"_sh;
        myInfluenceradiustexture = ""_sh;
        myInfluencedecay = 2;
        myInfluencedecayoverride = 0;
        myInfluencedecayattrib = "influencedecayscale"_sh;
        myInfluencedecaytexture = ""_sh;
        myMaxguidecount = 10;
        myMaxguidecountoverride = 0;
        myMaxguidecountattrib = "maxguidecountscale"_sh;
        myMaxguidecounttexture = ""_sh;
        myMaxguideangle = 90;
        myMaxguideangleoverride = 0;
        myMaxguideangleattrib = "maxguideanglescale"_sh;
        myMaxguideangletexture = ""_sh;
        myClumpcrossover = 0;
        myClumpcrossoveroverride = 0;
        myClumpcrossoverattrib = "clumpcrossoverscale"_sh;
        myClumpcrossovertexture = ""_sh;
        myGrowunguided = false;
        myUseinitdirattrib = false;
        myInitdirattrib = "furdirection"_sh;
        myUnguidedsegments = 8;
        myUnguidedlength = 0.05;
        myUnguidedlengthoverride = 0;
        myUnguidedlengthattrib = "unguidedlengthscale"_sh;
        myUnguidedlengthtexture = ""_sh;
        myUnguidedminlength = 1e-05;
        myCreateweightattribs = false;
        myCreaterestrootattrib = false;
        myOutputthicknessattrib = false;
        myThicknessattrib = "width"_sh;
        myThickness = 0.001;
        myThicknessoverride = 0;
        myThicknessskinattrib = "thicknessscale"_sh;
        myThicknesstexture = ""_sh;
        myHairprofile = UT_SharedPtr<UT_Ramp>(0);
        myPointattribs = ""_sh;
        myVertattribs = ""_sh;
        myPrimattribs = ""_sh;
        myDetailattribs = ""_sh;
        myGuidepointattribs = ""_sh;
        myGuideprimattribs = ""_sh;

    }

    explicit SOP_HairGenCoreParms(const SOP_HairGenCoreParms &) = default;

    virtual ~SOP_HairGenCoreParms() {}

    bool operator==(const SOP_HairGenCoreParms &src) const
    {
        if (myMode != src.myMode) return false;
        if (myGroup != src.myGroup) return false;
        if (myUvattrib != src.myUvattrib) return false;
        if (myLimittobbox != src.myLimittobbox) return false;
        if (myBboxsize != src.myBboxsize) return false;
        if (myBboxcenter != src.myBboxcenter) return false;
        if (myPrune != src.myPrune) return false;
        if (myPruningratio != src.myPruningratio) return false;
        if (myPrunethicken != src.myPrunethicken) return false;
        if (myUseguides != src.myUseguides) return false;
        if (myUniformguidesegments != src.myUniformguidesegments) return false;
        if (mySkininterp != src.mySkininterp) return false;
        if (myGuideblendmethod != src.myGuideblendmethod) return false;
        if (myGuidegroup != src.myGuidegroup) return false;
        if (myInfluenceradius != src.myInfluenceradius) return false;
        if (myInfluenceradiusoverride != src.myInfluenceradiusoverride) return false;
        if (myInfluenceradiusattrib != src.myInfluenceradiusattrib) return false;
        if (myInfluenceradiustexture != src.myInfluenceradiustexture) return false;
        if (myInfluencedecay != src.myInfluencedecay) return false;
        if (myInfluencedecayoverride != src.myInfluencedecayoverride) return false;
        if (myInfluencedecayattrib != src.myInfluencedecayattrib) return false;
        if (myInfluencedecaytexture != src.myInfluencedecaytexture) return false;
        if (myMaxguidecount != src.myMaxguidecount) return false;
        if (myMaxguidecountoverride != src.myMaxguidecountoverride) return false;
        if (myMaxguidecountattrib != src.myMaxguidecountattrib) return false;
        if (myMaxguidecounttexture != src.myMaxguidecounttexture) return false;
        if (myMaxguideangle != src.myMaxguideangle) return false;
        if (myMaxguideangleoverride != src.myMaxguideangleoverride) return false;
        if (myMaxguideangleattrib != src.myMaxguideangleattrib) return false;
        if (myMaxguideangletexture != src.myMaxguideangletexture) return false;
        if (myClumpcrossover != src.myClumpcrossover) return false;
        if (myClumpcrossoveroverride != src.myClumpcrossoveroverride) return false;
        if (myClumpcrossoverattrib != src.myClumpcrossoverattrib) return false;
        if (myClumpcrossovertexture != src.myClumpcrossovertexture) return false;
        if (myGrowunguided != src.myGrowunguided) return false;
        if (myUseinitdirattrib != src.myUseinitdirattrib) return false;
        if (myInitdirattrib != src.myInitdirattrib) return false;
        if (myUnguidedsegments != src.myUnguidedsegments) return false;
        if (myUnguidedlength != src.myUnguidedlength) return false;
        if (myUnguidedlengthoverride != src.myUnguidedlengthoverride) return false;
        if (myUnguidedlengthattrib != src.myUnguidedlengthattrib) return false;
        if (myUnguidedlengthtexture != src.myUnguidedlengthtexture) return false;
        if (myUnguidedminlength != src.myUnguidedminlength) return false;
        if (myCreateweightattribs != src.myCreateweightattribs) return false;
        if (myCreaterestrootattrib != src.myCreaterestrootattrib) return false;
        if (myOutputthicknessattrib != src.myOutputthicknessattrib) return false;
        if (myThicknessattrib != src.myThicknessattrib) return false;
        if (myThickness != src.myThickness) return false;
        if (myThicknessoverride != src.myThicknessoverride) return false;
        if (myThicknessskinattrib != src.myThicknessskinattrib) return false;
        if (myThicknesstexture != src.myThicknesstexture) return false;
        if (myHairprofile != src.myHairprofile) return false;
        if (myPointattribs != src.myPointattribs) return false;
        if (myVertattribs != src.myVertattribs) return false;
        if (myPrimattribs != src.myPrimattribs) return false;
        if (myDetailattribs != src.myDetailattribs) return false;
        if (myGuidepointattribs != src.myGuidepointattribs) return false;
        if (myGuideprimattribs != src.myGuideprimattribs) return false;

        return true;
    }
    bool operator!=(const SOP_HairGenCoreParms &src) const
    {
        return !operator==(src);
    }
    using Mode = SOP_HairGenCoreEnums::Mode;
    using Guideblendmethod = SOP_HairGenCoreEnums::Guideblendmethod;
    using Influenceradiusoverride = SOP_HairGenCoreEnums::Influenceradiusoverride;
    using Influencedecayoverride = SOP_HairGenCoreEnums::Influencedecayoverride;
    using Maxguidecountoverride = SOP_HairGenCoreEnums::Maxguidecountoverride;
    using Maxguideangleoverride = SOP_HairGenCoreEnums::Maxguideangleoverride;
    using Clumpcrossoveroverride = SOP_HairGenCoreEnums::Clumpcrossoveroverride;
    using Unguidedlengthoverride = SOP_HairGenCoreEnums::Unguidedlengthoverride;
    using Thicknessoverride = SOP_HairGenCoreEnums::Thicknessoverride;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myMode, node, "mode", time, 0);
        else myMode = 0;
        if (true)
            OP_Utils::evalOpParm(myGroup, node, "group", time, 0);
        else myGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myUvattrib, node, "uvattrib", time, 0);
        else myUvattrib = "uv"_sh;
        if (true)
            OP_Utils::evalOpParm(myLimittobbox, node, "limittobbox", time, 0);
        else myLimittobbox = false;
        if (true && ( (!(((getLimittobbox()==0)))) ) )
            OP_Utils::evalOpParm(myBboxsize, node, "bboxsize", time, 0);
        else myBboxsize = UT_Vector3D(1,1,1);
        if (true && ( (!(((getLimittobbox()==0)))) ) )
            OP_Utils::evalOpParm(myBboxcenter, node, "bboxcenter", time, 0);
        else myBboxcenter = UT_Vector3D(0,0,0);
        if (true)
            OP_Utils::evalOpParm(myPrune, node, "prune", time, 0);
        else myPrune = false;
        if (true && ( (!(((getPrune()==0)))) ) )
            OP_Utils::evalOpParm(myPruningratio, node, "pruningratio", time, 0);
        else myPruningratio = 0.9;
        if (true && ( (!(((getPrune()==0)))) ) )
            OP_Utils::evalOpParm(myPrunethicken, node, "prunethicken", time, 0);
        else myPrunethicken = false;
        if (true)
            OP_Utils::evalOpParm(myUseguides, node, "useguides", time, 0);
        else myUseguides = false;
        if (true && ( (!(((getUseguides()==0)))) ) )
            OP_Utils::evalOpParm(myUniformguidesegments, node, "uniformguidesegments", time, 0);
        else myUniformguidesegments = false;
        if (true && ( (!(((getUseguides()==0)))) ) )
            OP_Utils::evalOpParm(mySkininterp, node, "skininterp", time, 0);
        else mySkininterp = false;
        if (true)
            OP_Utils::evalOpParm(myGuideblendmethod, node, "guideblendmethod", time, 0);
        else myGuideblendmethod = 0;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1)))) ) )
            OP_Utils::evalOpParm(myGuidegroup, node, "guidegroup", time, 0);
        else myGuidegroup = ""_sh;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1)))) ) )
            OP_Utils::evalOpParm(myInfluenceradius, node, "influenceradius", time, 0);
        else myInfluenceradius = 0.05;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1)))) ) )
            OP_Utils::evalOpParm(myInfluenceradiusoverride, node, "influenceradiusoverride", time, 0);
        else myInfluenceradiusoverride = 0;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1))||((int64(getInfluenceradiusoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myInfluenceradiusattrib, node, "influenceradiusattrib", time, 0);
        else myInfluenceradiusattrib = "influenceradiusscale"_sh;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1))||((int64(getInfluenceradiusoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myInfluenceradiustexture, node, "influenceradiustexture", time, 0);
        else myInfluenceradiustexture = ""_sh;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1)))) ) )
            OP_Utils::evalOpParm(myInfluencedecay, node, "influencedecay", time, 0);
        else myInfluencedecay = 2;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1)))) ) )
            OP_Utils::evalOpParm(myInfluencedecayoverride, node, "influencedecayoverride", time, 0);
        else myInfluencedecayoverride = 0;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1))||((int64(getInfluencedecayoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myInfluencedecayattrib, node, "influencedecayattrib", time, 0);
        else myInfluencedecayattrib = "influencedecayscale"_sh;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1))||((int64(getInfluencedecayoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myInfluencedecaytexture, node, "influencedecaytexture", time, 0);
        else myInfluencedecaytexture = ""_sh;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1)))) ) )
            OP_Utils::evalOpParm(myMaxguidecount, node, "maxguidecount", time, 0);
        else myMaxguidecount = 10;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1)))) ) )
            OP_Utils::evalOpParm(myMaxguidecountoverride, node, "maxguidecountoverride", time, 0);
        else myMaxguidecountoverride = 0;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1))||((int64(getMaxguidecountoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myMaxguidecountattrib, node, "maxguidecountattrib", time, 0);
        else myMaxguidecountattrib = "maxguidecountscale"_sh;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1))||((int64(getMaxguidecountoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myMaxguidecounttexture, node, "maxguidecounttexture", time, 0);
        else myMaxguidecounttexture = ""_sh;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1)))) ) )
            OP_Utils::evalOpParm(myMaxguideangle, node, "maxguideangle", time, 0);
        else myMaxguideangle = 90;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1)))) ) )
            OP_Utils::evalOpParm(myMaxguideangleoverride, node, "maxguideangleoverride", time, 0);
        else myMaxguideangleoverride = 0;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1))||((int64(getMaxguideangleoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myMaxguideangleattrib, node, "maxguideangleattrib", time, 0);
        else myMaxguideangleattrib = "maxguideanglescale"_sh;
        if (true && ( (!(((getUseguides()==0))||((getSkininterp()==1))||((int64(getMaxguideangleoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myMaxguideangletexture, node, "maxguideangletexture", time, 0);
        else myMaxguideangletexture = ""_sh;
        if (true && ( (!(((getUseguides()==0)))) ) )
            OP_Utils::evalOpParm(myClumpcrossover, node, "clumpcrossover", time, 0);
        else myClumpcrossover = 0;
        if (true && ( (!(((getUseguides()==0)))) ) )
            OP_Utils::evalOpParm(myClumpcrossoveroverride, node, "clumpcrossoveroverride", time, 0);
        else myClumpcrossoveroverride = 0;
        if (true && ( (!(((getUseguides()==0))||((int64(getClumpcrossoveroverride())!=1)))) ) )
            OP_Utils::evalOpParm(myClumpcrossoverattrib, node, "clumpcrossoverattrib", time, 0);
        else myClumpcrossoverattrib = "clumpcrossoverscale"_sh;
        if (true && ( (!(((getUseguides()==0))||((int64(getClumpcrossoveroverride())!=2)))) ) )
            OP_Utils::evalOpParm(myClumpcrossovertexture, node, "clumpcrossovertexture", time, 0);
        else myClumpcrossovertexture = ""_sh;
        if (true && ( (!(((getUseguides()==0)))) ) )
            OP_Utils::evalOpParm(myGrowunguided, node, "growunguided", time, 0);
        else myGrowunguided = false;
        if (true && ( (!(((getUseguides()==1)&&(getGrowunguided()==0)))) ) )
            OP_Utils::evalOpParm(myUseinitdirattrib, node, "useinitdirattrib", time, 0);
        else myUseinitdirattrib = false;
        if (true && ( (!(((getUseinitdirattrib()==0))||((getUseguides()==1)&&(getGrowunguided()==0)))) ) )
            OP_Utils::evalOpParm(myInitdirattrib, node, "initdirattrib", time, 0);
        else myInitdirattrib = "furdirection"_sh;
        if (true && ( (!(((getUseguides()==1)&&(getGrowunguided()==0)))) ) )
            OP_Utils::evalOpParm(myUnguidedsegments, node, "unguidedsegments", time, 0);
        else myUnguidedsegments = 8;
        if (true && ( (!(((getUseguides()==1)&&(getGrowunguided()==0)))) ) )
            OP_Utils::evalOpParm(myUnguidedlength, node, "unguidedlength", time, 0);
        else myUnguidedlength = 0.05;
        if (true && ( (!(((getUseguides()==1)&&(getGrowunguided()==0)))) ) )
            OP_Utils::evalOpParm(myUnguidedlengthoverride, node, "unguidedlengthoverride", time, 0);
        else myUnguidedlengthoverride = 0;
        if (true && ( (!(((getUseguides()==1)&&(getGrowunguided()==0))||((int64(getUnguidedlengthoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myUnguidedlengthattrib, node, "unguidedlengthattrib", time, 0);
        else myUnguidedlengthattrib = "unguidedlengthscale"_sh;
        if (true && ( (!(((getUseguides()==1)&&(getGrowunguided()==0))||((int64(getUnguidedlengthoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myUnguidedlengthtexture, node, "unguidedlengthtexture", time, 0);
        else myUnguidedlengthtexture = ""_sh;
        if (true && ( (!(((getUseguides()==1)&&(getGrowunguided()==0)))) ) )
            OP_Utils::evalOpParm(myUnguidedminlength, node, "unguidedminlength", time, 0);
        else myUnguidedminlength = 1e-05;
        if (true && ( (!(((getUseguides()==0)))) ) )
            OP_Utils::evalOpParm(myCreateweightattribs, node, "createweightattribs", time, 0);
        else myCreateweightattribs = false;
        if (true)
            OP_Utils::evalOpParm(myCreaterestrootattrib, node, "createrestrootattrib", time, 0);
        else myCreaterestrootattrib = false;
        if (true)
            OP_Utils::evalOpParm(myOutputthicknessattrib, node, "outputthicknessattrib", time, 0);
        else myOutputthicknessattrib = false;
        if (true && ( (!(((getOutputthicknessattrib()==0)))) ) )
            OP_Utils::evalOpParm(myThicknessattrib, node, "thicknessattrib", time, 0);
        else myThicknessattrib = "width"_sh;
        if (true && ( (!(((getOutputthicknessattrib()==0)))) ) )
            OP_Utils::evalOpParm(myThickness, node, "thickness", time, 0);
        else myThickness = 0.001;
        if (true && ( (!(((getOutputthicknessattrib()==0)))) ) )
            OP_Utils::evalOpParm(myThicknessoverride, node, "thicknessoverride", time, 0);
        else myThicknessoverride = 0;
        if (true && ( (!(((getOutputthicknessattrib()==0))||((int64(getThicknessoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myThicknessskinattrib, node, "thicknessskinattrib", time, 0);
        else myThicknessskinattrib = "thicknessscale"_sh;
        if (true && ( (!(((getOutputthicknessattrib()==0))||((int64(getThicknessoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myThicknesstexture, node, "thicknesstexture", time, 0);
        else myThicknesstexture = ""_sh;
        if (true && ( (!(((getOutputthicknessattrib()==0)))) ) )
            OP_Utils::evalOpParm(myHairprofile, node, "hairprofile", time, 0);
        else myHairprofile = UT_SharedPtr<UT_Ramp>(0);
        if (true)
            OP_Utils::evalOpParm(myPointattribs, node, "pointattribs", time, 0);
        else myPointattribs = ""_sh;
        if (true && ( (!(((int64(getMode())!=0)))) ) )
            OP_Utils::evalOpParm(myVertattribs, node, "vertattribs", time, 0);
        else myVertattribs = ""_sh;
        if (true && ( (!(((int64(getMode())!=0)))) ) )
            OP_Utils::evalOpParm(myPrimattribs, node, "primattribs", time, 0);
        else myPrimattribs = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myDetailattribs, node, "detailattribs", time, 0);
        else myDetailattribs = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myGuidepointattribs, node, "guidepointattribs", time, 0);
        else myGuidepointattribs = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myGuideprimattribs, node, "guideprimattribs", time, 0);
        else myGuideprimattribs = ""_sh;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_HairGenCoreParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myMode);
                break;
            case 1:
                coerceValue(value, myGroup);
                break;
            case 2:
                coerceValue(value, myUvattrib);
                break;
            case 3:
                coerceValue(value, myLimittobbox);
                break;
            case 4:
                coerceValue(value, myBboxsize);
                break;
            case 5:
                coerceValue(value, myBboxcenter);
                break;
            case 6:
                coerceValue(value, myPrune);
                break;
            case 7:
                coerceValue(value, myPruningratio);
                break;
            case 8:
                coerceValue(value, myPrunethicken);
                break;
            case 9:
                coerceValue(value, myUseguides);
                break;
            case 10:
                coerceValue(value, myUniformguidesegments);
                break;
            case 11:
                coerceValue(value, mySkininterp);
                break;
            case 12:
                coerceValue(value, myGuideblendmethod);
                break;
            case 13:
                coerceValue(value, myGuidegroup);
                break;
            case 14:
                coerceValue(value, myInfluenceradius);
                break;
            case 15:
                coerceValue(value, myInfluenceradiusoverride);
                break;
            case 16:
                coerceValue(value, myInfluenceradiusattrib);
                break;
            case 17:
                coerceValue(value, myInfluenceradiustexture);
                break;
            case 18:
                coerceValue(value, myInfluencedecay);
                break;
            case 19:
                coerceValue(value, myInfluencedecayoverride);
                break;
            case 20:
                coerceValue(value, myInfluencedecayattrib);
                break;
            case 21:
                coerceValue(value, myInfluencedecaytexture);
                break;
            case 22:
                coerceValue(value, myMaxguidecount);
                break;
            case 23:
                coerceValue(value, myMaxguidecountoverride);
                break;
            case 24:
                coerceValue(value, myMaxguidecountattrib);
                break;
            case 25:
                coerceValue(value, myMaxguidecounttexture);
                break;
            case 26:
                coerceValue(value, myMaxguideangle);
                break;
            case 27:
                coerceValue(value, myMaxguideangleoverride);
                break;
            case 28:
                coerceValue(value, myMaxguideangleattrib);
                break;
            case 29:
                coerceValue(value, myMaxguideangletexture);
                break;
            case 30:
                coerceValue(value, myClumpcrossover);
                break;
            case 31:
                coerceValue(value, myClumpcrossoveroverride);
                break;
            case 32:
                coerceValue(value, myClumpcrossoverattrib);
                break;
            case 33:
                coerceValue(value, myClumpcrossovertexture);
                break;
            case 34:
                coerceValue(value, myGrowunguided);
                break;
            case 35:
                coerceValue(value, myUseinitdirattrib);
                break;
            case 36:
                coerceValue(value, myInitdirattrib);
                break;
            case 37:
                coerceValue(value, myUnguidedsegments);
                break;
            case 38:
                coerceValue(value, myUnguidedlength);
                break;
            case 39:
                coerceValue(value, myUnguidedlengthoverride);
                break;
            case 40:
                coerceValue(value, myUnguidedlengthattrib);
                break;
            case 41:
                coerceValue(value, myUnguidedlengthtexture);
                break;
            case 42:
                coerceValue(value, myUnguidedminlength);
                break;
            case 43:
                coerceValue(value, myCreateweightattribs);
                break;
            case 44:
                coerceValue(value, myCreaterestrootattrib);
                break;
            case 45:
                coerceValue(value, myOutputthicknessattrib);
                break;
            case 46:
                coerceValue(value, myThicknessattrib);
                break;
            case 47:
                coerceValue(value, myThickness);
                break;
            case 48:
                coerceValue(value, myThicknessoverride);
                break;
            case 49:
                coerceValue(value, myThicknessskinattrib);
                break;
            case 50:
                coerceValue(value, myThicknesstexture);
                break;
            case 51:
                coerceValue(value, myHairprofile);
                break;
            case 52:
                coerceValue(value, myPointattribs);
                break;
            case 53:
                coerceValue(value, myVertattribs);
                break;
            case 54:
                coerceValue(value, myPrimattribs);
                break;
            case 55:
                coerceValue(value, myDetailattribs);
                break;
            case 56:
                coerceValue(value, myGuidepointattribs);
                break;
            case 57:
                coerceValue(value, myGuideprimattribs);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myMode, value);
                break;
            case 1:
                coerceValue(myGroup, value);
                break;
            case 2:
                coerceValue(myUvattrib, value);
                break;
            case 3:
                coerceValue(myLimittobbox, value);
                break;
            case 4:
                coerceValue(myBboxsize, value);
                break;
            case 5:
                coerceValue(myBboxcenter, value);
                break;
            case 6:
                coerceValue(myPrune, value);
                break;
            case 7:
                coerceValue(myPruningratio, value);
                break;
            case 8:
                coerceValue(myPrunethicken, value);
                break;
            case 9:
                coerceValue(myUseguides, value);
                break;
            case 10:
                coerceValue(myUniformguidesegments, value);
                break;
            case 11:
                coerceValue(mySkininterp, value);
                break;
            case 12:
                coerceValue(myGuideblendmethod, value);
                break;
            case 13:
                coerceValue(myGuidegroup, value);
                break;
            case 14:
                coerceValue(myInfluenceradius, value);
                break;
            case 15:
                coerceValue(myInfluenceradiusoverride, value);
                break;
            case 16:
                coerceValue(myInfluenceradiusattrib, value);
                break;
            case 17:
                coerceValue(myInfluenceradiustexture, value);
                break;
            case 18:
                coerceValue(myInfluencedecay, value);
                break;
            case 19:
                coerceValue(myInfluencedecayoverride, value);
                break;
            case 20:
                coerceValue(myInfluencedecayattrib, value);
                break;
            case 21:
                coerceValue(myInfluencedecaytexture, value);
                break;
            case 22:
                coerceValue(myMaxguidecount, value);
                break;
            case 23:
                coerceValue(myMaxguidecountoverride, value);
                break;
            case 24:
                coerceValue(myMaxguidecountattrib, value);
                break;
            case 25:
                coerceValue(myMaxguidecounttexture, value);
                break;
            case 26:
                coerceValue(myMaxguideangle, value);
                break;
            case 27:
                coerceValue(myMaxguideangleoverride, value);
                break;
            case 28:
                coerceValue(myMaxguideangleattrib, value);
                break;
            case 29:
                coerceValue(myMaxguideangletexture, value);
                break;
            case 30:
                coerceValue(myClumpcrossover, value);
                break;
            case 31:
                coerceValue(myClumpcrossoveroverride, value);
                break;
            case 32:
                coerceValue(myClumpcrossoverattrib, value);
                break;
            case 33:
                coerceValue(myClumpcrossovertexture, value);
                break;
            case 34:
                coerceValue(myGrowunguided, value);
                break;
            case 35:
                coerceValue(myUseinitdirattrib, value);
                break;
            case 36:
                coerceValue(myInitdirattrib, value);
                break;
            case 37:
                coerceValue(myUnguidedsegments, value);
                break;
            case 38:
                coerceValue(myUnguidedlength, value);
                break;
            case 39:
                coerceValue(myUnguidedlengthoverride, value);
                break;
            case 40:
                coerceValue(myUnguidedlengthattrib, value);
                break;
            case 41:
                coerceValue(myUnguidedlengthtexture, value);
                break;
            case 42:
                coerceValue(myUnguidedminlength, value);
                break;
            case 43:
                coerceValue(myCreateweightattribs, value);
                break;
            case 44:
                coerceValue(myCreaterestrootattrib, value);
                break;
            case 45:
                coerceValue(myOutputthicknessattrib, value);
                break;
            case 46:
                coerceValue(myThicknessattrib, value);
                break;
            case 47:
                coerceValue(myThickness, value);
                break;
            case 48:
                coerceValue(myThicknessoverride, value);
                break;
            case 49:
                coerceValue(myThicknessskinattrib, value);
                break;
            case 50:
                coerceValue(myThicknesstexture, value);
                break;
            case 51:
                coerceValue(myHairprofile, value);
                break;
            case 52:
                coerceValue(myPointattribs, value);
                break;
            case 53:
                coerceValue(myVertattribs, value);
                break;
            case 54:
                coerceValue(myPrimattribs, value);
                break;
            case 55:
                coerceValue(myDetailattribs, value);
                break;
            case 56:
                coerceValue(myGuidepointattribs, value);
                break;
            case 57:
                coerceValue(myGuideprimattribs, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 58;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "mode";
            case 1:
                return "group";
            case 2:
                return "uvattrib";
            case 3:
                return "limittobbox";
            case 4:
                return "bboxsize";
            case 5:
                return "bboxcenter";
            case 6:
                return "prune";
            case 7:
                return "pruningratio";
            case 8:
                return "prunethicken";
            case 9:
                return "useguides";
            case 10:
                return "uniformguidesegments";
            case 11:
                return "skininterp";
            case 12:
                return "guideblendmethod";
            case 13:
                return "guidegroup";
            case 14:
                return "influenceradius";
            case 15:
                return "influenceradiusoverride";
            case 16:
                return "influenceradiusattrib";
            case 17:
                return "influenceradiustexture";
            case 18:
                return "influencedecay";
            case 19:
                return "influencedecayoverride";
            case 20:
                return "influencedecayattrib";
            case 21:
                return "influencedecaytexture";
            case 22:
                return "maxguidecount";
            case 23:
                return "maxguidecountoverride";
            case 24:
                return "maxguidecountattrib";
            case 25:
                return "maxguidecounttexture";
            case 26:
                return "maxguideangle";
            case 27:
                return "maxguideangleoverride";
            case 28:
                return "maxguideangleattrib";
            case 29:
                return "maxguideangletexture";
            case 30:
                return "clumpcrossover";
            case 31:
                return "clumpcrossoveroverride";
            case 32:
                return "clumpcrossoverattrib";
            case 33:
                return "clumpcrossovertexture";
            case 34:
                return "growunguided";
            case 35:
                return "useinitdirattrib";
            case 36:
                return "initdirattrib";
            case 37:
                return "unguidedsegments";
            case 38:
                return "unguidedlength";
            case 39:
                return "unguidedlengthoverride";
            case 40:
                return "unguidedlengthattrib";
            case 41:
                return "unguidedlengthtexture";
            case 42:
                return "unguidedminlength";
            case 43:
                return "createweightattribs";
            case 44:
                return "createrestrootattrib";
            case 45:
                return "outputthicknessattrib";
            case 46:
                return "thicknessattrib";
            case 47:
                return "thickness";
            case 48:
                return "thicknessoverride";
            case 49:
                return "thicknessskinattrib";
            case 50:
                return "thicknesstexture";
            case 51:
                return "hairprofile";
            case 52:
                return "pointattribs";
            case 53:
                return "vertattribs";
            case 54:
                return "primattribs";
            case 55:
                return "detailattribs";
            case 56:
                return "guidepointattribs";
            case 57:
                return "guideprimattribs";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_INTEGER;
                case 1:
                    return PARM_STRING;
                case 2:
                    return PARM_STRING;
                case 3:
                    return PARM_INTEGER;
                case 4:
                    return PARM_VECTOR3;
                case 5:
                    return PARM_VECTOR3;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_FLOAT;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_INTEGER;
                case 11:
                    return PARM_INTEGER;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_STRING;
                case 14:
                    return PARM_FLOAT;
                case 15:
                    return PARM_INTEGER;
                case 16:
                    return PARM_STRING;
                case 17:
                    return PARM_STRING;
                case 18:
                    return PARM_FLOAT;
                case 19:
                    return PARM_INTEGER;
                case 20:
                    return PARM_STRING;
                case 21:
                    return PARM_STRING;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_INTEGER;
                case 24:
                    return PARM_STRING;
                case 25:
                    return PARM_STRING;
                case 26:
                    return PARM_FLOAT;
                case 27:
                    return PARM_INTEGER;
                case 28:
                    return PARM_STRING;
                case 29:
                    return PARM_STRING;
                case 30:
                    return PARM_FLOAT;
                case 31:
                    return PARM_INTEGER;
                case 32:
                    return PARM_STRING;
                case 33:
                    return PARM_STRING;
                case 34:
                    return PARM_INTEGER;
                case 35:
                    return PARM_INTEGER;
                case 36:
                    return PARM_STRING;
                case 37:
                    return PARM_INTEGER;
                case 38:
                    return PARM_FLOAT;
                case 39:
                    return PARM_INTEGER;
                case 40:
                    return PARM_STRING;
                case 41:
                    return PARM_STRING;
                case 42:
                    return PARM_FLOAT;
                case 43:
                    return PARM_INTEGER;
                case 44:
                    return PARM_INTEGER;
                case 45:
                    return PARM_INTEGER;
                case 46:
                    return PARM_STRING;
                case 47:
                    return PARM_FLOAT;
                case 48:
                    return PARM_INTEGER;
                case 49:
                    return PARM_STRING;
                case 50:
                    return PARM_STRING;
                case 51:
                    return PARM_RAMP;
                case 52:
                    return PARM_STRING;
                case 53:
                    return PARM_STRING;
                case 54:
                    return PARM_STRING;
                case 55:
                    return PARM_STRING;
                case 56:
                    return PARM_STRING;
                case 57:
                    return PARM_STRING;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myMode);
        saveData(os, myGroup);
        saveData(os, myUvattrib);
        saveData(os, myLimittobbox);
        saveData(os, myBboxsize);
        saveData(os, myBboxcenter);
        saveData(os, myPrune);
        saveData(os, myPruningratio);
        saveData(os, myPrunethicken);
        saveData(os, myUseguides);
        saveData(os, myUniformguidesegments);
        saveData(os, mySkininterp);
        saveData(os, myGuideblendmethod);
        saveData(os, myGuidegroup);
        saveData(os, myInfluenceradius);
        saveData(os, myInfluenceradiusoverride);
        saveData(os, myInfluenceradiusattrib);
        saveData(os, myInfluenceradiustexture);
        saveData(os, myInfluencedecay);
        saveData(os, myInfluencedecayoverride);
        saveData(os, myInfluencedecayattrib);
        saveData(os, myInfluencedecaytexture);
        saveData(os, myMaxguidecount);
        saveData(os, myMaxguidecountoverride);
        saveData(os, myMaxguidecountattrib);
        saveData(os, myMaxguidecounttexture);
        saveData(os, myMaxguideangle);
        saveData(os, myMaxguideangleoverride);
        saveData(os, myMaxguideangleattrib);
        saveData(os, myMaxguideangletexture);
        saveData(os, myClumpcrossover);
        saveData(os, myClumpcrossoveroverride);
        saveData(os, myClumpcrossoverattrib);
        saveData(os, myClumpcrossovertexture);
        saveData(os, myGrowunguided);
        saveData(os, myUseinitdirattrib);
        saveData(os, myInitdirattrib);
        saveData(os, myUnguidedsegments);
        saveData(os, myUnguidedlength);
        saveData(os, myUnguidedlengthoverride);
        saveData(os, myUnguidedlengthattrib);
        saveData(os, myUnguidedlengthtexture);
        saveData(os, myUnguidedminlength);
        saveData(os, myCreateweightattribs);
        saveData(os, myCreaterestrootattrib);
        saveData(os, myOutputthicknessattrib);
        saveData(os, myThicknessattrib);
        saveData(os, myThickness);
        saveData(os, myThicknessoverride);
        saveData(os, myThicknessskinattrib);
        saveData(os, myThicknesstexture);
        saveData(os, myHairprofile);
        saveData(os, myPointattribs);
        saveData(os, myVertattribs);
        saveData(os, myPrimattribs);
        saveData(os, myDetailattribs);
        saveData(os, myGuidepointattribs);
        saveData(os, myGuideprimattribs);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myMode);
        loadData(is, myGroup);
        loadData(is, myUvattrib);
        loadData(is, myLimittobbox);
        loadData(is, myBboxsize);
        loadData(is, myBboxcenter);
        loadData(is, myPrune);
        loadData(is, myPruningratio);
        loadData(is, myPrunethicken);
        loadData(is, myUseguides);
        loadData(is, myUniformguidesegments);
        loadData(is, mySkininterp);
        loadData(is, myGuideblendmethod);
        loadData(is, myGuidegroup);
        loadData(is, myInfluenceradius);
        loadData(is, myInfluenceradiusoverride);
        loadData(is, myInfluenceradiusattrib);
        loadData(is, myInfluenceradiustexture);
        loadData(is, myInfluencedecay);
        loadData(is, myInfluencedecayoverride);
        loadData(is, myInfluencedecayattrib);
        loadData(is, myInfluencedecaytexture);
        loadData(is, myMaxguidecount);
        loadData(is, myMaxguidecountoverride);
        loadData(is, myMaxguidecountattrib);
        loadData(is, myMaxguidecounttexture);
        loadData(is, myMaxguideangle);
        loadData(is, myMaxguideangleoverride);
        loadData(is, myMaxguideangleattrib);
        loadData(is, myMaxguideangletexture);
        loadData(is, myClumpcrossover);
        loadData(is, myClumpcrossoveroverride);
        loadData(is, myClumpcrossoverattrib);
        loadData(is, myClumpcrossovertexture);
        loadData(is, myGrowunguided);
        loadData(is, myUseinitdirattrib);
        loadData(is, myInitdirattrib);
        loadData(is, myUnguidedsegments);
        loadData(is, myUnguidedlength);
        loadData(is, myUnguidedlengthoverride);
        loadData(is, myUnguidedlengthattrib);
        loadData(is, myUnguidedlengthtexture);
        loadData(is, myUnguidedminlength);
        loadData(is, myCreateweightattribs);
        loadData(is, myCreaterestrootattrib);
        loadData(is, myOutputthicknessattrib);
        loadData(is, myThicknessattrib);
        loadData(is, myThickness);
        loadData(is, myThicknessoverride);
        loadData(is, myThicknessskinattrib);
        loadData(is, myThicknesstexture);
        loadData(is, myHairprofile);
        loadData(is, myPointattribs);
        loadData(is, myVertattribs);
        loadData(is, myPrimattribs);
        loadData(is, myDetailattribs);
        loadData(is, myGuidepointattribs);
        loadData(is, myGuideprimattribs);

        return true;
    }

    Mode getMode() const { return Mode(myMode); }
    void setMode(Mode val) { myMode = int64(val); }
    Mode opMode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMode();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "mode", cookparms.getCookTime(), 0);
        return Mode(result);
    }
    const UT_StringHolder & getGroup() const { return myGroup; }
    void setGroup(const UT_StringHolder & val) { myGroup = val; }
    UT_StringHolder opGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "group", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getUvattrib() const { return myUvattrib; }
    void setUvattrib(const UT_StringHolder & val) { myUvattrib = val; }
    UT_StringHolder opUvattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUvattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "uvattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getLimittobbox() const { return myLimittobbox; }
    void setLimittobbox(bool val) { myLimittobbox = val; }
    bool opLimittobbox(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLimittobbox();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "limittobbox", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getBboxsize() const { return myBboxsize; }
    void setBboxsize(UT_Vector3D val) { myBboxsize = val; }
    UT_Vector3D opBboxsize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBboxsize();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "bboxsize", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getBboxcenter() const { return myBboxcenter; }
    void setBboxcenter(UT_Vector3D val) { myBboxcenter = val; }
    UT_Vector3D opBboxcenter(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBboxcenter();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "bboxcenter", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPrune() const { return myPrune; }
    void setPrune(bool val) { myPrune = val; }
    bool opPrune(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrune();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "prune", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getPruningratio() const { return myPruningratio; }
    void setPruningratio(fpreal64 val) { myPruningratio = val; }
    fpreal64 opPruningratio(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPruningratio();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "pruningratio", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPrunethicken() const { return myPrunethicken; }
    void setPrunethicken(bool val) { myPrunethicken = val; }
    bool opPrunethicken(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrunethicken();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "prunethicken", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseguides() const { return myUseguides; }
    void setUseguides(bool val) { myUseguides = val; }
    bool opUseguides(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseguides();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useguides", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUniformguidesegments() const { return myUniformguidesegments; }
    void setUniformguidesegments(bool val) { myUniformguidesegments = val; }
    bool opUniformguidesegments(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUniformguidesegments();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "uniformguidesegments", cookparms.getCookTime(), 0);
        return result;
    }
    bool getSkininterp() const { return mySkininterp; }
    void setSkininterp(bool val) { mySkininterp = val; }
    bool opSkininterp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSkininterp();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "skininterp", cookparms.getCookTime(), 0);
        return result;
    }
    Guideblendmethod getGuideblendmethod() const { return Guideblendmethod(myGuideblendmethod); }
    void setGuideblendmethod(Guideblendmethod val) { myGuideblendmethod = int64(val); }
    Guideblendmethod opGuideblendmethod(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGuideblendmethod();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "guideblendmethod", cookparms.getCookTime(), 0);
        return Guideblendmethod(result);
    }
    const UT_StringHolder & getGuidegroup() const { return myGuidegroup; }
    void setGuidegroup(const UT_StringHolder & val) { myGuidegroup = val; }
    UT_StringHolder opGuidegroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGuidegroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "guidegroup", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getInfluenceradius() const { return myInfluenceradius; }
    void setInfluenceradius(fpreal64 val) { myInfluenceradius = val; }
    fpreal64 opInfluenceradius(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInfluenceradius();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "influenceradius", cookparms.getCookTime(), 0);
        return result;
    }
    Influenceradiusoverride getInfluenceradiusoverride() const { return Influenceradiusoverride(myInfluenceradiusoverride); }
    void setInfluenceradiusoverride(Influenceradiusoverride val) { myInfluenceradiusoverride = int64(val); }
    Influenceradiusoverride opInfluenceradiusoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInfluenceradiusoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "influenceradiusoverride", cookparms.getCookTime(), 0);
        return Influenceradiusoverride(result);
    }
    const UT_StringHolder & getInfluenceradiusattrib() const { return myInfluenceradiusattrib; }
    void setInfluenceradiusattrib(const UT_StringHolder & val) { myInfluenceradiusattrib = val; }
    UT_StringHolder opInfluenceradiusattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInfluenceradiusattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "influenceradiusattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getInfluenceradiustexture() const { return myInfluenceradiustexture; }
    void setInfluenceradiustexture(const UT_StringHolder & val) { myInfluenceradiustexture = val; }
    UT_StringHolder opInfluenceradiustexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInfluenceradiustexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "influenceradiustexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getInfluencedecay() const { return myInfluencedecay; }
    void setInfluencedecay(fpreal64 val) { myInfluencedecay = val; }
    fpreal64 opInfluencedecay(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInfluencedecay();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "influencedecay", cookparms.getCookTime(), 0);
        return result;
    }
    Influencedecayoverride getInfluencedecayoverride() const { return Influencedecayoverride(myInfluencedecayoverride); }
    void setInfluencedecayoverride(Influencedecayoverride val) { myInfluencedecayoverride = int64(val); }
    Influencedecayoverride opInfluencedecayoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInfluencedecayoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "influencedecayoverride", cookparms.getCookTime(), 0);
        return Influencedecayoverride(result);
    }
    const UT_StringHolder & getInfluencedecayattrib() const { return myInfluencedecayattrib; }
    void setInfluencedecayattrib(const UT_StringHolder & val) { myInfluencedecayattrib = val; }
    UT_StringHolder opInfluencedecayattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInfluencedecayattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "influencedecayattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getInfluencedecaytexture() const { return myInfluencedecaytexture; }
    void setInfluencedecaytexture(const UT_StringHolder & val) { myInfluencedecaytexture = val; }
    UT_StringHolder opInfluencedecaytexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInfluencedecaytexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "influencedecaytexture", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getMaxguidecount() const { return myMaxguidecount; }
    void setMaxguidecount(int64 val) { myMaxguidecount = val; }
    int64 opMaxguidecount(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxguidecount();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "maxguidecount", cookparms.getCookTime(), 0);
        return result;
    }
    Maxguidecountoverride getMaxguidecountoverride() const { return Maxguidecountoverride(myMaxguidecountoverride); }
    void setMaxguidecountoverride(Maxguidecountoverride val) { myMaxguidecountoverride = int64(val); }
    Maxguidecountoverride opMaxguidecountoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxguidecountoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "maxguidecountoverride", cookparms.getCookTime(), 0);
        return Maxguidecountoverride(result);
    }
    const UT_StringHolder & getMaxguidecountattrib() const { return myMaxguidecountattrib; }
    void setMaxguidecountattrib(const UT_StringHolder & val) { myMaxguidecountattrib = val; }
    UT_StringHolder opMaxguidecountattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxguidecountattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "maxguidecountattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getMaxguidecounttexture() const { return myMaxguidecounttexture; }
    void setMaxguidecounttexture(const UT_StringHolder & val) { myMaxguidecounttexture = val; }
    UT_StringHolder opMaxguidecounttexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxguidecounttexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "maxguidecounttexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getMaxguideangle() const { return myMaxguideangle; }
    void setMaxguideangle(fpreal64 val) { myMaxguideangle = val; }
    fpreal64 opMaxguideangle(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxguideangle();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "maxguideangle", cookparms.getCookTime(), 0);
        return result;
    }
    Maxguideangleoverride getMaxguideangleoverride() const { return Maxguideangleoverride(myMaxguideangleoverride); }
    void setMaxguideangleoverride(Maxguideangleoverride val) { myMaxguideangleoverride = int64(val); }
    Maxguideangleoverride opMaxguideangleoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxguideangleoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "maxguideangleoverride", cookparms.getCookTime(), 0);
        return Maxguideangleoverride(result);
    }
    const UT_StringHolder & getMaxguideangleattrib() const { return myMaxguideangleattrib; }
    void setMaxguideangleattrib(const UT_StringHolder & val) { myMaxguideangleattrib = val; }
    UT_StringHolder opMaxguideangleattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxguideangleattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "maxguideangleattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getMaxguideangletexture() const { return myMaxguideangletexture; }
    void setMaxguideangletexture(const UT_StringHolder & val) { myMaxguideangletexture = val; }
    UT_StringHolder opMaxguideangletexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxguideangletexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "maxguideangletexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getClumpcrossover() const { return myClumpcrossover; }
    void setClumpcrossover(fpreal64 val) { myClumpcrossover = val; }
    fpreal64 opClumpcrossover(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpcrossover();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "clumpcrossover", cookparms.getCookTime(), 0);
        return result;
    }
    Clumpcrossoveroverride getClumpcrossoveroverride() const { return Clumpcrossoveroverride(myClumpcrossoveroverride); }
    void setClumpcrossoveroverride(Clumpcrossoveroverride val) { myClumpcrossoveroverride = int64(val); }
    Clumpcrossoveroverride opClumpcrossoveroverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpcrossoveroverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "clumpcrossoveroverride", cookparms.getCookTime(), 0);
        return Clumpcrossoveroverride(result);
    }
    const UT_StringHolder & getClumpcrossoverattrib() const { return myClumpcrossoverattrib; }
    void setClumpcrossoverattrib(const UT_StringHolder & val) { myClumpcrossoverattrib = val; }
    UT_StringHolder opClumpcrossoverattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpcrossoverattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "clumpcrossoverattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getClumpcrossovertexture() const { return myClumpcrossovertexture; }
    void setClumpcrossovertexture(const UT_StringHolder & val) { myClumpcrossovertexture = val; }
    UT_StringHolder opClumpcrossovertexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpcrossovertexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "clumpcrossovertexture", cookparms.getCookTime(), 0);
        return result;
    }
    bool getGrowunguided() const { return myGrowunguided; }
    void setGrowunguided(bool val) { myGrowunguided = val; }
    bool opGrowunguided(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGrowunguided();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "growunguided", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseinitdirattrib() const { return myUseinitdirattrib; }
    void setUseinitdirattrib(bool val) { myUseinitdirattrib = val; }
    bool opUseinitdirattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseinitdirattrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useinitdirattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getInitdirattrib() const { return myInitdirattrib; }
    void setInitdirattrib(const UT_StringHolder & val) { myInitdirattrib = val; }
    UT_StringHolder opInitdirattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInitdirattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "initdirattrib", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getUnguidedsegments() const { return myUnguidedsegments; }
    void setUnguidedsegments(int64 val) { myUnguidedsegments = val; }
    int64 opUnguidedsegments(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUnguidedsegments();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "unguidedsegments", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getUnguidedlength() const { return myUnguidedlength; }
    void setUnguidedlength(fpreal64 val) { myUnguidedlength = val; }
    fpreal64 opUnguidedlength(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUnguidedlength();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "unguidedlength", cookparms.getCookTime(), 0);
        return result;
    }
    Unguidedlengthoverride getUnguidedlengthoverride() const { return Unguidedlengthoverride(myUnguidedlengthoverride); }
    void setUnguidedlengthoverride(Unguidedlengthoverride val) { myUnguidedlengthoverride = int64(val); }
    Unguidedlengthoverride opUnguidedlengthoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUnguidedlengthoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "unguidedlengthoverride", cookparms.getCookTime(), 0);
        return Unguidedlengthoverride(result);
    }
    const UT_StringHolder & getUnguidedlengthattrib() const { return myUnguidedlengthattrib; }
    void setUnguidedlengthattrib(const UT_StringHolder & val) { myUnguidedlengthattrib = val; }
    UT_StringHolder opUnguidedlengthattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUnguidedlengthattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "unguidedlengthattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getUnguidedlengthtexture() const { return myUnguidedlengthtexture; }
    void setUnguidedlengthtexture(const UT_StringHolder & val) { myUnguidedlengthtexture = val; }
    UT_StringHolder opUnguidedlengthtexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUnguidedlengthtexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "unguidedlengthtexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getUnguidedminlength() const { return myUnguidedminlength; }
    void setUnguidedminlength(fpreal64 val) { myUnguidedminlength = val; }
    fpreal64 opUnguidedminlength(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUnguidedminlength();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "unguidedminlength", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCreateweightattribs() const { return myCreateweightattribs; }
    void setCreateweightattribs(bool val) { myCreateweightattribs = val; }
    bool opCreateweightattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCreateweightattribs();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "createweightattribs", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCreaterestrootattrib() const { return myCreaterestrootattrib; }
    void setCreaterestrootattrib(bool val) { myCreaterestrootattrib = val; }
    bool opCreaterestrootattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCreaterestrootattrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "createrestrootattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOutputthicknessattrib() const { return myOutputthicknessattrib; }
    void setOutputthicknessattrib(bool val) { myOutputthicknessattrib = val; }
    bool opOutputthicknessattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputthicknessattrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "outputthicknessattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getThicknessattrib() const { return myThicknessattrib; }
    void setThicknessattrib(const UT_StringHolder & val) { myThicknessattrib = val; }
    UT_StringHolder opThicknessattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getThicknessattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "thicknessattrib", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getThickness() const { return myThickness; }
    void setThickness(fpreal64 val) { myThickness = val; }
    fpreal64 opThickness(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getThickness();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "thickness", cookparms.getCookTime(), 0);
        return result;
    }
    Thicknessoverride getThicknessoverride() const { return Thicknessoverride(myThicknessoverride); }
    void setThicknessoverride(Thicknessoverride val) { myThicknessoverride = int64(val); }
    Thicknessoverride opThicknessoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getThicknessoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "thicknessoverride", cookparms.getCookTime(), 0);
        return Thicknessoverride(result);
    }
    const UT_StringHolder & getThicknessskinattrib() const { return myThicknessskinattrib; }
    void setThicknessskinattrib(const UT_StringHolder & val) { myThicknessskinattrib = val; }
    UT_StringHolder opThicknessskinattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getThicknessskinattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "thicknessskinattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getThicknesstexture() const { return myThicknesstexture; }
    void setThicknesstexture(const UT_StringHolder & val) { myThicknesstexture = val; }
    UT_StringHolder opThicknesstexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getThicknesstexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "thicknesstexture", cookparms.getCookTime(), 0);
        return result;
    }
    UT_SharedPtr<UT_Ramp> getHairprofile() const { return myHairprofile; }
    void setHairprofile(UT_SharedPtr<UT_Ramp> val) { myHairprofile = val; }
    UT_SharedPtr<UT_Ramp> opHairprofile(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getHairprofile();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "hairprofile", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPointattribs() const { return myPointattribs; }
    void setPointattribs(const UT_StringHolder & val) { myPointattribs = val; }
    UT_StringHolder opPointattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointattribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "pointattribs", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getVertattribs() const { return myVertattribs; }
    void setVertattribs(const UT_StringHolder & val) { myVertattribs = val; }
    UT_StringHolder opVertattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVertattribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "vertattribs", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPrimattribs() const { return myPrimattribs; }
    void setPrimattribs(const UT_StringHolder & val) { myPrimattribs = val; }
    UT_StringHolder opPrimattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimattribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primattribs", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getDetailattribs() const { return myDetailattribs; }
    void setDetailattribs(const UT_StringHolder & val) { myDetailattribs = val; }
    UT_StringHolder opDetailattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDetailattribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "detailattribs", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getGuidepointattribs() const { return myGuidepointattribs; }
    void setGuidepointattribs(const UT_StringHolder & val) { myGuidepointattribs = val; }
    UT_StringHolder opGuidepointattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGuidepointattribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "guidepointattribs", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getGuideprimattribs() const { return myGuideprimattribs; }
    void setGuideprimattribs(const UT_StringHolder & val) { myGuideprimattribs = val; }
    UT_StringHolder opGuideprimattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGuideprimattribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "guideprimattribs", cookparms.getCookTime(), 0);
        return result;
    }

private:
    int64 myMode;
    UT_StringHolder myGroup;
    UT_StringHolder myUvattrib;
    bool myLimittobbox;
    UT_Vector3D myBboxsize;
    UT_Vector3D myBboxcenter;
    bool myPrune;
    fpreal64 myPruningratio;
    bool myPrunethicken;
    bool myUseguides;
    bool myUniformguidesegments;
    bool mySkininterp;
    int64 myGuideblendmethod;
    UT_StringHolder myGuidegroup;
    fpreal64 myInfluenceradius;
    int64 myInfluenceradiusoverride;
    UT_StringHolder myInfluenceradiusattrib;
    UT_StringHolder myInfluenceradiustexture;
    fpreal64 myInfluencedecay;
    int64 myInfluencedecayoverride;
    UT_StringHolder myInfluencedecayattrib;
    UT_StringHolder myInfluencedecaytexture;
    int64 myMaxguidecount;
    int64 myMaxguidecountoverride;
    UT_StringHolder myMaxguidecountattrib;
    UT_StringHolder myMaxguidecounttexture;
    fpreal64 myMaxguideangle;
    int64 myMaxguideangleoverride;
    UT_StringHolder myMaxguideangleattrib;
    UT_StringHolder myMaxguideangletexture;
    fpreal64 myClumpcrossover;
    int64 myClumpcrossoveroverride;
    UT_StringHolder myClumpcrossoverattrib;
    UT_StringHolder myClumpcrossovertexture;
    bool myGrowunguided;
    bool myUseinitdirattrib;
    UT_StringHolder myInitdirattrib;
    int64 myUnguidedsegments;
    fpreal64 myUnguidedlength;
    int64 myUnguidedlengthoverride;
    UT_StringHolder myUnguidedlengthattrib;
    UT_StringHolder myUnguidedlengthtexture;
    fpreal64 myUnguidedminlength;
    bool myCreateweightattribs;
    bool myCreaterestrootattrib;
    bool myOutputthicknessattrib;
    UT_StringHolder myThicknessattrib;
    fpreal64 myThickness;
    int64 myThicknessoverride;
    UT_StringHolder myThicknessskinattrib;
    UT_StringHolder myThicknesstexture;
    UT_SharedPtr<UT_Ramp> myHairprofile;
    UT_StringHolder myPointattribs;
    UT_StringHolder myVertattribs;
    UT_StringHolder myPrimattribs;
    UT_StringHolder myDetailattribs;
    UT_StringHolder myGuidepointattribs;
    UT_StringHolder myGuideprimattribs;

};
