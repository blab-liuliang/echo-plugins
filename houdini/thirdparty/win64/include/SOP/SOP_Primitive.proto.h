/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_PrimitiveEnums
{
    enum class DoRot
    {
        OFF = 0,
        ON,
        MATCH
    };
    enum class Xord
    {
        SRT = 0,
        STR,
        RST,
        RTS,
        TSR,
        TRS
    };
    enum class Rord
    {
        XYZ = 0,
        XZY,
        YXZ,
        YZX,
        ZXY,
        ZYX
    };
    enum class Doclr
    {
        OFF = 0,
        ON,
        REMOVE
    };
    enum class Doalpha
    {
        OFF = 0,
        ON,
        REMOVE
    };
    enum class Docrease
    {
        OFF = 0,
        ON,
        REMOVE
    };
    enum class Dotexture
    {
        OFF = 0,
        ON,
        REMOVE
    };
    enum class Closeu
    {
        SAMECLOSURE = 0,
        OPEN,
        CLOSESHARP,
        CLOSEROUND,
        UNROLL
    };
    enum class Closev
    {
        SAMECLOSURE = 0,
        OPEN,
        CLOSESHARP,
        CLOSEROUND,
        UNROLL
    };
    enum class Clampu
    {
        SAMECLAMP = 0,
        CLAMP,
        UNCLAMP
    };
    enum class Clampv
    {
        SAMECLAMP = 0,
        CLAMP,
        UNCLAMP
    };
    enum class Vtxsort
    {
        SAMEVERTEX = 0,
        REVERSE,
        REVERSEU,
        REVERSEV,
        SWAPUV,
        SHIFT
    };
    enum class Prtype
    {
        SPHERE = 0,
        CIRCLE,
        LINE,
        TUBE,
        CAPPED,
        ROUNDED
    };
    enum class Volvis
    {
        SMOKE = 0,
        RAINBOW,
        ISO,
        INVISIBLE,
        HEIGHTFIELD
    };
    enum class Volborder
    {
        CONSTANT = 0,
        REPEAT,
        STREAK,
        SDF
    };
}


class SOP_API SOP_PrimitiveParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_PrimitiveParms()
    {
        myGroup = ""_sh;
        myDoXform = false;
        myDoRot = 0;
        myXord = 0;
        myRord = 0;
        myT = UT_Vector3D(0,0,0);
        myR = UT_Vector3D(0,0,0);
        myS = UT_Vector3D(1,1,1);
        myShear = UT_Vector3D(0,0,0);
        myP = UT_Vector3D(0,0,0);
        myPr = UT_Vector3D(0,0,0);
        myLookatpath = ""_sh;
        myUpvector = UT_Vector3D(0,0,0);
        myXformattribs = "N"_sh;
        myDoclr = 0;
        myDiff = UT_Vector3D(0,0,0);
        myDoalpha = 0;
        myAlpha = 0;
        myDocrease = 0;
        myCrease = 0;
        myDotexture = 0;
        myTexture = ""_sh;
        myCloseu = 0;
        myClosev = 0;
        myClampu = 0;
        myClampv = 0;
        myVtxsort = 0;
        myVtxuoff = 0;
        myVtxvoff = 0;
        myDoweight = false;
        myMetaweight = 0;
        myDoprender = false;
        myPrtype = 0;
        myPrsize = 0.05;
        myPrblur = 0;
        myDovolvis = false;
        myVolvis = 0;
        myVolvisiso = 0;
        myVolvisdensity = 1;
        myDotaper = false;
        myTaper = UT_Vector2D(1,1);
        myDovolume = false;
        myVolborder = 0;
        myVolborderval = 0;
        myDovoltol = false;
        myVoltol = 0;
        myDovdbclass = false;
        myVdbclass = 0;
        myDovdbcreator = false;
        myVdbcreator = ""_sh;
        myDovdbtransform = false;
        myVdbtransform = false;
        myDovdbvectype = false;
        myVdbvectype = 0;
        myDovdbhalf = false;
        myVdbhalf = false;
        myTemplategrp = ""_sh;
        myPshapeu = false;
        myPshapev = false;

    }

    explicit SOP_PrimitiveParms(const SOP_PrimitiveParms &) = default;

    virtual ~SOP_PrimitiveParms() {}

    bool operator==(const SOP_PrimitiveParms &src) const
    {
        if (myGroup != src.myGroup) return false;
        if (myDoXform != src.myDoXform) return false;
        if (myDoRot != src.myDoRot) return false;
        if (myXord != src.myXord) return false;
        if (myRord != src.myRord) return false;
        if (myT != src.myT) return false;
        if (myR != src.myR) return false;
        if (myS != src.myS) return false;
        if (myShear != src.myShear) return false;
        if (myP != src.myP) return false;
        if (myPr != src.myPr) return false;
        if (myLookatpath != src.myLookatpath) return false;
        if (myUpvector != src.myUpvector) return false;
        if (myXformattribs != src.myXformattribs) return false;
        if (myDoclr != src.myDoclr) return false;
        if (myDiff != src.myDiff) return false;
        if (myDoalpha != src.myDoalpha) return false;
        if (myAlpha != src.myAlpha) return false;
        if (myDocrease != src.myDocrease) return false;
        if (myCrease != src.myCrease) return false;
        if (myDotexture != src.myDotexture) return false;
        if (myTexture != src.myTexture) return false;
        if (myCloseu != src.myCloseu) return false;
        if (myClosev != src.myClosev) return false;
        if (myClampu != src.myClampu) return false;
        if (myClampv != src.myClampv) return false;
        if (myVtxsort != src.myVtxsort) return false;
        if (myVtxuoff != src.myVtxuoff) return false;
        if (myVtxvoff != src.myVtxvoff) return false;
        if (myDoweight != src.myDoweight) return false;
        if (myMetaweight != src.myMetaweight) return false;
        if (myDoprender != src.myDoprender) return false;
        if (myPrtype != src.myPrtype) return false;
        if (myPrsize != src.myPrsize) return false;
        if (myPrblur != src.myPrblur) return false;
        if (myDovolvis != src.myDovolvis) return false;
        if (myVolvis != src.myVolvis) return false;
        if (myVolvisiso != src.myVolvisiso) return false;
        if (myVolvisdensity != src.myVolvisdensity) return false;
        if (myDotaper != src.myDotaper) return false;
        if (myTaper != src.myTaper) return false;
        if (myDovolume != src.myDovolume) return false;
        if (myVolborder != src.myVolborder) return false;
        if (myVolborderval != src.myVolborderval) return false;
        if (myDovoltol != src.myDovoltol) return false;
        if (myVoltol != src.myVoltol) return false;
        if (myDovdbclass != src.myDovdbclass) return false;
        if (myVdbclass != src.myVdbclass) return false;
        if (myDovdbcreator != src.myDovdbcreator) return false;
        if (myVdbcreator != src.myVdbcreator) return false;
        if (myDovdbtransform != src.myDovdbtransform) return false;
        if (myVdbtransform != src.myVdbtransform) return false;
        if (myDovdbvectype != src.myDovdbvectype) return false;
        if (myVdbvectype != src.myVdbvectype) return false;
        if (myDovdbhalf != src.myDovdbhalf) return false;
        if (myVdbhalf != src.myVdbhalf) return false;
        if (myTemplategrp != src.myTemplategrp) return false;
        if (myPshapeu != src.myPshapeu) return false;
        if (myPshapev != src.myPshapev) return false;

        return true;
    }
    bool operator!=(const SOP_PrimitiveParms &src) const
    {
        return !operator==(src);
    }
    using DoRot = SOP_PrimitiveEnums::DoRot;
    using Xord = SOP_PrimitiveEnums::Xord;
    using Rord = SOP_PrimitiveEnums::Rord;
    using Doclr = SOP_PrimitiveEnums::Doclr;
    using Doalpha = SOP_PrimitiveEnums::Doalpha;
    using Docrease = SOP_PrimitiveEnums::Docrease;
    using Dotexture = SOP_PrimitiveEnums::Dotexture;
    using Closeu = SOP_PrimitiveEnums::Closeu;
    using Closev = SOP_PrimitiveEnums::Closev;
    using Clampu = SOP_PrimitiveEnums::Clampu;
    using Clampv = SOP_PrimitiveEnums::Clampv;
    using Vtxsort = SOP_PrimitiveEnums::Vtxsort;
    using Prtype = SOP_PrimitiveEnums::Prtype;
    using Volvis = SOP_PrimitiveEnums::Volvis;
    using Volborder = SOP_PrimitiveEnums::Volborder;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myGroup, node, "group", time, 0);
        else myGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myDoXform, node, "doxform", time, 0);
        else myDoXform = false;
        if (true && ( (!((((node->getInput(1)!=0)==0))||((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myDoRot, node, "dorot", time, 0);
        else myDoRot = 0;
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myXord, node, "xOrd", time, 0);
        else myXord = 0;
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myRord, node, "rOrd", time, 0);
        else myRord = 0;
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myT, node, "t", time, 0);
        else myT = UT_Vector3D(0,0,0);
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myR, node, "r", time, 0);
        else myR = UT_Vector3D(0,0,0);
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myS, node, "s", time, 0);
        else myS = UT_Vector3D(1,1,1);
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myShear, node, "shear", time, 0);
        else myShear = UT_Vector3D(0,0,0);
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myP, node, "p", time, 0);
        else myP = UT_Vector3D(0,0,0);
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myPr, node, "pr", time, 0);
        else myPr = UT_Vector3D(0,0,0);
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myLookatpath, node, "lookatpath", time, 0);
        else myLookatpath = ""_sh;
        if (true && ( (!(((getDoXform()==0))||((getLookatpath()=="")))) ) )
            OP_Utils::evalOpParm(myUpvector, node, "upvector", time, 0);
        else myUpvector = UT_Vector3D(0,0,0);
        if (true && ( (!(((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myXformattribs, node, "xformattribs", time, 0);
        else myXformattribs = "N"_sh;
        if (true)
            OP_Utils::evalOpParm(myDoclr, node, "doclr", time, 0);
        else myDoclr = 0;
        if (true && ( (!(((int64(getDoclr())!=1)))) ) )
            OP_Utils::evalOpParm(myDiff, node, "diff", time, 0);
        else myDiff = UT_Vector3D(0,0,0);
        if (true)
            OP_Utils::evalOpParm(myDoalpha, node, "doalpha", time, 0);
        else myDoalpha = 0;
        if (true && ( (!(((int64(getDoalpha())!=1)))) ) )
            OP_Utils::evalOpParm(myAlpha, node, "alpha", time, 0);
        else myAlpha = 0;
        if (true)
            OP_Utils::evalOpParm(myDocrease, node, "docrease", time, 0);
        else myDocrease = 0;
        if (true && ( (!(((int64(getDocrease())!=1)))) ) )
            OP_Utils::evalOpParm(myCrease, node, "crease", time, 0);
        else myCrease = 0;
        if (true)
            OP_Utils::evalOpParm(myDotexture, node, "dotexture", time, 0);
        else myDotexture = 0;
        if (true && ( (!(((int64(getDotexture())!=1)))) ) )
            OP_Utils::evalOpParm(myTexture, node, "texture", time, 0);
        else myTexture = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myCloseu, node, "closeu", time, 0);
        else myCloseu = 0;
        if (true)
            OP_Utils::evalOpParm(myClosev, node, "closev", time, 0);
        else myClosev = 0;
        if (true)
            OP_Utils::evalOpParm(myClampu, node, "clampu", time, 0);
        else myClampu = 0;
        if (true)
            OP_Utils::evalOpParm(myClampv, node, "clampv", time, 0);
        else myClampv = 0;
        if (true)
            OP_Utils::evalOpParm(myVtxsort, node, "vtxsort", time, 0);
        else myVtxsort = 0;
        if (true && ( (!(((int64(getVtxsort())!=5)))) ) )
            OP_Utils::evalOpParm(myVtxuoff, node, "vtxuoff", time, 0);
        else myVtxuoff = 0;
        if (true && ( (!(((int64(getVtxsort())!=5)))) ) )
            OP_Utils::evalOpParm(myVtxvoff, node, "vtxvoff", time, 0);
        else myVtxvoff = 0;
        if (true)
            OP_Utils::evalOpParm(myDoweight, node, "doweight", time, 0);
        else myDoweight = false;
        if (true && ( (!(((getDoweight()==0)))) ) )
            OP_Utils::evalOpParm(myMetaweight, node, "metaweight", time, 0);
        else myMetaweight = 0;
        if (true)
            OP_Utils::evalOpParm(myDoprender, node, "doprender", time, 0);
        else myDoprender = false;
        if (true && ( (!(((getDoprender()==0)))) ) )
            OP_Utils::evalOpParm(myPrtype, node, "prtype", time, 0);
        else myPrtype = 0;
        if (true && ( (!(((getDoprender()==0)))) ) )
            OP_Utils::evalOpParm(myPrsize, node, "prsize", time, 0);
        else myPrsize = 0.05;
        if (true && ( (!(((getDoprender()==0)))) ) )
            OP_Utils::evalOpParm(myPrblur, node, "prblur", time, 0);
        else myPrblur = 0;
        if (true)
            OP_Utils::evalOpParm(myDovolvis, node, "dovolvis", time, 0);
        else myDovolvis = false;
        if (true && ( (!(((getDovolvis()==0)))) ) )
            OP_Utils::evalOpParm(myVolvis, node, "volvis", time, 0);
        else myVolvis = 0;
        if (true && ( (!(((getDovolvis()==0)))) ) )
            OP_Utils::evalOpParm(myVolvisiso, node, "volvisiso", time, 0);
        else myVolvisiso = 0;
        if (true && ( (!(((getDovolvis()==0)))) ) )
            OP_Utils::evalOpParm(myVolvisdensity, node, "volvisdensity", time, 0);
        else myVolvisdensity = 1;
        if (true)
            OP_Utils::evalOpParm(myDotaper, node, "dotaper", time, 0);
        else myDotaper = false;
        if (true && ( (!(((getDotaper()==0)))) ) )
            OP_Utils::evalOpParm(myTaper, node, "taper", time, 0);
        else myTaper = UT_Vector2D(1,1);
        if (true)
            OP_Utils::evalOpParm(myDovolume, node, "dovolume", time, 0);
        else myDovolume = false;
        if (true && ( (!(((getDovolume()==0)))) ) )
            OP_Utils::evalOpParm(myVolborder, node, "volborder", time, 0);
        else myVolborder = 0;
        if (true && ( (!(((getDovolume()==0)))) ) )
            OP_Utils::evalOpParm(myVolborderval, node, "volborderval", time, 0);
        else myVolborderval = 0;
        if (true)
            OP_Utils::evalOpParm(myDovoltol, node, "dovoltol", time, 0);
        else myDovoltol = false;
        if (true && ( (!(((getDovoltol()==0)))) ) )
            OP_Utils::evalOpParm(myVoltol, node, "voltol", time, 0);
        else myVoltol = 0;
        if (true)
            OP_Utils::evalOpParm(myDovdbclass, node, "dovdbclass", time, 0);
        else myDovdbclass = false;
        if (true && ( (!(((getDovdbclass()==0)))) ) )
            OP_Utils::evalOpParm(myVdbclass, node, "vdbclass", time, 0);
        else myVdbclass = 0;
        if (true)
            OP_Utils::evalOpParm(myDovdbcreator, node, "dovdbcreator", time, 0);
        else myDovdbcreator = false;
        if (true && ( (!(((getDovdbcreator()==0)))) ) )
            OP_Utils::evalOpParm(myVdbcreator, node, "vdbcreator", time, 0);
        else myVdbcreator = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myDovdbtransform, node, "dovdbtransform", time, 0);
        else myDovdbtransform = false;
        if (true && ( (!(((getDovdbtransform()==0)))) ) )
            OP_Utils::evalOpParm(myVdbtransform, node, "vdbtransform", time, 0);
        else myVdbtransform = false;
        if (true)
            OP_Utils::evalOpParm(myDovdbvectype, node, "dovdbvectype", time, 0);
        else myDovdbvectype = false;
        if (true && ( (!(((getDovdbvectype()==0)))) ) )
            OP_Utils::evalOpParm(myVdbvectype, node, "vdbvectype", time, 0);
        else myVdbvectype = 0;
        if (true)
            OP_Utils::evalOpParm(myDovdbhalf, node, "dovdbhalf", time, 0);
        else myDovdbhalf = false;
        if (true && ( (!(((getDovdbhalf()==0)))) ) )
            OP_Utils::evalOpParm(myVdbhalf, node, "vdbhalf", time, 0);
        else myVdbhalf = false;
        if (true && ( (!((((node->getInput(1)!=0)==0))||((getDoXform()==0)))) ) )
            OP_Utils::evalOpParm(myTemplategrp, node, "templateGrp", time, 0);
        else myTemplategrp = ""_sh;
        if (true && ( (!(((int64(getCloseu())==0)&&(int64(getClampu())==0)))) ) )
            OP_Utils::evalOpParm(myPshapeu, node, "pshapeu", time, 0);
        else myPshapeu = false;
        if (true && ( (!(((int64(getClosev())==0)&&(int64(getClampv())==0)))) ) )
            OP_Utils::evalOpParm(myPshapev, node, "pshapev", time, 0);
        else myPshapev = false;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_PrimitiveParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myGroup);
                break;
            case 1:
                coerceValue(value, myDoXform);
                break;
            case 2:
                coerceValue(value, myDoRot);
                break;
            case 3:
                coerceValue(value, myXord);
                break;
            case 4:
                coerceValue(value, myRord);
                break;
            case 5:
                coerceValue(value, myT);
                break;
            case 6:
                coerceValue(value, myR);
                break;
            case 7:
                coerceValue(value, myS);
                break;
            case 8:
                coerceValue(value, myShear);
                break;
            case 9:
                coerceValue(value, myP);
                break;
            case 10:
                coerceValue(value, myPr);
                break;
            case 11:
                coerceValue(value, myLookatpath);
                break;
            case 12:
                coerceValue(value, myUpvector);
                break;
            case 13:
                coerceValue(value, myXformattribs);
                break;
            case 14:
                coerceValue(value, myDoclr);
                break;
            case 15:
                coerceValue(value, myDiff);
                break;
            case 16:
                coerceValue(value, myDoalpha);
                break;
            case 17:
                coerceValue(value, myAlpha);
                break;
            case 18:
                coerceValue(value, myDocrease);
                break;
            case 19:
                coerceValue(value, myCrease);
                break;
            case 20:
                coerceValue(value, myDotexture);
                break;
            case 21:
                coerceValue(value, myTexture);
                break;
            case 22:
                coerceValue(value, myCloseu);
                break;
            case 23:
                coerceValue(value, myClosev);
                break;
            case 24:
                coerceValue(value, myClampu);
                break;
            case 25:
                coerceValue(value, myClampv);
                break;
            case 26:
                coerceValue(value, myVtxsort);
                break;
            case 27:
                coerceValue(value, myVtxuoff);
                break;
            case 28:
                coerceValue(value, myVtxvoff);
                break;
            case 29:
                coerceValue(value, myDoweight);
                break;
            case 30:
                coerceValue(value, myMetaweight);
                break;
            case 31:
                coerceValue(value, myDoprender);
                break;
            case 32:
                coerceValue(value, myPrtype);
                break;
            case 33:
                coerceValue(value, myPrsize);
                break;
            case 34:
                coerceValue(value, myPrblur);
                break;
            case 35:
                coerceValue(value, myDovolvis);
                break;
            case 36:
                coerceValue(value, myVolvis);
                break;
            case 37:
                coerceValue(value, myVolvisiso);
                break;
            case 38:
                coerceValue(value, myVolvisdensity);
                break;
            case 39:
                coerceValue(value, myDotaper);
                break;
            case 40:
                coerceValue(value, myTaper);
                break;
            case 41:
                coerceValue(value, myDovolume);
                break;
            case 42:
                coerceValue(value, myVolborder);
                break;
            case 43:
                coerceValue(value, myVolborderval);
                break;
            case 44:
                coerceValue(value, myDovoltol);
                break;
            case 45:
                coerceValue(value, myVoltol);
                break;
            case 46:
                coerceValue(value, myDovdbclass);
                break;
            case 47:
                coerceValue(value, myVdbclass);
                break;
            case 48:
                coerceValue(value, myDovdbcreator);
                break;
            case 49:
                coerceValue(value, myVdbcreator);
                break;
            case 50:
                coerceValue(value, myDovdbtransform);
                break;
            case 51:
                coerceValue(value, myVdbtransform);
                break;
            case 52:
                coerceValue(value, myDovdbvectype);
                break;
            case 53:
                coerceValue(value, myVdbvectype);
                break;
            case 54:
                coerceValue(value, myDovdbhalf);
                break;
            case 55:
                coerceValue(value, myVdbhalf);
                break;
            case 56:
                coerceValue(value, myTemplategrp);
                break;
            case 57:
                coerceValue(value, myPshapeu);
                break;
            case 58:
                coerceValue(value, myPshapev);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myGroup, value);
                break;
            case 1:
                coerceValue(myDoXform, value);
                break;
            case 2:
                coerceValue(myDoRot, value);
                break;
            case 3:
                coerceValue(myXord, value);
                break;
            case 4:
                coerceValue(myRord, value);
                break;
            case 5:
                coerceValue(myT, value);
                break;
            case 6:
                coerceValue(myR, value);
                break;
            case 7:
                coerceValue(myS, value);
                break;
            case 8:
                coerceValue(myShear, value);
                break;
            case 9:
                coerceValue(myP, value);
                break;
            case 10:
                coerceValue(myPr, value);
                break;
            case 11:
                coerceValue(myLookatpath, value);
                break;
            case 12:
                coerceValue(myUpvector, value);
                break;
            case 13:
                coerceValue(myXformattribs, value);
                break;
            case 14:
                coerceValue(myDoclr, value);
                break;
            case 15:
                coerceValue(myDiff, value);
                break;
            case 16:
                coerceValue(myDoalpha, value);
                break;
            case 17:
                coerceValue(myAlpha, value);
                break;
            case 18:
                coerceValue(myDocrease, value);
                break;
            case 19:
                coerceValue(myCrease, value);
                break;
            case 20:
                coerceValue(myDotexture, value);
                break;
            case 21:
                coerceValue(myTexture, value);
                break;
            case 22:
                coerceValue(myCloseu, value);
                break;
            case 23:
                coerceValue(myClosev, value);
                break;
            case 24:
                coerceValue(myClampu, value);
                break;
            case 25:
                coerceValue(myClampv, value);
                break;
            case 26:
                coerceValue(myVtxsort, value);
                break;
            case 27:
                coerceValue(myVtxuoff, value);
                break;
            case 28:
                coerceValue(myVtxvoff, value);
                break;
            case 29:
                coerceValue(myDoweight, value);
                break;
            case 30:
                coerceValue(myMetaweight, value);
                break;
            case 31:
                coerceValue(myDoprender, value);
                break;
            case 32:
                coerceValue(myPrtype, value);
                break;
            case 33:
                coerceValue(myPrsize, value);
                break;
            case 34:
                coerceValue(myPrblur, value);
                break;
            case 35:
                coerceValue(myDovolvis, value);
                break;
            case 36:
                coerceValue(myVolvis, value);
                break;
            case 37:
                coerceValue(myVolvisiso, value);
                break;
            case 38:
                coerceValue(myVolvisdensity, value);
                break;
            case 39:
                coerceValue(myDotaper, value);
                break;
            case 40:
                coerceValue(myTaper, value);
                break;
            case 41:
                coerceValue(myDovolume, value);
                break;
            case 42:
                coerceValue(myVolborder, value);
                break;
            case 43:
                coerceValue(myVolborderval, value);
                break;
            case 44:
                coerceValue(myDovoltol, value);
                break;
            case 45:
                coerceValue(myVoltol, value);
                break;
            case 46:
                coerceValue(myDovdbclass, value);
                break;
            case 47:
                coerceValue(myVdbclass, value);
                break;
            case 48:
                coerceValue(myDovdbcreator, value);
                break;
            case 49:
                coerceValue(myVdbcreator, value);
                break;
            case 50:
                coerceValue(myDovdbtransform, value);
                break;
            case 51:
                coerceValue(myVdbtransform, value);
                break;
            case 52:
                coerceValue(myDovdbvectype, value);
                break;
            case 53:
                coerceValue(myVdbvectype, value);
                break;
            case 54:
                coerceValue(myDovdbhalf, value);
                break;
            case 55:
                coerceValue(myVdbhalf, value);
                break;
            case 56:
                coerceValue(myTemplategrp, value);
                break;
            case 57:
                coerceValue(myPshapeu, value);
                break;
            case 58:
                coerceValue(myPshapev, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 59;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "group";
            case 1:
                return "doxform";
            case 2:
                return "dorot";
            case 3:
                return "xOrd";
            case 4:
                return "rOrd";
            case 5:
                return "t";
            case 6:
                return "r";
            case 7:
                return "s";
            case 8:
                return "shear";
            case 9:
                return "p";
            case 10:
                return "pr";
            case 11:
                return "lookatpath";
            case 12:
                return "upvector";
            case 13:
                return "xformattribs";
            case 14:
                return "doclr";
            case 15:
                return "diff";
            case 16:
                return "doalpha";
            case 17:
                return "alpha";
            case 18:
                return "docrease";
            case 19:
                return "crease";
            case 20:
                return "dotexture";
            case 21:
                return "texture";
            case 22:
                return "closeu";
            case 23:
                return "closev";
            case 24:
                return "clampu";
            case 25:
                return "clampv";
            case 26:
                return "vtxsort";
            case 27:
                return "vtxuoff";
            case 28:
                return "vtxvoff";
            case 29:
                return "doweight";
            case 30:
                return "metaweight";
            case 31:
                return "doprender";
            case 32:
                return "prtype";
            case 33:
                return "prsize";
            case 34:
                return "prblur";
            case 35:
                return "dovolvis";
            case 36:
                return "volvis";
            case 37:
                return "volvisiso";
            case 38:
                return "volvisdensity";
            case 39:
                return "dotaper";
            case 40:
                return "taper";
            case 41:
                return "dovolume";
            case 42:
                return "volborder";
            case 43:
                return "volborderval";
            case 44:
                return "dovoltol";
            case 45:
                return "voltol";
            case 46:
                return "dovdbclass";
            case 47:
                return "vdbclass";
            case 48:
                return "dovdbcreator";
            case 49:
                return "vdbcreator";
            case 50:
                return "dovdbtransform";
            case 51:
                return "vdbtransform";
            case 52:
                return "dovdbvectype";
            case 53:
                return "vdbvectype";
            case 54:
                return "dovdbhalf";
            case 55:
                return "vdbhalf";
            case 56:
                return "templateGrp";
            case 57:
                return "pshapeu";
            case 58:
                return "pshapev";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_INTEGER;
                case 3:
                    return PARM_INTEGER;
                case 4:
                    return PARM_INTEGER;
                case 5:
                    return PARM_VECTOR3;
                case 6:
                    return PARM_VECTOR3;
                case 7:
                    return PARM_VECTOR3;
                case 8:
                    return PARM_VECTOR3;
                case 9:
                    return PARM_VECTOR3;
                case 10:
                    return PARM_VECTOR3;
                case 11:
                    return PARM_STRING;
                case 12:
                    return PARM_VECTOR3;
                case 13:
                    return PARM_STRING;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_VECTOR3;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_FLOAT;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_FLOAT;
                case 20:
                    return PARM_INTEGER;
                case 21:
                    return PARM_STRING;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_INTEGER;
                case 24:
                    return PARM_INTEGER;
                case 25:
                    return PARM_INTEGER;
                case 26:
                    return PARM_INTEGER;
                case 27:
                    return PARM_INTEGER;
                case 28:
                    return PARM_INTEGER;
                case 29:
                    return PARM_INTEGER;
                case 30:
                    return PARM_FLOAT;
                case 31:
                    return PARM_INTEGER;
                case 32:
                    return PARM_INTEGER;
                case 33:
                    return PARM_FLOAT;
                case 34:
                    return PARM_FLOAT;
                case 35:
                    return PARM_INTEGER;
                case 36:
                    return PARM_INTEGER;
                case 37:
                    return PARM_FLOAT;
                case 38:
                    return PARM_FLOAT;
                case 39:
                    return PARM_INTEGER;
                case 40:
                    return PARM_VECTOR2;
                case 41:
                    return PARM_INTEGER;
                case 42:
                    return PARM_INTEGER;
                case 43:
                    return PARM_FLOAT;
                case 44:
                    return PARM_INTEGER;
                case 45:
                    return PARM_FLOAT;
                case 46:
                    return PARM_INTEGER;
                case 47:
                    return PARM_INTEGER;
                case 48:
                    return PARM_INTEGER;
                case 49:
                    return PARM_STRING;
                case 50:
                    return PARM_INTEGER;
                case 51:
                    return PARM_INTEGER;
                case 52:
                    return PARM_INTEGER;
                case 53:
                    return PARM_INTEGER;
                case 54:
                    return PARM_INTEGER;
                case 55:
                    return PARM_INTEGER;
                case 56:
                    return PARM_STRING;
                case 57:
                    return PARM_INTEGER;
                case 58:
                    return PARM_INTEGER;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myGroup);
        saveData(os, myDoXform);
        saveData(os, myDoRot);
        saveData(os, myXord);
        saveData(os, myRord);
        saveData(os, myT);
        saveData(os, myR);
        saveData(os, myS);
        saveData(os, myShear);
        saveData(os, myP);
        saveData(os, myPr);
        saveData(os, myLookatpath);
        saveData(os, myUpvector);
        saveData(os, myXformattribs);
        saveData(os, myDoclr);
        saveData(os, myDiff);
        saveData(os, myDoalpha);
        saveData(os, myAlpha);
        saveData(os, myDocrease);
        saveData(os, myCrease);
        saveData(os, myDotexture);
        saveData(os, myTexture);
        saveData(os, myCloseu);
        saveData(os, myClosev);
        saveData(os, myClampu);
        saveData(os, myClampv);
        saveData(os, myVtxsort);
        saveData(os, myVtxuoff);
        saveData(os, myVtxvoff);
        saveData(os, myDoweight);
        saveData(os, myMetaweight);
        saveData(os, myDoprender);
        saveData(os, myPrtype);
        saveData(os, myPrsize);
        saveData(os, myPrblur);
        saveData(os, myDovolvis);
        saveData(os, myVolvis);
        saveData(os, myVolvisiso);
        saveData(os, myVolvisdensity);
        saveData(os, myDotaper);
        saveData(os, myTaper);
        saveData(os, myDovolume);
        saveData(os, myVolborder);
        saveData(os, myVolborderval);
        saveData(os, myDovoltol);
        saveData(os, myVoltol);
        saveData(os, myDovdbclass);
        saveData(os, myVdbclass);
        saveData(os, myDovdbcreator);
        saveData(os, myVdbcreator);
        saveData(os, myDovdbtransform);
        saveData(os, myVdbtransform);
        saveData(os, myDovdbvectype);
        saveData(os, myVdbvectype);
        saveData(os, myDovdbhalf);
        saveData(os, myVdbhalf);
        saveData(os, myTemplategrp);
        saveData(os, myPshapeu);
        saveData(os, myPshapev);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myGroup);
        loadData(is, myDoXform);
        loadData(is, myDoRot);
        loadData(is, myXord);
        loadData(is, myRord);
        loadData(is, myT);
        loadData(is, myR);
        loadData(is, myS);
        loadData(is, myShear);
        loadData(is, myP);
        loadData(is, myPr);
        loadData(is, myLookatpath);
        loadData(is, myUpvector);
        loadData(is, myXformattribs);
        loadData(is, myDoclr);
        loadData(is, myDiff);
        loadData(is, myDoalpha);
        loadData(is, myAlpha);
        loadData(is, myDocrease);
        loadData(is, myCrease);
        loadData(is, myDotexture);
        loadData(is, myTexture);
        loadData(is, myCloseu);
        loadData(is, myClosev);
        loadData(is, myClampu);
        loadData(is, myClampv);
        loadData(is, myVtxsort);
        loadData(is, myVtxuoff);
        loadData(is, myVtxvoff);
        loadData(is, myDoweight);
        loadData(is, myMetaweight);
        loadData(is, myDoprender);
        loadData(is, myPrtype);
        loadData(is, myPrsize);
        loadData(is, myPrblur);
        loadData(is, myDovolvis);
        loadData(is, myVolvis);
        loadData(is, myVolvisiso);
        loadData(is, myVolvisdensity);
        loadData(is, myDotaper);
        loadData(is, myTaper);
        loadData(is, myDovolume);
        loadData(is, myVolborder);
        loadData(is, myVolborderval);
        loadData(is, myDovoltol);
        loadData(is, myVoltol);
        loadData(is, myDovdbclass);
        loadData(is, myVdbclass);
        loadData(is, myDovdbcreator);
        loadData(is, myVdbcreator);
        loadData(is, myDovdbtransform);
        loadData(is, myVdbtransform);
        loadData(is, myDovdbvectype);
        loadData(is, myVdbvectype);
        loadData(is, myDovdbhalf);
        loadData(is, myVdbhalf);
        loadData(is, myTemplategrp);
        loadData(is, myPshapeu);
        loadData(is, myPshapev);

        return true;
    }

    const UT_StringHolder & getGroup() const { return myGroup; }
    void setGroup(const UT_StringHolder & val) { myGroup = val; }
    UT_StringHolder opGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "group", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDoXform() const { return myDoXform; }
    void setDoXform(bool val) { myDoXform = val; }
    bool opDoXform(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoXform();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "doxform", cookparms.getCookTime(), 0);
        return result;
    }
    DoRot getDoRot() const { return DoRot(myDoRot); }
    void setDoRot(DoRot val) { myDoRot = int64(val); }
    DoRot opDoRot(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoRot();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "dorot", cookparms.getCookTime(), 0);
        return DoRot(result);
    }
    Xord getXord() const { return Xord(myXord); }
    void setXord(Xord val) { myXord = int64(val); }
    Xord opXord(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getXord();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "xOrd", cookparms.getCookTime(), 0);
        return Xord(result);
    }
    Rord getRord() const { return Rord(myRord); }
    void setRord(Rord val) { myRord = int64(val); }
    Rord opRord(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRord();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "rOrd", cookparms.getCookTime(), 0);
        return Rord(result);
    }
    UT_Vector3D getT() const { return myT; }
    void setT(UT_Vector3D val) { myT = val; }
    UT_Vector3D opT(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getT();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "t", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getR() const { return myR; }
    void setR(UT_Vector3D val) { myR = val; }
    UT_Vector3D opR(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getR();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "r", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getS() const { return myS; }
    void setS(UT_Vector3D val) { myS = val; }
    UT_Vector3D opS(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getS();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "s", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getShear() const { return myShear; }
    void setShear(UT_Vector3D val) { myShear = val; }
    UT_Vector3D opShear(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getShear();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "shear", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getP() const { return myP; }
    void setP(UT_Vector3D val) { myP = val; }
    UT_Vector3D opP(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getP();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "p", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getPr() const { return myPr; }
    void setPr(UT_Vector3D val) { myPr = val; }
    UT_Vector3D opPr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPr();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "pr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getLookatpath() const { return myLookatpath; }
    void setLookatpath(const UT_StringHolder & val) { myLookatpath = val; }
    UT_StringHolder opLookatpath(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLookatpath();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "lookatpath", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getUpvector() const { return myUpvector; }
    void setUpvector(UT_Vector3D val) { myUpvector = val; }
    UT_Vector3D opUpvector(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUpvector();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "upvector", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getXformattribs() const { return myXformattribs; }
    void setXformattribs(const UT_StringHolder & val) { myXformattribs = val; }
    UT_StringHolder opXformattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getXformattribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "xformattribs", cookparms.getCookTime(), 0);
        return result;
    }
    Doclr getDoclr() const { return Doclr(myDoclr); }
    void setDoclr(Doclr val) { myDoclr = int64(val); }
    Doclr opDoclr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoclr();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "doclr", cookparms.getCookTime(), 0);
        return Doclr(result);
    }
    UT_Vector3D getDiff() const { return myDiff; }
    void setDiff(UT_Vector3D val) { myDiff = val; }
    UT_Vector3D opDiff(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDiff();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "diff", cookparms.getCookTime(), 0);
        return result;
    }
    Doalpha getDoalpha() const { return Doalpha(myDoalpha); }
    void setDoalpha(Doalpha val) { myDoalpha = int64(val); }
    Doalpha opDoalpha(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoalpha();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "doalpha", cookparms.getCookTime(), 0);
        return Doalpha(result);
    }
    fpreal64 getAlpha() const { return myAlpha; }
    void setAlpha(fpreal64 val) { myAlpha = val; }
    fpreal64 opAlpha(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAlpha();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "alpha", cookparms.getCookTime(), 0);
        return result;
    }
    Docrease getDocrease() const { return Docrease(myDocrease); }
    void setDocrease(Docrease val) { myDocrease = int64(val); }
    Docrease opDocrease(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDocrease();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "docrease", cookparms.getCookTime(), 0);
        return Docrease(result);
    }
    fpreal64 getCrease() const { return myCrease; }
    void setCrease(fpreal64 val) { myCrease = val; }
    fpreal64 opCrease(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCrease();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "crease", cookparms.getCookTime(), 0);
        return result;
    }
    Dotexture getDotexture() const { return Dotexture(myDotexture); }
    void setDotexture(Dotexture val) { myDotexture = int64(val); }
    Dotexture opDotexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDotexture();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "dotexture", cookparms.getCookTime(), 0);
        return Dotexture(result);
    }
    const UT_StringHolder & getTexture() const { return myTexture; }
    void setTexture(const UT_StringHolder & val) { myTexture = val; }
    UT_StringHolder opTexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "texture", cookparms.getCookTime(), 0);
        return result;
    }
    Closeu getCloseu() const { return Closeu(myCloseu); }
    void setCloseu(Closeu val) { myCloseu = int64(val); }
    Closeu opCloseu(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCloseu();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "closeu", cookparms.getCookTime(), 0);
        return Closeu(result);
    }
    Closev getClosev() const { return Closev(myClosev); }
    void setClosev(Closev val) { myClosev = int64(val); }
    Closev opClosev(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClosev();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "closev", cookparms.getCookTime(), 0);
        return Closev(result);
    }
    Clampu getClampu() const { return Clampu(myClampu); }
    void setClampu(Clampu val) { myClampu = int64(val); }
    Clampu opClampu(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClampu();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "clampu", cookparms.getCookTime(), 0);
        return Clampu(result);
    }
    Clampv getClampv() const { return Clampv(myClampv); }
    void setClampv(Clampv val) { myClampv = int64(val); }
    Clampv opClampv(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClampv();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "clampv", cookparms.getCookTime(), 0);
        return Clampv(result);
    }
    Vtxsort getVtxsort() const { return Vtxsort(myVtxsort); }
    void setVtxsort(Vtxsort val) { myVtxsort = int64(val); }
    Vtxsort opVtxsort(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVtxsort();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "vtxsort", cookparms.getCookTime(), 0);
        return Vtxsort(result);
    }
    int64 getVtxuoff() const { return myVtxuoff; }
    void setVtxuoff(int64 val) { myVtxuoff = val; }
    int64 opVtxuoff(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVtxuoff();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "vtxuoff", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getVtxvoff() const { return myVtxvoff; }
    void setVtxvoff(int64 val) { myVtxvoff = val; }
    int64 opVtxvoff(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVtxvoff();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "vtxvoff", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDoweight() const { return myDoweight; }
    void setDoweight(bool val) { myDoweight = val; }
    bool opDoweight(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoweight();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "doweight", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getMetaweight() const { return myMetaweight; }
    void setMetaweight(fpreal64 val) { myMetaweight = val; }
    fpreal64 opMetaweight(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMetaweight();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "metaweight", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDoprender() const { return myDoprender; }
    void setDoprender(bool val) { myDoprender = val; }
    bool opDoprender(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDoprender();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "doprender", cookparms.getCookTime(), 0);
        return result;
    }
    Prtype getPrtype() const { return Prtype(myPrtype); }
    void setPrtype(Prtype val) { myPrtype = int64(val); }
    Prtype opPrtype(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrtype();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "prtype", cookparms.getCookTime(), 0);
        return Prtype(result);
    }
    fpreal64 getPrsize() const { return myPrsize; }
    void setPrsize(fpreal64 val) { myPrsize = val; }
    fpreal64 opPrsize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrsize();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "prsize", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getPrblur() const { return myPrblur; }
    void setPrblur(fpreal64 val) { myPrblur = val; }
    fpreal64 opPrblur(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrblur();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "prblur", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDovolvis() const { return myDovolvis; }
    void setDovolvis(bool val) { myDovolvis = val; }
    bool opDovolvis(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDovolvis();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dovolvis", cookparms.getCookTime(), 0);
        return result;
    }
    Volvis getVolvis() const { return Volvis(myVolvis); }
    void setVolvis(Volvis val) { myVolvis = int64(val); }
    Volvis opVolvis(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVolvis();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "volvis", cookparms.getCookTime(), 0);
        return Volvis(result);
    }
    fpreal64 getVolvisiso() const { return myVolvisiso; }
    void setVolvisiso(fpreal64 val) { myVolvisiso = val; }
    fpreal64 opVolvisiso(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVolvisiso();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "volvisiso", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getVolvisdensity() const { return myVolvisdensity; }
    void setVolvisdensity(fpreal64 val) { myVolvisdensity = val; }
    fpreal64 opVolvisdensity(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVolvisdensity();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "volvisdensity", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDotaper() const { return myDotaper; }
    void setDotaper(bool val) { myDotaper = val; }
    bool opDotaper(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDotaper();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dotaper", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector2D getTaper() const { return myTaper; }
    void setTaper(UT_Vector2D val) { myTaper = val; }
    UT_Vector2D opTaper(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTaper();
        UT_Vector2D result;
        OP_Utils::evalOpParm(result, thissop, "taper", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDovolume() const { return myDovolume; }
    void setDovolume(bool val) { myDovolume = val; }
    bool opDovolume(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDovolume();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dovolume", cookparms.getCookTime(), 0);
        return result;
    }
    Volborder getVolborder() const { return Volborder(myVolborder); }
    void setVolborder(Volborder val) { myVolborder = int64(val); }
    Volborder opVolborder(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVolborder();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "volborder", cookparms.getCookTime(), 0);
        return Volborder(result);
    }
    fpreal64 getVolborderval() const { return myVolborderval; }
    void setVolborderval(fpreal64 val) { myVolborderval = val; }
    fpreal64 opVolborderval(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVolborderval();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "volborderval", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDovoltol() const { return myDovoltol; }
    void setDovoltol(bool val) { myDovoltol = val; }
    bool opDovoltol(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDovoltol();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dovoltol", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getVoltol() const { return myVoltol; }
    void setVoltol(fpreal64 val) { myVoltol = val; }
    fpreal64 opVoltol(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVoltol();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "voltol", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDovdbclass() const { return myDovdbclass; }
    void setDovdbclass(bool val) { myDovdbclass = val; }
    bool opDovdbclass(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDovdbclass();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dovdbclass", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getVdbclass() const { return myVdbclass; }
    void setVdbclass(int64 val) { myVdbclass = val; }
    int64 opVdbclass(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVdbclass();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "vdbclass", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDovdbcreator() const { return myDovdbcreator; }
    void setDovdbcreator(bool val) { myDovdbcreator = val; }
    bool opDovdbcreator(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDovdbcreator();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dovdbcreator", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getVdbcreator() const { return myVdbcreator; }
    void setVdbcreator(const UT_StringHolder & val) { myVdbcreator = val; }
    UT_StringHolder opVdbcreator(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVdbcreator();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "vdbcreator", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDovdbtransform() const { return myDovdbtransform; }
    void setDovdbtransform(bool val) { myDovdbtransform = val; }
    bool opDovdbtransform(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDovdbtransform();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dovdbtransform", cookparms.getCookTime(), 0);
        return result;
    }
    bool getVdbtransform() const { return myVdbtransform; }
    void setVdbtransform(bool val) { myVdbtransform = val; }
    bool opVdbtransform(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVdbtransform();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "vdbtransform", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDovdbvectype() const { return myDovdbvectype; }
    void setDovdbvectype(bool val) { myDovdbvectype = val; }
    bool opDovdbvectype(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDovdbvectype();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dovdbvectype", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getVdbvectype() const { return myVdbvectype; }
    void setVdbvectype(int64 val) { myVdbvectype = val; }
    int64 opVdbvectype(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVdbvectype();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "vdbvectype", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDovdbhalf() const { return myDovdbhalf; }
    void setDovdbhalf(bool val) { myDovdbhalf = val; }
    bool opDovdbhalf(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDovdbhalf();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "dovdbhalf", cookparms.getCookTime(), 0);
        return result;
    }
    bool getVdbhalf() const { return myVdbhalf; }
    void setVdbhalf(bool val) { myVdbhalf = val; }
    bool opVdbhalf(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVdbhalf();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "vdbhalf", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTemplategrp() const { return myTemplategrp; }
    void setTemplategrp(const UT_StringHolder & val) { myTemplategrp = val; }
    UT_StringHolder opTemplategrp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTemplategrp();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "templateGrp", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPshapeu() const { return myPshapeu; }
    void setPshapeu(bool val) { myPshapeu = val; }
    bool opPshapeu(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPshapeu();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "pshapeu", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPshapev() const { return myPshapev; }
    void setPshapev(bool val) { myPshapev = val; }
    bool opPshapev(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPshapev();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "pshapev", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myGroup;
    bool myDoXform;
    int64 myDoRot;
    int64 myXord;
    int64 myRord;
    UT_Vector3D myT;
    UT_Vector3D myR;
    UT_Vector3D myS;
    UT_Vector3D myShear;
    UT_Vector3D myP;
    UT_Vector3D myPr;
    UT_StringHolder myLookatpath;
    UT_Vector3D myUpvector;
    UT_StringHolder myXformattribs;
    int64 myDoclr;
    UT_Vector3D myDiff;
    int64 myDoalpha;
    fpreal64 myAlpha;
    int64 myDocrease;
    fpreal64 myCrease;
    int64 myDotexture;
    UT_StringHolder myTexture;
    int64 myCloseu;
    int64 myClosev;
    int64 myClampu;
    int64 myClampv;
    int64 myVtxsort;
    int64 myVtxuoff;
    int64 myVtxvoff;
    bool myDoweight;
    fpreal64 myMetaweight;
    bool myDoprender;
    int64 myPrtype;
    fpreal64 myPrsize;
    fpreal64 myPrblur;
    bool myDovolvis;
    int64 myVolvis;
    fpreal64 myVolvisiso;
    fpreal64 myVolvisdensity;
    bool myDotaper;
    UT_Vector2D myTaper;
    bool myDovolume;
    int64 myVolborder;
    fpreal64 myVolborderval;
    bool myDovoltol;
    fpreal64 myVoltol;
    bool myDovdbclass;
    int64 myVdbclass;
    bool myDovdbcreator;
    UT_StringHolder myVdbcreator;
    bool myDovdbtransform;
    bool myVdbtransform;
    bool myDovdbvectype;
    int64 myVdbvectype;
    bool myDovdbhalf;
    bool myVdbhalf;
    UT_StringHolder myTemplategrp;
    bool myPshapeu;
    bool myPshapev;

};
