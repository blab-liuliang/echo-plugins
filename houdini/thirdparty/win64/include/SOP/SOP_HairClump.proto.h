/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_HairClumpEnums
{
    enum class Blendoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Clumpsizeoverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
    enum class Method
    {
        LINEARBLEND = 0,
        EXTRUDEBLEND
    };
    enum class Tightnessoverride
    {
        NONE = 0,
        CLUMPATTRIB,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Strayamountoverride
    {
        NONE = 0,
        CLUMPATTRIB,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Strayrateoverride
    {
        NONE = 0,
        CLUMPATTRIB,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Strayfalloffoverride
    {
        NONE = 0,
        CLUMPATTRIB,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Iterationsoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Sizereductionoverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
    enum class Goalfeedbackoverride
    {
        NONE = 0,
        SKINATTRIB,
        TEXTURE
    };
    enum class Tightnessreductionoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Curlampoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
    enum class Curlfreqoverride
    {
        NONE = 0,
        CURVEATTRIB,
        SKINATTRIB,
        TEXTURE
    };
}


class SOP_API SOP_HairClumpParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_HairClumpParms()
    {
        myLegacymasking = false;
        myUvattrib = "uv"_sh;
        myBlend = 1;
        myBlendoverride = 0;
        myBlendcurveattrib = "clumpmask"_sh;
        myBlendattrib = "clumpmask"_sh;
        myBlendtexture = ""_sh;
        myUseskinmask = false;
        mySkinmaskattrib = "clumpmask"_sh;
        myClumpsize = 0.05;
        myClumpsizeoverride = 0;
        myClumpsizeattrib = "clumpsize"_sh;
        myClumpsizetexture = ""_sh;
        mySearchbeyondradius = false;
        myClumpwithinclumps = false;
        myCrossoverrate = 0.2;
        mySeed = 0;
        myMethod = 1;
        myPreservelength = false;
        myExtendtomatch = 1;
        myShortentomatch = 1;
        myAccuratebundling = false;
        myHairwidth = 0.001;
        myHairwidthscale = 1;
        myTightness = 1;
        myTightnessoverride = 0;
        myTightnesscurveattrib = "tightness"_sh;
        myTightnessclumpattrib = "tightness"_sh;
        myTightnessattrib = "tightness"_sh;
        myTightnesstexture = ""_sh;
        myStrayamount = 1;
        myStrayamountoverride = 0;
        myStrayamountcurveattrib = "strayamount"_sh;
        myStrayamountclumpattrib = "strayamount"_sh;
        myStrayamountattrib = "strayamount"_sh;
        myStrayamounttexture = ""_sh;
        myStrayrate = 0;
        myStrayrateoverride = 0;
        myStrayratecurveattrib = "strayrate"_sh;
        myStrayrateclumpattrib = "strayrate"_sh;
        myStrayrateattrib = "strayrate"_sh;
        myStrayratetexture = ""_sh;
        myStrayfalloff = 1;
        myStrayfalloffoverride = 0;
        myStrayfalloffcurveattrib = "strayfalloff"_sh;
        myStrayfalloffclumpattrib = "strayfalloff"_sh;
        myStrayfalloffattrib = "strayfalloff"_sh;
        myStrayfallofftexture = ""_sh;
        myClumpprofile = UT_SharedPtr<UT_Ramp>(0);
        myIterations = 1;
        myIterationsoverride = 0;
        myIterationscurveattrib = "clumpiterations"_sh;
        myIterationsattrib = "clumpiterations"_sh;
        myIterationstexture = ""_sh;
        mySizereduction = 0.4;
        mySizereductionoverride = 0;
        mySizereductionattrib = "clumpsizereduction"_sh;
        mySizereductiontexture = ""_sh;
        myGoalfeedback = 0.1;
        myGoalfeedbackoverride = 0;
        myGoalfeedbackattrib = "clumpgoalfeedback"_sh;
        myGoalfeedbacktexture = ""_sh;
        myTightnessreduction = 0.2;
        myTightnessreductionoverride = 0;
        myTightnessreductioncurveattrib = "clumptightnessreduction"_sh;
        myTightnessreductionattrib = "clumptightnessreduction"_sh;
        myTightnessreductiontexture = ""_sh;
        myEnablecurling = false;
        myCurlamp = 0;
        myCurlampoverride = 0;
        myCurlampcurveattrib = "clumpcurlamp"_sh;
        myCurlampattrib = "clumpcurlamp"_sh;
        myCurlamptexture = ""_sh;
        myCurlampramp = UT_SharedPtr<UT_Ramp>(0);
        myCurlfreq = 5;
        myCurlfreqoverride = 0;
        myCurlfreqcurveattrib = "clumpcurlfreq"_sh;
        myCurveattrib = "clumpcurlfreq"_sh;
        myCurlfreqattrib = "clumpcurlfreq"_sh;
        myCurlfreqtexture = ""_sh;
        myCurlfreqramp = UT_SharedPtr<UT_Ramp>(0);
        myClumppointattribs = ""_sh;
        myClumpprimattribs = ""_sh;

    }

    explicit SOP_HairClumpParms(const SOP_HairClumpParms &) = default;

    virtual ~SOP_HairClumpParms() {}

    bool operator==(const SOP_HairClumpParms &src) const
    {
        if (myLegacymasking != src.myLegacymasking) return false;
        if (myUvattrib != src.myUvattrib) return false;
        if (myBlend != src.myBlend) return false;
        if (myBlendoverride != src.myBlendoverride) return false;
        if (myBlendcurveattrib != src.myBlendcurveattrib) return false;
        if (myBlendattrib != src.myBlendattrib) return false;
        if (myBlendtexture != src.myBlendtexture) return false;
        if (myUseskinmask != src.myUseskinmask) return false;
        if (mySkinmaskattrib != src.mySkinmaskattrib) return false;
        if (myClumpsize != src.myClumpsize) return false;
        if (myClumpsizeoverride != src.myClumpsizeoverride) return false;
        if (myClumpsizeattrib != src.myClumpsizeattrib) return false;
        if (myClumpsizetexture != src.myClumpsizetexture) return false;
        if (mySearchbeyondradius != src.mySearchbeyondradius) return false;
        if (myClumpwithinclumps != src.myClumpwithinclumps) return false;
        if (myCrossoverrate != src.myCrossoverrate) return false;
        if (mySeed != src.mySeed) return false;
        if (myMethod != src.myMethod) return false;
        if (myPreservelength != src.myPreservelength) return false;
        if (myExtendtomatch != src.myExtendtomatch) return false;
        if (myShortentomatch != src.myShortentomatch) return false;
        if (myAccuratebundling != src.myAccuratebundling) return false;
        if (myHairwidth != src.myHairwidth) return false;
        if (myHairwidthscale != src.myHairwidthscale) return false;
        if (myTightness != src.myTightness) return false;
        if (myTightnessoverride != src.myTightnessoverride) return false;
        if (myTightnesscurveattrib != src.myTightnesscurveattrib) return false;
        if (myTightnessclumpattrib != src.myTightnessclumpattrib) return false;
        if (myTightnessattrib != src.myTightnessattrib) return false;
        if (myTightnesstexture != src.myTightnesstexture) return false;
        if (myStrayamount != src.myStrayamount) return false;
        if (myStrayamountoverride != src.myStrayamountoverride) return false;
        if (myStrayamountcurveattrib != src.myStrayamountcurveattrib) return false;
        if (myStrayamountclumpattrib != src.myStrayamountclumpattrib) return false;
        if (myStrayamountattrib != src.myStrayamountattrib) return false;
        if (myStrayamounttexture != src.myStrayamounttexture) return false;
        if (myStrayrate != src.myStrayrate) return false;
        if (myStrayrateoverride != src.myStrayrateoverride) return false;
        if (myStrayratecurveattrib != src.myStrayratecurveattrib) return false;
        if (myStrayrateclumpattrib != src.myStrayrateclumpattrib) return false;
        if (myStrayrateattrib != src.myStrayrateattrib) return false;
        if (myStrayratetexture != src.myStrayratetexture) return false;
        if (myStrayfalloff != src.myStrayfalloff) return false;
        if (myStrayfalloffoverride != src.myStrayfalloffoverride) return false;
        if (myStrayfalloffcurveattrib != src.myStrayfalloffcurveattrib) return false;
        if (myStrayfalloffclumpattrib != src.myStrayfalloffclumpattrib) return false;
        if (myStrayfalloffattrib != src.myStrayfalloffattrib) return false;
        if (myStrayfallofftexture != src.myStrayfallofftexture) return false;
        if (myClumpprofile != src.myClumpprofile) return false;
        if (myIterations != src.myIterations) return false;
        if (myIterationsoverride != src.myIterationsoverride) return false;
        if (myIterationscurveattrib != src.myIterationscurveattrib) return false;
        if (myIterationsattrib != src.myIterationsattrib) return false;
        if (myIterationstexture != src.myIterationstexture) return false;
        if (mySizereduction != src.mySizereduction) return false;
        if (mySizereductionoverride != src.mySizereductionoverride) return false;
        if (mySizereductionattrib != src.mySizereductionattrib) return false;
        if (mySizereductiontexture != src.mySizereductiontexture) return false;
        if (myGoalfeedback != src.myGoalfeedback) return false;
        if (myGoalfeedbackoverride != src.myGoalfeedbackoverride) return false;
        if (myGoalfeedbackattrib != src.myGoalfeedbackattrib) return false;
        if (myGoalfeedbacktexture != src.myGoalfeedbacktexture) return false;
        if (myTightnessreduction != src.myTightnessreduction) return false;
        if (myTightnessreductionoverride != src.myTightnessreductionoverride) return false;
        if (myTightnessreductioncurveattrib != src.myTightnessreductioncurveattrib) return false;
        if (myTightnessreductionattrib != src.myTightnessreductionattrib) return false;
        if (myTightnessreductiontexture != src.myTightnessreductiontexture) return false;
        if (myEnablecurling != src.myEnablecurling) return false;
        if (myCurlamp != src.myCurlamp) return false;
        if (myCurlampoverride != src.myCurlampoverride) return false;
        if (myCurlampcurveattrib != src.myCurlampcurveattrib) return false;
        if (myCurlampattrib != src.myCurlampattrib) return false;
        if (myCurlamptexture != src.myCurlamptexture) return false;
        if (myCurlampramp != src.myCurlampramp) return false;
        if (myCurlfreq != src.myCurlfreq) return false;
        if (myCurlfreqoverride != src.myCurlfreqoverride) return false;
        if (myCurlfreqcurveattrib != src.myCurlfreqcurveattrib) return false;
        if (myCurveattrib != src.myCurveattrib) return false;
        if (myCurlfreqattrib != src.myCurlfreqattrib) return false;
        if (myCurlfreqtexture != src.myCurlfreqtexture) return false;
        if (myCurlfreqramp != src.myCurlfreqramp) return false;
        if (myClumppointattribs != src.myClumppointattribs) return false;
        if (myClumpprimattribs != src.myClumpprimattribs) return false;

        return true;
    }
    bool operator!=(const SOP_HairClumpParms &src) const
    {
        return !operator==(src);
    }
    using Blendoverride = SOP_HairClumpEnums::Blendoverride;
    using Clumpsizeoverride = SOP_HairClumpEnums::Clumpsizeoverride;
    using Method = SOP_HairClumpEnums::Method;
    using Tightnessoverride = SOP_HairClumpEnums::Tightnessoverride;
    using Strayamountoverride = SOP_HairClumpEnums::Strayamountoverride;
    using Strayrateoverride = SOP_HairClumpEnums::Strayrateoverride;
    using Strayfalloffoverride = SOP_HairClumpEnums::Strayfalloffoverride;
    using Iterationsoverride = SOP_HairClumpEnums::Iterationsoverride;
    using Sizereductionoverride = SOP_HairClumpEnums::Sizereductionoverride;
    using Goalfeedbackoverride = SOP_HairClumpEnums::Goalfeedbackoverride;
    using Tightnessreductionoverride = SOP_HairClumpEnums::Tightnessreductionoverride;
    using Curlampoverride = SOP_HairClumpEnums::Curlampoverride;
    using Curlfreqoverride = SOP_HairClumpEnums::Curlfreqoverride;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myLegacymasking, node, "legacymasking", time, 0);
        else myLegacymasking = false;
        if (true)
            OP_Utils::evalOpParm(myUvattrib, node, "uvattrib", time, 0);
        else myUvattrib = "uv"_sh;
        if (true)
            OP_Utils::evalOpParm(myBlend, node, "blend", time, 0);
        else myBlend = 1;
        if (true && ( (!(((getLegacymasking()==1)))) ) )
            OP_Utils::evalOpParm(myBlendoverride, node, "blendoverride", time, 0);
        else myBlendoverride = 0;
        if (true && ( (!(((int64(getBlendoverride())!=1))||((getLegacymasking()==1)))) ) )
            OP_Utils::evalOpParm(myBlendcurveattrib, node, "blendcurveattrib", time, 0);
        else myBlendcurveattrib = "clumpmask"_sh;
        if (true && ( (!(((int64(getBlendoverride())!=2))||((getLegacymasking()==1)))) ) )
            OP_Utils::evalOpParm(myBlendattrib, node, "blendattrib", time, 0);
        else myBlendattrib = "clumpmask"_sh;
        if (true && ( (!(((int64(getBlendoverride())!=3))||((getLegacymasking()==1)))) ) )
            OP_Utils::evalOpParm(myBlendtexture, node, "blendtexture", time, 0);
        else myBlendtexture = ""_sh;
        if (true && ( (!(((getLegacymasking()==0)))) ) )
            OP_Utils::evalOpParm(myUseskinmask, node, "useskinmask", time, 0);
        else myUseskinmask = false;
        if (true && ( (!(((getUseskinmask()==0))||((getLegacymasking()==0)))) ) )
            OP_Utils::evalOpParm(mySkinmaskattrib, node, "skinmaskattrib", time, 0);
        else mySkinmaskattrib = "clumpmask"_sh;
        if (true)
            OP_Utils::evalOpParm(myClumpsize, node, "clumpsize", time, 0);
        else myClumpsize = 0.05;
        if (true)
            OP_Utils::evalOpParm(myClumpsizeoverride, node, "clumpsizeoverride", time, 0);
        else myClumpsizeoverride = 0;
        if (true && ( (!(((int64(getClumpsizeoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myClumpsizeattrib, node, "clumpsizeattrib", time, 0);
        else myClumpsizeattrib = "clumpsize"_sh;
        if (true && ( (!(((int64(getClumpsizeoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myClumpsizetexture, node, "clumpsizetexture", time, 0);
        else myClumpsizetexture = ""_sh;
        if (true)
            OP_Utils::evalOpParm(mySearchbeyondradius, node, "searchbeyondradius", time, 0);
        else mySearchbeyondradius = false;
        if (true)
            OP_Utils::evalOpParm(myClumpwithinclumps, node, "clumpwithinclumps", time, 0);
        else myClumpwithinclumps = false;
        if (true)
            OP_Utils::evalOpParm(myCrossoverrate, node, "crossoverrate", time, 0);
        else myCrossoverrate = 0.2;
        if (true)
            OP_Utils::evalOpParm(mySeed, node, "seed", time, 0);
        else mySeed = 0;
        if (true)
            OP_Utils::evalOpParm(myMethod, node, "method", time, 0);
        else myMethod = 1;
        if (true)
            OP_Utils::evalOpParm(myPreservelength, node, "preservelength", time, 0);
        else myPreservelength = false;
        if (true && ( (!(((getPreservelength()==0)))) ) )
            OP_Utils::evalOpParm(myExtendtomatch, node, "extendtomatch", time, 0);
        else myExtendtomatch = 1;
        if (true && ( (!(((getPreservelength()==0)))) ) )
            OP_Utils::evalOpParm(myShortentomatch, node, "shortentomatch", time, 0);
        else myShortentomatch = 1;
        if (true)
            OP_Utils::evalOpParm(myAccuratebundling, node, "accuratebundling", time, 0);
        else myAccuratebundling = false;
        if (true && ( (!(((getAccuratebundling()==0)))) ) )
            OP_Utils::evalOpParm(myHairwidth, node, "hairwidth", time, 0);
        else myHairwidth = 0.001;
        if (true && ( (!(((getAccuratebundling()==0)))) ) )
            OP_Utils::evalOpParm(myHairwidthscale, node, "hairwidthscale", time, 0);
        else myHairwidthscale = 1;
        if (true)
            OP_Utils::evalOpParm(myTightness, node, "tightness", time, 0);
        else myTightness = 1;
        if (true)
            OP_Utils::evalOpParm(myTightnessoverride, node, "tightnessoverride", time, 0);
        else myTightnessoverride = 0;
        if (true && ( (!(((int64(getTightnessoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myTightnesscurveattrib, node, "tightnesscurveattrib", time, 0);
        else myTightnesscurveattrib = "tightness"_sh;
        if (true && ( (!(((int64(getTightnessoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myTightnessclumpattrib, node, "tightnessclumpattrib", time, 0);
        else myTightnessclumpattrib = "tightness"_sh;
        if (true && ( (!(((int64(getTightnessoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myTightnessattrib, node, "tightnessattrib", time, 0);
        else myTightnessattrib = "tightness"_sh;
        if (true && ( (!(((int64(getTightnessoverride())!=4)))) ) )
            OP_Utils::evalOpParm(myTightnesstexture, node, "tightnesstexture", time, 0);
        else myTightnesstexture = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myStrayamount, node, "strayamount", time, 0);
        else myStrayamount = 1;
        if (true)
            OP_Utils::evalOpParm(myStrayamountoverride, node, "strayamountoverride", time, 0);
        else myStrayamountoverride = 0;
        if (true && ( (!(((int64(getStrayamountoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myStrayamountcurveattrib, node, "strayamountcurveattrib", time, 0);
        else myStrayamountcurveattrib = "strayamount"_sh;
        if (true && ( (!(((int64(getStrayamountoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myStrayamountclumpattrib, node, "strayamountclumpattrib", time, 0);
        else myStrayamountclumpattrib = "strayamount"_sh;
        if (true && ( (!(((int64(getStrayamountoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myStrayamountattrib, node, "strayamountattrib", time, 0);
        else myStrayamountattrib = "strayamount"_sh;
        if (true && ( (!(((int64(getStrayamountoverride())!=4)))) ) )
            OP_Utils::evalOpParm(myStrayamounttexture, node, "strayamounttexture", time, 0);
        else myStrayamounttexture = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myStrayrate, node, "strayrate", time, 0);
        else myStrayrate = 0;
        if (true)
            OP_Utils::evalOpParm(myStrayrateoverride, node, "strayrateoverride", time, 0);
        else myStrayrateoverride = 0;
        if (true && ( (!(((int64(getStrayrateoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myStrayratecurveattrib, node, "strayratecurveattrib", time, 0);
        else myStrayratecurveattrib = "strayrate"_sh;
        if (true && ( (!(((int64(getStrayrateoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myStrayrateclumpattrib, node, "strayrateclumpattrib", time, 0);
        else myStrayrateclumpattrib = "strayrate"_sh;
        if (true && ( (!(((int64(getStrayrateoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myStrayrateattrib, node, "strayrateattrib", time, 0);
        else myStrayrateattrib = "strayrate"_sh;
        if (true && ( (!(((int64(getStrayrateoverride())!=4)))) ) )
            OP_Utils::evalOpParm(myStrayratetexture, node, "strayratetexture", time, 0);
        else myStrayratetexture = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myStrayfalloff, node, "strayfalloff", time, 0);
        else myStrayfalloff = 1;
        if (true)
            OP_Utils::evalOpParm(myStrayfalloffoverride, node, "strayfalloffoverride", time, 0);
        else myStrayfalloffoverride = 0;
        if (true && ( (!(((int64(getStrayfalloffoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myStrayfalloffcurveattrib, node, "strayfalloffcurveattrib", time, 0);
        else myStrayfalloffcurveattrib = "strayfalloff"_sh;
        if (true && ( (!(((int64(getStrayfalloffoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myStrayfalloffclumpattrib, node, "strayfalloffclumpattrib", time, 0);
        else myStrayfalloffclumpattrib = "strayfalloff"_sh;
        if (true && ( (!(((int64(getStrayfalloffoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myStrayfalloffattrib, node, "strayfalloffattrib", time, 0);
        else myStrayfalloffattrib = "strayfalloff"_sh;
        if (true && ( (!(((int64(getStrayfalloffoverride())!=4)))) ) )
            OP_Utils::evalOpParm(myStrayfallofftexture, node, "strayfallofftexture", time, 0);
        else myStrayfallofftexture = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myClumpprofile, node, "clumpprofile", time, 0);
        else myClumpprofile = UT_SharedPtr<UT_Ramp>(0);
        if (true)
            OP_Utils::evalOpParm(myIterations, node, "iterations", time, 0);
        else myIterations = 1;
        if (true)
            OP_Utils::evalOpParm(myIterationsoverride, node, "iterationsoverride", time, 0);
        else myIterationsoverride = 0;
        if (true && ( (!(((int64(getIterationsoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myIterationscurveattrib, node, "iterationscurveattrib", time, 0);
        else myIterationscurveattrib = "clumpiterations"_sh;
        if (true && ( (!(((int64(getIterationsoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myIterationsattrib, node, "iterationsattrib", time, 0);
        else myIterationsattrib = "clumpiterations"_sh;
        if (true && ( (!(((int64(getIterationsoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myIterationstexture, node, "iterationstexture", time, 0);
        else myIterationstexture = ""_sh;
        if (true && ( (!(((getIterations()<=1)))) ) )
            OP_Utils::evalOpParm(mySizereduction, node, "sizereduction", time, 0);
        else mySizereduction = 0.4;
        if (true && ( (!(((getIterations()<=1)))) ) )
            OP_Utils::evalOpParm(mySizereductionoverride, node, "sizereductionoverride", time, 0);
        else mySizereductionoverride = 0;
        if (true && ( (!(((getIterations()<=1))||((int64(getSizereductionoverride())!=1)))) ) )
            OP_Utils::evalOpParm(mySizereductionattrib, node, "sizereductionattrib", time, 0);
        else mySizereductionattrib = "clumpsizereduction"_sh;
        if (true && ( (!(((getIterations()<=1))||((int64(getSizereductionoverride())!=2)))) ) )
            OP_Utils::evalOpParm(mySizereductiontexture, node, "sizereductiontexture", time, 0);
        else mySizereductiontexture = ""_sh;
        if (true && ( (!(((getIterations()<=1)))) ) )
            OP_Utils::evalOpParm(myGoalfeedback, node, "goalfeedback", time, 0);
        else myGoalfeedback = 0.1;
        if (true && ( (!(((getIterations()<=1)))) ) )
            OP_Utils::evalOpParm(myGoalfeedbackoverride, node, "goalfeedbackoverride", time, 0);
        else myGoalfeedbackoverride = 0;
        if (true && ( (!(((getIterations()<=1))||((int64(getGoalfeedbackoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myGoalfeedbackattrib, node, "goalfeedbackattrib", time, 0);
        else myGoalfeedbackattrib = "clumpgoalfeedback"_sh;
        if (true && ( (!(((getIterations()<=1))||((int64(getGoalfeedbackoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myGoalfeedbacktexture, node, "goalfeedbacktexture", time, 0);
        else myGoalfeedbacktexture = ""_sh;
        if (true && ( (!(((getIterations()<=1)))) ) )
            OP_Utils::evalOpParm(myTightnessreduction, node, "tightnessreduction", time, 0);
        else myTightnessreduction = 0.2;
        if (true && ( (!(((getIterations()<=1)))) ) )
            OP_Utils::evalOpParm(myTightnessreductionoverride, node, "tightnessreductionoverride", time, 0);
        else myTightnessreductionoverride = 0;
        if (true && ( (!(((getIterations()<=1))||((int64(getTightnessreductionoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myTightnessreductioncurveattrib, node, "tightnessreductioncurveattrib", time, 0);
        else myTightnessreductioncurveattrib = "clumptightnessreduction"_sh;
        if (true && ( (!(((getIterations()<=1))||((int64(getTightnessreductionoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myTightnessreductionattrib, node, "tightnessreductionattrib", time, 0);
        else myTightnessreductionattrib = "clumptightnessreduction"_sh;
        if (true && ( (!(((getIterations()<=1))||((int64(getTightnessreductionoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myTightnessreductiontexture, node, "tightnessreductiontexture", time, 0);
        else myTightnessreductiontexture = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myEnablecurling, node, "enablecurling", time, 0);
        else myEnablecurling = false;
        if (true && ( (!(((getEnablecurling()==0)))) ) )
            OP_Utils::evalOpParm(myCurlamp, node, "curlamp", time, 0);
        else myCurlamp = 0;
        if (true && ( (!(((getEnablecurling()==0)))) ) )
            OP_Utils::evalOpParm(myCurlampoverride, node, "curlampoverride", time, 0);
        else myCurlampoverride = 0;
        if (true && ( (!(((getEnablecurling()==0))||((int64(getCurlampoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myCurlampcurveattrib, node, "curlampcurveattrib", time, 0);
        else myCurlampcurveattrib = "clumpcurlamp"_sh;
        if (true && ( (!(((getEnablecurling()==0))||((int64(getCurlampoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myCurlampattrib, node, "curlampattrib", time, 0);
        else myCurlampattrib = "clumpcurlamp"_sh;
        if (true && ( (!(((getEnablecurling()==0))||((int64(getCurlampoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myCurlamptexture, node, "curlamptexture", time, 0);
        else myCurlamptexture = ""_sh;
        if (true && ( (!(((getEnablecurling()==0)))) ) )
            OP_Utils::evalOpParm(myCurlampramp, node, "curlampramp", time, 0);
        else myCurlampramp = UT_SharedPtr<UT_Ramp>(0);
        if (true && ( (!(((getEnablecurling()==0)))) ) )
            OP_Utils::evalOpParm(myCurlfreq, node, "curlfreq", time, 0);
        else myCurlfreq = 5;
        if (true && ( (!(((getEnablecurling()==0)))) ) )
            OP_Utils::evalOpParm(myCurlfreqoverride, node, "curlfreqoverride", time, 0);
        else myCurlfreqoverride = 0;
        if (true && ( (!(((getEnablecurling()==0))||((int64(getCurlfreqoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myCurlfreqcurveattrib, node, "curlfreqcurveattrib", time, 0);
        else myCurlfreqcurveattrib = "clumpcurlfreq"_sh;
        if (true && ( (!(((getEnablecurling()==0))||((int64(getCurlfreqoverride())!=1)))) ) )
            OP_Utils::evalOpParm(myCurveattrib, node, "curveattrib", time, 0);
        else myCurveattrib = "clumpcurlfreq"_sh;
        if (true && ( (!(((getEnablecurling()==0))||((int64(getCurlfreqoverride())!=2)))) ) )
            OP_Utils::evalOpParm(myCurlfreqattrib, node, "curlfreqattrib", time, 0);
        else myCurlfreqattrib = "clumpcurlfreq"_sh;
        if (true && ( (!(((getEnablecurling()==0))||((int64(getCurlfreqoverride())!=3)))) ) )
            OP_Utils::evalOpParm(myCurlfreqtexture, node, "curlfreqtexture", time, 0);
        else myCurlfreqtexture = ""_sh;
        if (true && ( (!(((getEnablecurling()==0)))) ) )
            OP_Utils::evalOpParm(myCurlfreqramp, node, "curlfreqramp", time, 0);
        else myCurlfreqramp = UT_SharedPtr<UT_Ramp>(0);
        if (true)
            OP_Utils::evalOpParm(myClumppointattribs, node, "clumppointattribs", time, 0);
        else myClumppointattribs = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myClumpprimattribs, node, "clumpprimattribs", time, 0);
        else myClumpprimattribs = ""_sh;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_HairClumpParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myLegacymasking);
                break;
            case 1:
                coerceValue(value, myUvattrib);
                break;
            case 2:
                coerceValue(value, myBlend);
                break;
            case 3:
                coerceValue(value, myBlendoverride);
                break;
            case 4:
                coerceValue(value, myBlendcurveattrib);
                break;
            case 5:
                coerceValue(value, myBlendattrib);
                break;
            case 6:
                coerceValue(value, myBlendtexture);
                break;
            case 7:
                coerceValue(value, myUseskinmask);
                break;
            case 8:
                coerceValue(value, mySkinmaskattrib);
                break;
            case 9:
                coerceValue(value, myClumpsize);
                break;
            case 10:
                coerceValue(value, myClumpsizeoverride);
                break;
            case 11:
                coerceValue(value, myClumpsizeattrib);
                break;
            case 12:
                coerceValue(value, myClumpsizetexture);
                break;
            case 13:
                coerceValue(value, mySearchbeyondradius);
                break;
            case 14:
                coerceValue(value, myClumpwithinclumps);
                break;
            case 15:
                coerceValue(value, myCrossoverrate);
                break;
            case 16:
                coerceValue(value, mySeed);
                break;
            case 17:
                coerceValue(value, myMethod);
                break;
            case 18:
                coerceValue(value, myPreservelength);
                break;
            case 19:
                coerceValue(value, myExtendtomatch);
                break;
            case 20:
                coerceValue(value, myShortentomatch);
                break;
            case 21:
                coerceValue(value, myAccuratebundling);
                break;
            case 22:
                coerceValue(value, myHairwidth);
                break;
            case 23:
                coerceValue(value, myHairwidthscale);
                break;
            case 24:
                coerceValue(value, myTightness);
                break;
            case 25:
                coerceValue(value, myTightnessoverride);
                break;
            case 26:
                coerceValue(value, myTightnesscurveattrib);
                break;
            case 27:
                coerceValue(value, myTightnessclumpattrib);
                break;
            case 28:
                coerceValue(value, myTightnessattrib);
                break;
            case 29:
                coerceValue(value, myTightnesstexture);
                break;
            case 30:
                coerceValue(value, myStrayamount);
                break;
            case 31:
                coerceValue(value, myStrayamountoverride);
                break;
            case 32:
                coerceValue(value, myStrayamountcurveattrib);
                break;
            case 33:
                coerceValue(value, myStrayamountclumpattrib);
                break;
            case 34:
                coerceValue(value, myStrayamountattrib);
                break;
            case 35:
                coerceValue(value, myStrayamounttexture);
                break;
            case 36:
                coerceValue(value, myStrayrate);
                break;
            case 37:
                coerceValue(value, myStrayrateoverride);
                break;
            case 38:
                coerceValue(value, myStrayratecurveattrib);
                break;
            case 39:
                coerceValue(value, myStrayrateclumpattrib);
                break;
            case 40:
                coerceValue(value, myStrayrateattrib);
                break;
            case 41:
                coerceValue(value, myStrayratetexture);
                break;
            case 42:
                coerceValue(value, myStrayfalloff);
                break;
            case 43:
                coerceValue(value, myStrayfalloffoverride);
                break;
            case 44:
                coerceValue(value, myStrayfalloffcurveattrib);
                break;
            case 45:
                coerceValue(value, myStrayfalloffclumpattrib);
                break;
            case 46:
                coerceValue(value, myStrayfalloffattrib);
                break;
            case 47:
                coerceValue(value, myStrayfallofftexture);
                break;
            case 48:
                coerceValue(value, myClumpprofile);
                break;
            case 49:
                coerceValue(value, myIterations);
                break;
            case 50:
                coerceValue(value, myIterationsoverride);
                break;
            case 51:
                coerceValue(value, myIterationscurveattrib);
                break;
            case 52:
                coerceValue(value, myIterationsattrib);
                break;
            case 53:
                coerceValue(value, myIterationstexture);
                break;
            case 54:
                coerceValue(value, mySizereduction);
                break;
            case 55:
                coerceValue(value, mySizereductionoverride);
                break;
            case 56:
                coerceValue(value, mySizereductionattrib);
                break;
            case 57:
                coerceValue(value, mySizereductiontexture);
                break;
            case 58:
                coerceValue(value, myGoalfeedback);
                break;
            case 59:
                coerceValue(value, myGoalfeedbackoverride);
                break;
            case 60:
                coerceValue(value, myGoalfeedbackattrib);
                break;
            case 61:
                coerceValue(value, myGoalfeedbacktexture);
                break;
            case 62:
                coerceValue(value, myTightnessreduction);
                break;
            case 63:
                coerceValue(value, myTightnessreductionoverride);
                break;
            case 64:
                coerceValue(value, myTightnessreductioncurveattrib);
                break;
            case 65:
                coerceValue(value, myTightnessreductionattrib);
                break;
            case 66:
                coerceValue(value, myTightnessreductiontexture);
                break;
            case 67:
                coerceValue(value, myEnablecurling);
                break;
            case 68:
                coerceValue(value, myCurlamp);
                break;
            case 69:
                coerceValue(value, myCurlampoverride);
                break;
            case 70:
                coerceValue(value, myCurlampcurveattrib);
                break;
            case 71:
                coerceValue(value, myCurlampattrib);
                break;
            case 72:
                coerceValue(value, myCurlamptexture);
                break;
            case 73:
                coerceValue(value, myCurlampramp);
                break;
            case 74:
                coerceValue(value, myCurlfreq);
                break;
            case 75:
                coerceValue(value, myCurlfreqoverride);
                break;
            case 76:
                coerceValue(value, myCurlfreqcurveattrib);
                break;
            case 77:
                coerceValue(value, myCurveattrib);
                break;
            case 78:
                coerceValue(value, myCurlfreqattrib);
                break;
            case 79:
                coerceValue(value, myCurlfreqtexture);
                break;
            case 80:
                coerceValue(value, myCurlfreqramp);
                break;
            case 81:
                coerceValue(value, myClumppointattribs);
                break;
            case 82:
                coerceValue(value, myClumpprimattribs);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myLegacymasking, value);
                break;
            case 1:
                coerceValue(myUvattrib, value);
                break;
            case 2:
                coerceValue(myBlend, value);
                break;
            case 3:
                coerceValue(myBlendoverride, value);
                break;
            case 4:
                coerceValue(myBlendcurveattrib, value);
                break;
            case 5:
                coerceValue(myBlendattrib, value);
                break;
            case 6:
                coerceValue(myBlendtexture, value);
                break;
            case 7:
                coerceValue(myUseskinmask, value);
                break;
            case 8:
                coerceValue(mySkinmaskattrib, value);
                break;
            case 9:
                coerceValue(myClumpsize, value);
                break;
            case 10:
                coerceValue(myClumpsizeoverride, value);
                break;
            case 11:
                coerceValue(myClumpsizeattrib, value);
                break;
            case 12:
                coerceValue(myClumpsizetexture, value);
                break;
            case 13:
                coerceValue(mySearchbeyondradius, value);
                break;
            case 14:
                coerceValue(myClumpwithinclumps, value);
                break;
            case 15:
                coerceValue(myCrossoverrate, value);
                break;
            case 16:
                coerceValue(mySeed, value);
                break;
            case 17:
                coerceValue(myMethod, value);
                break;
            case 18:
                coerceValue(myPreservelength, value);
                break;
            case 19:
                coerceValue(myExtendtomatch, value);
                break;
            case 20:
                coerceValue(myShortentomatch, value);
                break;
            case 21:
                coerceValue(myAccuratebundling, value);
                break;
            case 22:
                coerceValue(myHairwidth, value);
                break;
            case 23:
                coerceValue(myHairwidthscale, value);
                break;
            case 24:
                coerceValue(myTightness, value);
                break;
            case 25:
                coerceValue(myTightnessoverride, value);
                break;
            case 26:
                coerceValue(myTightnesscurveattrib, value);
                break;
            case 27:
                coerceValue(myTightnessclumpattrib, value);
                break;
            case 28:
                coerceValue(myTightnessattrib, value);
                break;
            case 29:
                coerceValue(myTightnesstexture, value);
                break;
            case 30:
                coerceValue(myStrayamount, value);
                break;
            case 31:
                coerceValue(myStrayamountoverride, value);
                break;
            case 32:
                coerceValue(myStrayamountcurveattrib, value);
                break;
            case 33:
                coerceValue(myStrayamountclumpattrib, value);
                break;
            case 34:
                coerceValue(myStrayamountattrib, value);
                break;
            case 35:
                coerceValue(myStrayamounttexture, value);
                break;
            case 36:
                coerceValue(myStrayrate, value);
                break;
            case 37:
                coerceValue(myStrayrateoverride, value);
                break;
            case 38:
                coerceValue(myStrayratecurveattrib, value);
                break;
            case 39:
                coerceValue(myStrayrateclumpattrib, value);
                break;
            case 40:
                coerceValue(myStrayrateattrib, value);
                break;
            case 41:
                coerceValue(myStrayratetexture, value);
                break;
            case 42:
                coerceValue(myStrayfalloff, value);
                break;
            case 43:
                coerceValue(myStrayfalloffoverride, value);
                break;
            case 44:
                coerceValue(myStrayfalloffcurveattrib, value);
                break;
            case 45:
                coerceValue(myStrayfalloffclumpattrib, value);
                break;
            case 46:
                coerceValue(myStrayfalloffattrib, value);
                break;
            case 47:
                coerceValue(myStrayfallofftexture, value);
                break;
            case 48:
                coerceValue(myClumpprofile, value);
                break;
            case 49:
                coerceValue(myIterations, value);
                break;
            case 50:
                coerceValue(myIterationsoverride, value);
                break;
            case 51:
                coerceValue(myIterationscurveattrib, value);
                break;
            case 52:
                coerceValue(myIterationsattrib, value);
                break;
            case 53:
                coerceValue(myIterationstexture, value);
                break;
            case 54:
                coerceValue(mySizereduction, value);
                break;
            case 55:
                coerceValue(mySizereductionoverride, value);
                break;
            case 56:
                coerceValue(mySizereductionattrib, value);
                break;
            case 57:
                coerceValue(mySizereductiontexture, value);
                break;
            case 58:
                coerceValue(myGoalfeedback, value);
                break;
            case 59:
                coerceValue(myGoalfeedbackoverride, value);
                break;
            case 60:
                coerceValue(myGoalfeedbackattrib, value);
                break;
            case 61:
                coerceValue(myGoalfeedbacktexture, value);
                break;
            case 62:
                coerceValue(myTightnessreduction, value);
                break;
            case 63:
                coerceValue(myTightnessreductionoverride, value);
                break;
            case 64:
                coerceValue(myTightnessreductioncurveattrib, value);
                break;
            case 65:
                coerceValue(myTightnessreductionattrib, value);
                break;
            case 66:
                coerceValue(myTightnessreductiontexture, value);
                break;
            case 67:
                coerceValue(myEnablecurling, value);
                break;
            case 68:
                coerceValue(myCurlamp, value);
                break;
            case 69:
                coerceValue(myCurlampoverride, value);
                break;
            case 70:
                coerceValue(myCurlampcurveattrib, value);
                break;
            case 71:
                coerceValue(myCurlampattrib, value);
                break;
            case 72:
                coerceValue(myCurlamptexture, value);
                break;
            case 73:
                coerceValue(myCurlampramp, value);
                break;
            case 74:
                coerceValue(myCurlfreq, value);
                break;
            case 75:
                coerceValue(myCurlfreqoverride, value);
                break;
            case 76:
                coerceValue(myCurlfreqcurveattrib, value);
                break;
            case 77:
                coerceValue(myCurveattrib, value);
                break;
            case 78:
                coerceValue(myCurlfreqattrib, value);
                break;
            case 79:
                coerceValue(myCurlfreqtexture, value);
                break;
            case 80:
                coerceValue(myCurlfreqramp, value);
                break;
            case 81:
                coerceValue(myClumppointattribs, value);
                break;
            case 82:
                coerceValue(myClumpprimattribs, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 83;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "legacymasking";
            case 1:
                return "uvattrib";
            case 2:
                return "blend";
            case 3:
                return "blendoverride";
            case 4:
                return "blendcurveattrib";
            case 5:
                return "blendattrib";
            case 6:
                return "blendtexture";
            case 7:
                return "useskinmask";
            case 8:
                return "skinmaskattrib";
            case 9:
                return "clumpsize";
            case 10:
                return "clumpsizeoverride";
            case 11:
                return "clumpsizeattrib";
            case 12:
                return "clumpsizetexture";
            case 13:
                return "searchbeyondradius";
            case 14:
                return "clumpwithinclumps";
            case 15:
                return "crossoverrate";
            case 16:
                return "seed";
            case 17:
                return "method";
            case 18:
                return "preservelength";
            case 19:
                return "extendtomatch";
            case 20:
                return "shortentomatch";
            case 21:
                return "accuratebundling";
            case 22:
                return "hairwidth";
            case 23:
                return "hairwidthscale";
            case 24:
                return "tightness";
            case 25:
                return "tightnessoverride";
            case 26:
                return "tightnesscurveattrib";
            case 27:
                return "tightnessclumpattrib";
            case 28:
                return "tightnessattrib";
            case 29:
                return "tightnesstexture";
            case 30:
                return "strayamount";
            case 31:
                return "strayamountoverride";
            case 32:
                return "strayamountcurveattrib";
            case 33:
                return "strayamountclumpattrib";
            case 34:
                return "strayamountattrib";
            case 35:
                return "strayamounttexture";
            case 36:
                return "strayrate";
            case 37:
                return "strayrateoverride";
            case 38:
                return "strayratecurveattrib";
            case 39:
                return "strayrateclumpattrib";
            case 40:
                return "strayrateattrib";
            case 41:
                return "strayratetexture";
            case 42:
                return "strayfalloff";
            case 43:
                return "strayfalloffoverride";
            case 44:
                return "strayfalloffcurveattrib";
            case 45:
                return "strayfalloffclumpattrib";
            case 46:
                return "strayfalloffattrib";
            case 47:
                return "strayfallofftexture";
            case 48:
                return "clumpprofile";
            case 49:
                return "iterations";
            case 50:
                return "iterationsoverride";
            case 51:
                return "iterationscurveattrib";
            case 52:
                return "iterationsattrib";
            case 53:
                return "iterationstexture";
            case 54:
                return "sizereduction";
            case 55:
                return "sizereductionoverride";
            case 56:
                return "sizereductionattrib";
            case 57:
                return "sizereductiontexture";
            case 58:
                return "goalfeedback";
            case 59:
                return "goalfeedbackoverride";
            case 60:
                return "goalfeedbackattrib";
            case 61:
                return "goalfeedbacktexture";
            case 62:
                return "tightnessreduction";
            case 63:
                return "tightnessreductionoverride";
            case 64:
                return "tightnessreductioncurveattrib";
            case 65:
                return "tightnessreductionattrib";
            case 66:
                return "tightnessreductiontexture";
            case 67:
                return "enablecurling";
            case 68:
                return "curlamp";
            case 69:
                return "curlampoverride";
            case 70:
                return "curlampcurveattrib";
            case 71:
                return "curlampattrib";
            case 72:
                return "curlamptexture";
            case 73:
                return "curlampramp";
            case 74:
                return "curlfreq";
            case 75:
                return "curlfreqoverride";
            case 76:
                return "curlfreqcurveattrib";
            case 77:
                return "curveattrib";
            case 78:
                return "curlfreqattrib";
            case 79:
                return "curlfreqtexture";
            case 80:
                return "curlfreqramp";
            case 81:
                return "clumppointattribs";
            case 82:
                return "clumpprimattribs";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_INTEGER;
                case 1:
                    return PARM_STRING;
                case 2:
                    return PARM_FLOAT;
                case 3:
                    return PARM_INTEGER;
                case 4:
                    return PARM_STRING;
                case 5:
                    return PARM_STRING;
                case 6:
                    return PARM_STRING;
                case 7:
                    return PARM_INTEGER;
                case 8:
                    return PARM_STRING;
                case 9:
                    return PARM_FLOAT;
                case 10:
                    return PARM_INTEGER;
                case 11:
                    return PARM_STRING;
                case 12:
                    return PARM_STRING;
                case 13:
                    return PARM_INTEGER;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_FLOAT;
                case 16:
                    return PARM_FLOAT;
                case 17:
                    return PARM_INTEGER;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_FLOAT;
                case 20:
                    return PARM_FLOAT;
                case 21:
                    return PARM_INTEGER;
                case 22:
                    return PARM_FLOAT;
                case 23:
                    return PARM_FLOAT;
                case 24:
                    return PARM_FLOAT;
                case 25:
                    return PARM_INTEGER;
                case 26:
                    return PARM_STRING;
                case 27:
                    return PARM_STRING;
                case 28:
                    return PARM_STRING;
                case 29:
                    return PARM_STRING;
                case 30:
                    return PARM_FLOAT;
                case 31:
                    return PARM_INTEGER;
                case 32:
                    return PARM_STRING;
                case 33:
                    return PARM_STRING;
                case 34:
                    return PARM_STRING;
                case 35:
                    return PARM_STRING;
                case 36:
                    return PARM_FLOAT;
                case 37:
                    return PARM_INTEGER;
                case 38:
                    return PARM_STRING;
                case 39:
                    return PARM_STRING;
                case 40:
                    return PARM_STRING;
                case 41:
                    return PARM_STRING;
                case 42:
                    return PARM_FLOAT;
                case 43:
                    return PARM_INTEGER;
                case 44:
                    return PARM_STRING;
                case 45:
                    return PARM_STRING;
                case 46:
                    return PARM_STRING;
                case 47:
                    return PARM_STRING;
                case 48:
                    return PARM_RAMP;
                case 49:
                    return PARM_FLOAT;
                case 50:
                    return PARM_INTEGER;
                case 51:
                    return PARM_STRING;
                case 52:
                    return PARM_STRING;
                case 53:
                    return PARM_STRING;
                case 54:
                    return PARM_FLOAT;
                case 55:
                    return PARM_INTEGER;
                case 56:
                    return PARM_STRING;
                case 57:
                    return PARM_STRING;
                case 58:
                    return PARM_FLOAT;
                case 59:
                    return PARM_INTEGER;
                case 60:
                    return PARM_STRING;
                case 61:
                    return PARM_STRING;
                case 62:
                    return PARM_FLOAT;
                case 63:
                    return PARM_INTEGER;
                case 64:
                    return PARM_STRING;
                case 65:
                    return PARM_STRING;
                case 66:
                    return PARM_STRING;
                case 67:
                    return PARM_INTEGER;
                case 68:
                    return PARM_FLOAT;
                case 69:
                    return PARM_INTEGER;
                case 70:
                    return PARM_STRING;
                case 71:
                    return PARM_STRING;
                case 72:
                    return PARM_STRING;
                case 73:
                    return PARM_RAMP;
                case 74:
                    return PARM_FLOAT;
                case 75:
                    return PARM_INTEGER;
                case 76:
                    return PARM_STRING;
                case 77:
                    return PARM_STRING;
                case 78:
                    return PARM_STRING;
                case 79:
                    return PARM_STRING;
                case 80:
                    return PARM_RAMP;
                case 81:
                    return PARM_STRING;
                case 82:
                    return PARM_STRING;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myLegacymasking);
        saveData(os, myUvattrib);
        saveData(os, myBlend);
        saveData(os, myBlendoverride);
        saveData(os, myBlendcurveattrib);
        saveData(os, myBlendattrib);
        saveData(os, myBlendtexture);
        saveData(os, myUseskinmask);
        saveData(os, mySkinmaskattrib);
        saveData(os, myClumpsize);
        saveData(os, myClumpsizeoverride);
        saveData(os, myClumpsizeattrib);
        saveData(os, myClumpsizetexture);
        saveData(os, mySearchbeyondradius);
        saveData(os, myClumpwithinclumps);
        saveData(os, myCrossoverrate);
        saveData(os, mySeed);
        saveData(os, myMethod);
        saveData(os, myPreservelength);
        saveData(os, myExtendtomatch);
        saveData(os, myShortentomatch);
        saveData(os, myAccuratebundling);
        saveData(os, myHairwidth);
        saveData(os, myHairwidthscale);
        saveData(os, myTightness);
        saveData(os, myTightnessoverride);
        saveData(os, myTightnesscurveattrib);
        saveData(os, myTightnessclumpattrib);
        saveData(os, myTightnessattrib);
        saveData(os, myTightnesstexture);
        saveData(os, myStrayamount);
        saveData(os, myStrayamountoverride);
        saveData(os, myStrayamountcurveattrib);
        saveData(os, myStrayamountclumpattrib);
        saveData(os, myStrayamountattrib);
        saveData(os, myStrayamounttexture);
        saveData(os, myStrayrate);
        saveData(os, myStrayrateoverride);
        saveData(os, myStrayratecurveattrib);
        saveData(os, myStrayrateclumpattrib);
        saveData(os, myStrayrateattrib);
        saveData(os, myStrayratetexture);
        saveData(os, myStrayfalloff);
        saveData(os, myStrayfalloffoverride);
        saveData(os, myStrayfalloffcurveattrib);
        saveData(os, myStrayfalloffclumpattrib);
        saveData(os, myStrayfalloffattrib);
        saveData(os, myStrayfallofftexture);
        saveData(os, myClumpprofile);
        saveData(os, myIterations);
        saveData(os, myIterationsoverride);
        saveData(os, myIterationscurveattrib);
        saveData(os, myIterationsattrib);
        saveData(os, myIterationstexture);
        saveData(os, mySizereduction);
        saveData(os, mySizereductionoverride);
        saveData(os, mySizereductionattrib);
        saveData(os, mySizereductiontexture);
        saveData(os, myGoalfeedback);
        saveData(os, myGoalfeedbackoverride);
        saveData(os, myGoalfeedbackattrib);
        saveData(os, myGoalfeedbacktexture);
        saveData(os, myTightnessreduction);
        saveData(os, myTightnessreductionoverride);
        saveData(os, myTightnessreductioncurveattrib);
        saveData(os, myTightnessreductionattrib);
        saveData(os, myTightnessreductiontexture);
        saveData(os, myEnablecurling);
        saveData(os, myCurlamp);
        saveData(os, myCurlampoverride);
        saveData(os, myCurlampcurveattrib);
        saveData(os, myCurlampattrib);
        saveData(os, myCurlamptexture);
        saveData(os, myCurlampramp);
        saveData(os, myCurlfreq);
        saveData(os, myCurlfreqoverride);
        saveData(os, myCurlfreqcurveattrib);
        saveData(os, myCurveattrib);
        saveData(os, myCurlfreqattrib);
        saveData(os, myCurlfreqtexture);
        saveData(os, myCurlfreqramp);
        saveData(os, myClumppointattribs);
        saveData(os, myClumpprimattribs);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myLegacymasking);
        loadData(is, myUvattrib);
        loadData(is, myBlend);
        loadData(is, myBlendoverride);
        loadData(is, myBlendcurveattrib);
        loadData(is, myBlendattrib);
        loadData(is, myBlendtexture);
        loadData(is, myUseskinmask);
        loadData(is, mySkinmaskattrib);
        loadData(is, myClumpsize);
        loadData(is, myClumpsizeoverride);
        loadData(is, myClumpsizeattrib);
        loadData(is, myClumpsizetexture);
        loadData(is, mySearchbeyondradius);
        loadData(is, myClumpwithinclumps);
        loadData(is, myCrossoverrate);
        loadData(is, mySeed);
        loadData(is, myMethod);
        loadData(is, myPreservelength);
        loadData(is, myExtendtomatch);
        loadData(is, myShortentomatch);
        loadData(is, myAccuratebundling);
        loadData(is, myHairwidth);
        loadData(is, myHairwidthscale);
        loadData(is, myTightness);
        loadData(is, myTightnessoverride);
        loadData(is, myTightnesscurveattrib);
        loadData(is, myTightnessclumpattrib);
        loadData(is, myTightnessattrib);
        loadData(is, myTightnesstexture);
        loadData(is, myStrayamount);
        loadData(is, myStrayamountoverride);
        loadData(is, myStrayamountcurveattrib);
        loadData(is, myStrayamountclumpattrib);
        loadData(is, myStrayamountattrib);
        loadData(is, myStrayamounttexture);
        loadData(is, myStrayrate);
        loadData(is, myStrayrateoverride);
        loadData(is, myStrayratecurveattrib);
        loadData(is, myStrayrateclumpattrib);
        loadData(is, myStrayrateattrib);
        loadData(is, myStrayratetexture);
        loadData(is, myStrayfalloff);
        loadData(is, myStrayfalloffoverride);
        loadData(is, myStrayfalloffcurveattrib);
        loadData(is, myStrayfalloffclumpattrib);
        loadData(is, myStrayfalloffattrib);
        loadData(is, myStrayfallofftexture);
        loadData(is, myClumpprofile);
        loadData(is, myIterations);
        loadData(is, myIterationsoverride);
        loadData(is, myIterationscurveattrib);
        loadData(is, myIterationsattrib);
        loadData(is, myIterationstexture);
        loadData(is, mySizereduction);
        loadData(is, mySizereductionoverride);
        loadData(is, mySizereductionattrib);
        loadData(is, mySizereductiontexture);
        loadData(is, myGoalfeedback);
        loadData(is, myGoalfeedbackoverride);
        loadData(is, myGoalfeedbackattrib);
        loadData(is, myGoalfeedbacktexture);
        loadData(is, myTightnessreduction);
        loadData(is, myTightnessreductionoverride);
        loadData(is, myTightnessreductioncurveattrib);
        loadData(is, myTightnessreductionattrib);
        loadData(is, myTightnessreductiontexture);
        loadData(is, myEnablecurling);
        loadData(is, myCurlamp);
        loadData(is, myCurlampoverride);
        loadData(is, myCurlampcurveattrib);
        loadData(is, myCurlampattrib);
        loadData(is, myCurlamptexture);
        loadData(is, myCurlampramp);
        loadData(is, myCurlfreq);
        loadData(is, myCurlfreqoverride);
        loadData(is, myCurlfreqcurveattrib);
        loadData(is, myCurveattrib);
        loadData(is, myCurlfreqattrib);
        loadData(is, myCurlfreqtexture);
        loadData(is, myCurlfreqramp);
        loadData(is, myClumppointattribs);
        loadData(is, myClumpprimattribs);

        return true;
    }

    bool getLegacymasking() const { return myLegacymasking; }
    void setLegacymasking(bool val) { myLegacymasking = val; }
    bool opLegacymasking(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLegacymasking();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "legacymasking", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getUvattrib() const { return myUvattrib; }
    void setUvattrib(const UT_StringHolder & val) { myUvattrib = val; }
    UT_StringHolder opUvattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUvattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "uvattrib", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getBlend() const { return myBlend; }
    void setBlend(fpreal64 val) { myBlend = val; }
    fpreal64 opBlend(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBlend();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "blend", cookparms.getCookTime(), 0);
        return result;
    }
    Blendoverride getBlendoverride() const { return Blendoverride(myBlendoverride); }
    void setBlendoverride(Blendoverride val) { myBlendoverride = int64(val); }
    Blendoverride opBlendoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBlendoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "blendoverride", cookparms.getCookTime(), 0);
        return Blendoverride(result);
    }
    const UT_StringHolder & getBlendcurveattrib() const { return myBlendcurveattrib; }
    void setBlendcurveattrib(const UT_StringHolder & val) { myBlendcurveattrib = val; }
    UT_StringHolder opBlendcurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBlendcurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "blendcurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getBlendattrib() const { return myBlendattrib; }
    void setBlendattrib(const UT_StringHolder & val) { myBlendattrib = val; }
    UT_StringHolder opBlendattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBlendattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "blendattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getBlendtexture() const { return myBlendtexture; }
    void setBlendtexture(const UT_StringHolder & val) { myBlendtexture = val; }
    UT_StringHolder opBlendtexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBlendtexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "blendtexture", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseskinmask() const { return myUseskinmask; }
    void setUseskinmask(bool val) { myUseskinmask = val; }
    bool opUseskinmask(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseskinmask();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useskinmask", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getSkinmaskattrib() const { return mySkinmaskattrib; }
    void setSkinmaskattrib(const UT_StringHolder & val) { mySkinmaskattrib = val; }
    UT_StringHolder opSkinmaskattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSkinmaskattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "skinmaskattrib", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getClumpsize() const { return myClumpsize; }
    void setClumpsize(fpreal64 val) { myClumpsize = val; }
    fpreal64 opClumpsize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpsize();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "clumpsize", cookparms.getCookTime(), 0);
        return result;
    }
    Clumpsizeoverride getClumpsizeoverride() const { return Clumpsizeoverride(myClumpsizeoverride); }
    void setClumpsizeoverride(Clumpsizeoverride val) { myClumpsizeoverride = int64(val); }
    Clumpsizeoverride opClumpsizeoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpsizeoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "clumpsizeoverride", cookparms.getCookTime(), 0);
        return Clumpsizeoverride(result);
    }
    const UT_StringHolder & getClumpsizeattrib() const { return myClumpsizeattrib; }
    void setClumpsizeattrib(const UT_StringHolder & val) { myClumpsizeattrib = val; }
    UT_StringHolder opClumpsizeattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpsizeattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "clumpsizeattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getClumpsizetexture() const { return myClumpsizetexture; }
    void setClumpsizetexture(const UT_StringHolder & val) { myClumpsizetexture = val; }
    UT_StringHolder opClumpsizetexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpsizetexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "clumpsizetexture", cookparms.getCookTime(), 0);
        return result;
    }
    bool getSearchbeyondradius() const { return mySearchbeyondradius; }
    void setSearchbeyondradius(bool val) { mySearchbeyondradius = val; }
    bool opSearchbeyondradius(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSearchbeyondradius();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "searchbeyondradius", cookparms.getCookTime(), 0);
        return result;
    }
    bool getClumpwithinclumps() const { return myClumpwithinclumps; }
    void setClumpwithinclumps(bool val) { myClumpwithinclumps = val; }
    bool opClumpwithinclumps(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpwithinclumps();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "clumpwithinclumps", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getCrossoverrate() const { return myCrossoverrate; }
    void setCrossoverrate(fpreal64 val) { myCrossoverrate = val; }
    fpreal64 opCrossoverrate(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCrossoverrate();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "crossoverrate", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getSeed() const { return mySeed; }
    void setSeed(fpreal64 val) { mySeed = val; }
    fpreal64 opSeed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSeed();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "seed", cookparms.getCookTime(), 0);
        return result;
    }
    Method getMethod() const { return Method(myMethod); }
    void setMethod(Method val) { myMethod = int64(val); }
    Method opMethod(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMethod();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "method", cookparms.getCookTime(), 0);
        return Method(result);
    }
    bool getPreservelength() const { return myPreservelength; }
    void setPreservelength(bool val) { myPreservelength = val; }
    bool opPreservelength(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPreservelength();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "preservelength", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getExtendtomatch() const { return myExtendtomatch; }
    void setExtendtomatch(fpreal64 val) { myExtendtomatch = val; }
    fpreal64 opExtendtomatch(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getExtendtomatch();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "extendtomatch", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getShortentomatch() const { return myShortentomatch; }
    void setShortentomatch(fpreal64 val) { myShortentomatch = val; }
    fpreal64 opShortentomatch(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getShortentomatch();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "shortentomatch", cookparms.getCookTime(), 0);
        return result;
    }
    bool getAccuratebundling() const { return myAccuratebundling; }
    void setAccuratebundling(bool val) { myAccuratebundling = val; }
    bool opAccuratebundling(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAccuratebundling();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "accuratebundling", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getHairwidth() const { return myHairwidth; }
    void setHairwidth(fpreal64 val) { myHairwidth = val; }
    fpreal64 opHairwidth(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getHairwidth();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "hairwidth", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getHairwidthscale() const { return myHairwidthscale; }
    void setHairwidthscale(fpreal64 val) { myHairwidthscale = val; }
    fpreal64 opHairwidthscale(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getHairwidthscale();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "hairwidthscale", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getTightness() const { return myTightness; }
    void setTightness(fpreal64 val) { myTightness = val; }
    fpreal64 opTightness(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightness();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "tightness", cookparms.getCookTime(), 0);
        return result;
    }
    Tightnessoverride getTightnessoverride() const { return Tightnessoverride(myTightnessoverride); }
    void setTightnessoverride(Tightnessoverride val) { myTightnessoverride = int64(val); }
    Tightnessoverride opTightnessoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnessoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "tightnessoverride", cookparms.getCookTime(), 0);
        return Tightnessoverride(result);
    }
    const UT_StringHolder & getTightnesscurveattrib() const { return myTightnesscurveattrib; }
    void setTightnesscurveattrib(const UT_StringHolder & val) { myTightnesscurveattrib = val; }
    UT_StringHolder opTightnesscurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnesscurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "tightnesscurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTightnessclumpattrib() const { return myTightnessclumpattrib; }
    void setTightnessclumpattrib(const UT_StringHolder & val) { myTightnessclumpattrib = val; }
    UT_StringHolder opTightnessclumpattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnessclumpattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "tightnessclumpattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTightnessattrib() const { return myTightnessattrib; }
    void setTightnessattrib(const UT_StringHolder & val) { myTightnessattrib = val; }
    UT_StringHolder opTightnessattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnessattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "tightnessattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTightnesstexture() const { return myTightnesstexture; }
    void setTightnesstexture(const UT_StringHolder & val) { myTightnesstexture = val; }
    UT_StringHolder opTightnesstexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnesstexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "tightnesstexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getStrayamount() const { return myStrayamount; }
    void setStrayamount(fpreal64 val) { myStrayamount = val; }
    fpreal64 opStrayamount(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayamount();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "strayamount", cookparms.getCookTime(), 0);
        return result;
    }
    Strayamountoverride getStrayamountoverride() const { return Strayamountoverride(myStrayamountoverride); }
    void setStrayamountoverride(Strayamountoverride val) { myStrayamountoverride = int64(val); }
    Strayamountoverride opStrayamountoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayamountoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "strayamountoverride", cookparms.getCookTime(), 0);
        return Strayamountoverride(result);
    }
    const UT_StringHolder & getStrayamountcurveattrib() const { return myStrayamountcurveattrib; }
    void setStrayamountcurveattrib(const UT_StringHolder & val) { myStrayamountcurveattrib = val; }
    UT_StringHolder opStrayamountcurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayamountcurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayamountcurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getStrayamountclumpattrib() const { return myStrayamountclumpattrib; }
    void setStrayamountclumpattrib(const UT_StringHolder & val) { myStrayamountclumpattrib = val; }
    UT_StringHolder opStrayamountclumpattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayamountclumpattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayamountclumpattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getStrayamountattrib() const { return myStrayamountattrib; }
    void setStrayamountattrib(const UT_StringHolder & val) { myStrayamountattrib = val; }
    UT_StringHolder opStrayamountattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayamountattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayamountattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getStrayamounttexture() const { return myStrayamounttexture; }
    void setStrayamounttexture(const UT_StringHolder & val) { myStrayamounttexture = val; }
    UT_StringHolder opStrayamounttexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayamounttexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayamounttexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getStrayrate() const { return myStrayrate; }
    void setStrayrate(fpreal64 val) { myStrayrate = val; }
    fpreal64 opStrayrate(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayrate();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "strayrate", cookparms.getCookTime(), 0);
        return result;
    }
    Strayrateoverride getStrayrateoverride() const { return Strayrateoverride(myStrayrateoverride); }
    void setStrayrateoverride(Strayrateoverride val) { myStrayrateoverride = int64(val); }
    Strayrateoverride opStrayrateoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayrateoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "strayrateoverride", cookparms.getCookTime(), 0);
        return Strayrateoverride(result);
    }
    const UT_StringHolder & getStrayratecurveattrib() const { return myStrayratecurveattrib; }
    void setStrayratecurveattrib(const UT_StringHolder & val) { myStrayratecurveattrib = val; }
    UT_StringHolder opStrayratecurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayratecurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayratecurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getStrayrateclumpattrib() const { return myStrayrateclumpattrib; }
    void setStrayrateclumpattrib(const UT_StringHolder & val) { myStrayrateclumpattrib = val; }
    UT_StringHolder opStrayrateclumpattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayrateclumpattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayrateclumpattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getStrayrateattrib() const { return myStrayrateattrib; }
    void setStrayrateattrib(const UT_StringHolder & val) { myStrayrateattrib = val; }
    UT_StringHolder opStrayrateattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayrateattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayrateattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getStrayratetexture() const { return myStrayratetexture; }
    void setStrayratetexture(const UT_StringHolder & val) { myStrayratetexture = val; }
    UT_StringHolder opStrayratetexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayratetexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayratetexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getStrayfalloff() const { return myStrayfalloff; }
    void setStrayfalloff(fpreal64 val) { myStrayfalloff = val; }
    fpreal64 opStrayfalloff(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayfalloff();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "strayfalloff", cookparms.getCookTime(), 0);
        return result;
    }
    Strayfalloffoverride getStrayfalloffoverride() const { return Strayfalloffoverride(myStrayfalloffoverride); }
    void setStrayfalloffoverride(Strayfalloffoverride val) { myStrayfalloffoverride = int64(val); }
    Strayfalloffoverride opStrayfalloffoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayfalloffoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "strayfalloffoverride", cookparms.getCookTime(), 0);
        return Strayfalloffoverride(result);
    }
    const UT_StringHolder & getStrayfalloffcurveattrib() const { return myStrayfalloffcurveattrib; }
    void setStrayfalloffcurveattrib(const UT_StringHolder & val) { myStrayfalloffcurveattrib = val; }
    UT_StringHolder opStrayfalloffcurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayfalloffcurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayfalloffcurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getStrayfalloffclumpattrib() const { return myStrayfalloffclumpattrib; }
    void setStrayfalloffclumpattrib(const UT_StringHolder & val) { myStrayfalloffclumpattrib = val; }
    UT_StringHolder opStrayfalloffclumpattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayfalloffclumpattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayfalloffclumpattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getStrayfalloffattrib() const { return myStrayfalloffattrib; }
    void setStrayfalloffattrib(const UT_StringHolder & val) { myStrayfalloffattrib = val; }
    UT_StringHolder opStrayfalloffattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayfalloffattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayfalloffattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getStrayfallofftexture() const { return myStrayfallofftexture; }
    void setStrayfallofftexture(const UT_StringHolder & val) { myStrayfallofftexture = val; }
    UT_StringHolder opStrayfallofftexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStrayfallofftexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "strayfallofftexture", cookparms.getCookTime(), 0);
        return result;
    }
    UT_SharedPtr<UT_Ramp> getClumpprofile() const { return myClumpprofile; }
    void setClumpprofile(UT_SharedPtr<UT_Ramp> val) { myClumpprofile = val; }
    UT_SharedPtr<UT_Ramp> opClumpprofile(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpprofile();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "clumpprofile", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getIterations() const { return myIterations; }
    void setIterations(fpreal64 val) { myIterations = val; }
    fpreal64 opIterations(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIterations();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "iterations", cookparms.getCookTime(), 0);
        return result;
    }
    Iterationsoverride getIterationsoverride() const { return Iterationsoverride(myIterationsoverride); }
    void setIterationsoverride(Iterationsoverride val) { myIterationsoverride = int64(val); }
    Iterationsoverride opIterationsoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIterationsoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "iterationsoverride", cookparms.getCookTime(), 0);
        return Iterationsoverride(result);
    }
    const UT_StringHolder & getIterationscurveattrib() const { return myIterationscurveattrib; }
    void setIterationscurveattrib(const UT_StringHolder & val) { myIterationscurveattrib = val; }
    UT_StringHolder opIterationscurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIterationscurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "iterationscurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getIterationsattrib() const { return myIterationsattrib; }
    void setIterationsattrib(const UT_StringHolder & val) { myIterationsattrib = val; }
    UT_StringHolder opIterationsattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIterationsattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "iterationsattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getIterationstexture() const { return myIterationstexture; }
    void setIterationstexture(const UT_StringHolder & val) { myIterationstexture = val; }
    UT_StringHolder opIterationstexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIterationstexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "iterationstexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getSizereduction() const { return mySizereduction; }
    void setSizereduction(fpreal64 val) { mySizereduction = val; }
    fpreal64 opSizereduction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSizereduction();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "sizereduction", cookparms.getCookTime(), 0);
        return result;
    }
    Sizereductionoverride getSizereductionoverride() const { return Sizereductionoverride(mySizereductionoverride); }
    void setSizereductionoverride(Sizereductionoverride val) { mySizereductionoverride = int64(val); }
    Sizereductionoverride opSizereductionoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSizereductionoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "sizereductionoverride", cookparms.getCookTime(), 0);
        return Sizereductionoverride(result);
    }
    const UT_StringHolder & getSizereductionattrib() const { return mySizereductionattrib; }
    void setSizereductionattrib(const UT_StringHolder & val) { mySizereductionattrib = val; }
    UT_StringHolder opSizereductionattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSizereductionattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "sizereductionattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getSizereductiontexture() const { return mySizereductiontexture; }
    void setSizereductiontexture(const UT_StringHolder & val) { mySizereductiontexture = val; }
    UT_StringHolder opSizereductiontexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSizereductiontexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "sizereductiontexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getGoalfeedback() const { return myGoalfeedback; }
    void setGoalfeedback(fpreal64 val) { myGoalfeedback = val; }
    fpreal64 opGoalfeedback(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGoalfeedback();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "goalfeedback", cookparms.getCookTime(), 0);
        return result;
    }
    Goalfeedbackoverride getGoalfeedbackoverride() const { return Goalfeedbackoverride(myGoalfeedbackoverride); }
    void setGoalfeedbackoverride(Goalfeedbackoverride val) { myGoalfeedbackoverride = int64(val); }
    Goalfeedbackoverride opGoalfeedbackoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGoalfeedbackoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "goalfeedbackoverride", cookparms.getCookTime(), 0);
        return Goalfeedbackoverride(result);
    }
    const UT_StringHolder & getGoalfeedbackattrib() const { return myGoalfeedbackattrib; }
    void setGoalfeedbackattrib(const UT_StringHolder & val) { myGoalfeedbackattrib = val; }
    UT_StringHolder opGoalfeedbackattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGoalfeedbackattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "goalfeedbackattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getGoalfeedbacktexture() const { return myGoalfeedbacktexture; }
    void setGoalfeedbacktexture(const UT_StringHolder & val) { myGoalfeedbacktexture = val; }
    UT_StringHolder opGoalfeedbacktexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGoalfeedbacktexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "goalfeedbacktexture", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getTightnessreduction() const { return myTightnessreduction; }
    void setTightnessreduction(fpreal64 val) { myTightnessreduction = val; }
    fpreal64 opTightnessreduction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnessreduction();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "tightnessreduction", cookparms.getCookTime(), 0);
        return result;
    }
    Tightnessreductionoverride getTightnessreductionoverride() const { return Tightnessreductionoverride(myTightnessreductionoverride); }
    void setTightnessreductionoverride(Tightnessreductionoverride val) { myTightnessreductionoverride = int64(val); }
    Tightnessreductionoverride opTightnessreductionoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnessreductionoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "tightnessreductionoverride", cookparms.getCookTime(), 0);
        return Tightnessreductionoverride(result);
    }
    const UT_StringHolder & getTightnessreductioncurveattrib() const { return myTightnessreductioncurveattrib; }
    void setTightnessreductioncurveattrib(const UT_StringHolder & val) { myTightnessreductioncurveattrib = val; }
    UT_StringHolder opTightnessreductioncurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnessreductioncurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "tightnessreductioncurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTightnessreductionattrib() const { return myTightnessreductionattrib; }
    void setTightnessreductionattrib(const UT_StringHolder & val) { myTightnessreductionattrib = val; }
    UT_StringHolder opTightnessreductionattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnessreductionattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "tightnessreductionattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTightnessreductiontexture() const { return myTightnessreductiontexture; }
    void setTightnessreductiontexture(const UT_StringHolder & val) { myTightnessreductiontexture = val; }
    UT_StringHolder opTightnessreductiontexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTightnessreductiontexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "tightnessreductiontexture", cookparms.getCookTime(), 0);
        return result;
    }
    bool getEnablecurling() const { return myEnablecurling; }
    void setEnablecurling(bool val) { myEnablecurling = val; }
    bool opEnablecurling(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEnablecurling();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "enablecurling", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getCurlamp() const { return myCurlamp; }
    void setCurlamp(fpreal64 val) { myCurlamp = val; }
    fpreal64 opCurlamp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlamp();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "curlamp", cookparms.getCookTime(), 0);
        return result;
    }
    Curlampoverride getCurlampoverride() const { return Curlampoverride(myCurlampoverride); }
    void setCurlampoverride(Curlampoverride val) { myCurlampoverride = int64(val); }
    Curlampoverride opCurlampoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlampoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "curlampoverride", cookparms.getCookTime(), 0);
        return Curlampoverride(result);
    }
    const UT_StringHolder & getCurlampcurveattrib() const { return myCurlampcurveattrib; }
    void setCurlampcurveattrib(const UT_StringHolder & val) { myCurlampcurveattrib = val; }
    UT_StringHolder opCurlampcurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlampcurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "curlampcurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getCurlampattrib() const { return myCurlampattrib; }
    void setCurlampattrib(const UT_StringHolder & val) { myCurlampattrib = val; }
    UT_StringHolder opCurlampattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlampattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "curlampattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getCurlamptexture() const { return myCurlamptexture; }
    void setCurlamptexture(const UT_StringHolder & val) { myCurlamptexture = val; }
    UT_StringHolder opCurlamptexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlamptexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "curlamptexture", cookparms.getCookTime(), 0);
        return result;
    }
    UT_SharedPtr<UT_Ramp> getCurlampramp() const { return myCurlampramp; }
    void setCurlampramp(UT_SharedPtr<UT_Ramp> val) { myCurlampramp = val; }
    UT_SharedPtr<UT_Ramp> opCurlampramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlampramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "curlampramp", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getCurlfreq() const { return myCurlfreq; }
    void setCurlfreq(fpreal64 val) { myCurlfreq = val; }
    fpreal64 opCurlfreq(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlfreq();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "curlfreq", cookparms.getCookTime(), 0);
        return result;
    }
    Curlfreqoverride getCurlfreqoverride() const { return Curlfreqoverride(myCurlfreqoverride); }
    void setCurlfreqoverride(Curlfreqoverride val) { myCurlfreqoverride = int64(val); }
    Curlfreqoverride opCurlfreqoverride(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlfreqoverride();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "curlfreqoverride", cookparms.getCookTime(), 0);
        return Curlfreqoverride(result);
    }
    const UT_StringHolder & getCurlfreqcurveattrib() const { return myCurlfreqcurveattrib; }
    void setCurlfreqcurveattrib(const UT_StringHolder & val) { myCurlfreqcurveattrib = val; }
    UT_StringHolder opCurlfreqcurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlfreqcurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "curlfreqcurveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getCurveattrib() const { return myCurveattrib; }
    void setCurveattrib(const UT_StringHolder & val) { myCurveattrib = val; }
    UT_StringHolder opCurveattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurveattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "curveattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getCurlfreqattrib() const { return myCurlfreqattrib; }
    void setCurlfreqattrib(const UT_StringHolder & val) { myCurlfreqattrib = val; }
    UT_StringHolder opCurlfreqattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlfreqattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "curlfreqattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getCurlfreqtexture() const { return myCurlfreqtexture; }
    void setCurlfreqtexture(const UT_StringHolder & val) { myCurlfreqtexture = val; }
    UT_StringHolder opCurlfreqtexture(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlfreqtexture();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "curlfreqtexture", cookparms.getCookTime(), 0);
        return result;
    }
    UT_SharedPtr<UT_Ramp> getCurlfreqramp() const { return myCurlfreqramp; }
    void setCurlfreqramp(UT_SharedPtr<UT_Ramp> val) { myCurlfreqramp = val; }
    UT_SharedPtr<UT_Ramp> opCurlfreqramp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurlfreqramp();
        UT_SharedPtr<UT_Ramp> result;
        OP_Utils::evalOpParm(result, thissop, "curlfreqramp", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getClumppointattribs() const { return myClumppointattribs; }
    void setClumppointattribs(const UT_StringHolder & val) { myClumppointattribs = val; }
    UT_StringHolder opClumppointattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumppointattribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "clumppointattribs", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getClumpprimattribs() const { return myClumpprimattribs; }
    void setClumpprimattribs(const UT_StringHolder & val) { myClumpprimattribs = val; }
    UT_StringHolder opClumpprimattribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getClumpprimattribs();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "clumpprimattribs", cookparms.getCookTime(), 0);
        return result;
    }

private:
    bool myLegacymasking;
    UT_StringHolder myUvattrib;
    fpreal64 myBlend;
    int64 myBlendoverride;
    UT_StringHolder myBlendcurveattrib;
    UT_StringHolder myBlendattrib;
    UT_StringHolder myBlendtexture;
    bool myUseskinmask;
    UT_StringHolder mySkinmaskattrib;
    fpreal64 myClumpsize;
    int64 myClumpsizeoverride;
    UT_StringHolder myClumpsizeattrib;
    UT_StringHolder myClumpsizetexture;
    bool mySearchbeyondradius;
    bool myClumpwithinclumps;
    fpreal64 myCrossoverrate;
    fpreal64 mySeed;
    int64 myMethod;
    bool myPreservelength;
    fpreal64 myExtendtomatch;
    fpreal64 myShortentomatch;
    bool myAccuratebundling;
    fpreal64 myHairwidth;
    fpreal64 myHairwidthscale;
    fpreal64 myTightness;
    int64 myTightnessoverride;
    UT_StringHolder myTightnesscurveattrib;
    UT_StringHolder myTightnessclumpattrib;
    UT_StringHolder myTightnessattrib;
    UT_StringHolder myTightnesstexture;
    fpreal64 myStrayamount;
    int64 myStrayamountoverride;
    UT_StringHolder myStrayamountcurveattrib;
    UT_StringHolder myStrayamountclumpattrib;
    UT_StringHolder myStrayamountattrib;
    UT_StringHolder myStrayamounttexture;
    fpreal64 myStrayrate;
    int64 myStrayrateoverride;
    UT_StringHolder myStrayratecurveattrib;
    UT_StringHolder myStrayrateclumpattrib;
    UT_StringHolder myStrayrateattrib;
    UT_StringHolder myStrayratetexture;
    fpreal64 myStrayfalloff;
    int64 myStrayfalloffoverride;
    UT_StringHolder myStrayfalloffcurveattrib;
    UT_StringHolder myStrayfalloffclumpattrib;
    UT_StringHolder myStrayfalloffattrib;
    UT_StringHolder myStrayfallofftexture;
    UT_SharedPtr<UT_Ramp> myClumpprofile;
    fpreal64 myIterations;
    int64 myIterationsoverride;
    UT_StringHolder myIterationscurveattrib;
    UT_StringHolder myIterationsattrib;
    UT_StringHolder myIterationstexture;
    fpreal64 mySizereduction;
    int64 mySizereductionoverride;
    UT_StringHolder mySizereductionattrib;
    UT_StringHolder mySizereductiontexture;
    fpreal64 myGoalfeedback;
    int64 myGoalfeedbackoverride;
    UT_StringHolder myGoalfeedbackattrib;
    UT_StringHolder myGoalfeedbacktexture;
    fpreal64 myTightnessreduction;
    int64 myTightnessreductionoverride;
    UT_StringHolder myTightnessreductioncurveattrib;
    UT_StringHolder myTightnessreductionattrib;
    UT_StringHolder myTightnessreductiontexture;
    bool myEnablecurling;
    fpreal64 myCurlamp;
    int64 myCurlampoverride;
    UT_StringHolder myCurlampcurveattrib;
    UT_StringHolder myCurlampattrib;
    UT_StringHolder myCurlamptexture;
    UT_SharedPtr<UT_Ramp> myCurlampramp;
    fpreal64 myCurlfreq;
    int64 myCurlfreqoverride;
    UT_StringHolder myCurlfreqcurveattrib;
    UT_StringHolder myCurveattrib;
    UT_StringHolder myCurlfreqattrib;
    UT_StringHolder myCurlfreqtexture;
    UT_SharedPtr<UT_Ramp> myCurlfreqramp;
    UT_StringHolder myClumppointattribs;
    UT_StringHolder myClumpprimattribs;

};
