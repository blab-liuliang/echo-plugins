/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_Sweep_2_0Enums
{
    enum class CopyOrder
    {
        ALL = 0,
        EACH,
        CYCLEVTX,
        CYCLEPR,
        ATTRIB
    };
    enum class SurfaceShape
    {
        NONE = 0,
        RIBBON,
        TUBE
    };
    enum class SurfaceType
    {
        POINTS = 0,
        ROWS,
        COLS,
        ROWCOL,
        TRIS,
        QUADS,
        ALTTRIS,
        REVTRIS,
        COPYPTS,
        COPYPRIMS
    };
    enum class EndCapType
    {
        NONE = 0,
        SINGLE,
        FLAT,
        POINTED,
        ROUND
    };
    enum class TangentType
    {
        CIRCULAR = 0,
        SUBD,
        PREV,
        NEXT,
        NONE
    };
    enum class TwistPer
    {
        EDGE = 0,
        DISTANCE,
        UV,
        FULLEDGES,
        FULLDISTANCE
    };
    enum class SpinPer
    {
        EDGE = 0,
        DISTANCE,
        UV,
        FULLEDGES,
        FULLDISTANCE
    };
    enum class TumblePer
    {
        EDGE = 0,
        DISTANCE,
        UV,
        FULLEDGES,
        FULLDISTANCE
    };
}


class SOP_API SOP_Sweep_2_0Parms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_Sweep_2_0Parms()
    {
        myCrossSectionGroup = ""_sh;
        myCurveGroup = ""_sh;
        myComputeUVs = false;
        myOverrideExistingUVs = false;
        myLengthWeightedUVs = false;
        mySeparateVs = false;
        myCopyOrder = 2;
        myCrossSectionAttrib = "id"_sh;
        mySurfaceShape = 0;
        myNumVEdges = 8;
        myRadius = 0.1;
        mySurfaceType = 5;
        myUnrollClosedRowCol = false;
        myEndCapType = 1;
        myCapDivs = 3;
        myAddMetaData = false;
        myDeleteAllCurves = false;
        myScale = 1;
        myTangentType = 0;
        myExtrapolateEndTangents = false;
        myUpVector = UT_Vector3D(0,1,0);
        myUseNormalUp = false;
        myTransformByAttribs = false;
        myStretchAroundTurns = false;
        myMaxStretchAroundTurns = 10;
        myRoll = 0;
        myTwist = 0;
        myTwistPer = 0;
        myYaw = 0;
        mySpin = 0;
        mySpinPer = 0;
        myPitch = 0;
        myTumble = 0;
        myTumblePer = 0;
        myOutputXAxis = false;
        myXAxisName = "bitangent"_sh;
        myOutputYAxis = false;
        myYAxisName = "up"_sh;
        myOutputZAxis = false;
        myZAxisName = "N"_sh;

    }

    explicit SOP_Sweep_2_0Parms(const SOP_Sweep_2_0Parms &) = default;

    virtual ~SOP_Sweep_2_0Parms() {}

    bool operator==(const SOP_Sweep_2_0Parms &src) const
    {
        if (myCrossSectionGroup != src.myCrossSectionGroup) return false;
        if (myCurveGroup != src.myCurveGroup) return false;
        if (myComputeUVs != src.myComputeUVs) return false;
        if (myOverrideExistingUVs != src.myOverrideExistingUVs) return false;
        if (myLengthWeightedUVs != src.myLengthWeightedUVs) return false;
        if (mySeparateVs != src.mySeparateVs) return false;
        if (myCopyOrder != src.myCopyOrder) return false;
        if (myCrossSectionAttrib != src.myCrossSectionAttrib) return false;
        if (mySurfaceShape != src.mySurfaceShape) return false;
        if (myNumVEdges != src.myNumVEdges) return false;
        if (myRadius != src.myRadius) return false;
        if (mySurfaceType != src.mySurfaceType) return false;
        if (myUnrollClosedRowCol != src.myUnrollClosedRowCol) return false;
        if (myEndCapType != src.myEndCapType) return false;
        if (myCapDivs != src.myCapDivs) return false;
        if (myAddMetaData != src.myAddMetaData) return false;
        if (myDeleteAllCurves != src.myDeleteAllCurves) return false;
        if (myScale != src.myScale) return false;
        if (myTangentType != src.myTangentType) return false;
        if (myExtrapolateEndTangents != src.myExtrapolateEndTangents) return false;
        if (myUpVector != src.myUpVector) return false;
        if (myUseNormalUp != src.myUseNormalUp) return false;
        if (myTransformByAttribs != src.myTransformByAttribs) return false;
        if (myStretchAroundTurns != src.myStretchAroundTurns) return false;
        if (myMaxStretchAroundTurns != src.myMaxStretchAroundTurns) return false;
        if (myRoll != src.myRoll) return false;
        if (myTwist != src.myTwist) return false;
        if (myTwistPer != src.myTwistPer) return false;
        if (myYaw != src.myYaw) return false;
        if (mySpin != src.mySpin) return false;
        if (mySpinPer != src.mySpinPer) return false;
        if (myPitch != src.myPitch) return false;
        if (myTumble != src.myTumble) return false;
        if (myTumblePer != src.myTumblePer) return false;
        if (myOutputXAxis != src.myOutputXAxis) return false;
        if (myXAxisName != src.myXAxisName) return false;
        if (myOutputYAxis != src.myOutputYAxis) return false;
        if (myYAxisName != src.myYAxisName) return false;
        if (myOutputZAxis != src.myOutputZAxis) return false;
        if (myZAxisName != src.myZAxisName) return false;

        return true;
    }
    bool operator!=(const SOP_Sweep_2_0Parms &src) const
    {
        return !operator==(src);
    }
    using CopyOrder = SOP_Sweep_2_0Enums::CopyOrder;
    using SurfaceShape = SOP_Sweep_2_0Enums::SurfaceShape;
    using SurfaceType = SOP_Sweep_2_0Enums::SurfaceType;
    using EndCapType = SOP_Sweep_2_0Enums::EndCapType;
    using TangentType = SOP_Sweep_2_0Enums::TangentType;
    using TwistPer = SOP_Sweep_2_0Enums::TwistPer;
    using SpinPer = SOP_Sweep_2_0Enums::SpinPer;
    using TumblePer = SOP_Sweep_2_0Enums::TumblePer;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myCrossSectionGroup, node, "crosssectiongroup", time, 0);
        else myCrossSectionGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myCurveGroup, node, "curvegroup", time, 0);
        else myCurveGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myComputeUVs, node, "computeuvs", time, 0);
        else myComputeUVs = false;
        if (true && ( (!(((getComputeUVs()==0)))) ) )
            OP_Utils::evalOpParm(myOverrideExistingUVs, node, "overrideexistinguvs", time, 0);
        else myOverrideExistingUVs = false;
        if (true && ( (!(((getComputeUVs()==0)))) ) )
            OP_Utils::evalOpParm(myLengthWeightedUVs, node, "lengthweighteduvs", time, 0);
        else myLengthWeightedUVs = false;
        if (true && ( (!(((getComputeUVs()==0)))) ) )
            OP_Utils::evalOpParm(mySeparateVs, node, "separatevs", time, 0);
        else mySeparateVs = false;
        if (true && ( (!((((node->getInput(0)!=0)==0))||(((node->getInput(1)!=0)==0)))) ) )
            OP_Utils::evalOpParm(myCopyOrder, node, "copyorder", time, 0);
        else myCopyOrder = 2;
        if (true && ( (!((((node->getInput(0)!=0)==0))||(((node->getInput(1)!=0)==0))||((int64(getCopyOrder())!=4))||((int64(getCopyOrder())!=4)))) ) )
            OP_Utils::evalOpParm(myCrossSectionAttrib, node, "crosssectionattrib", time, 0);
        else myCrossSectionAttrib = "id"_sh;
        if (true && ( (!((((node->getInput(0)!=0)==1)))) ) )
            OP_Utils::evalOpParm(mySurfaceShape, node, "surfaceshape", time, 0);
        else mySurfaceShape = 0;
        if (true && ( (!((((node->getInput(0)!=0)==1))||((int64(getSurfaceShape())==0)))) ) )
            OP_Utils::evalOpParm(myNumVEdges, node, "numvedges", time, 0);
        else myNumVEdges = 8;
        if (true && ( (!((((node->getInput(0)!=0)==1))||((int64(getSurfaceShape())==0)))) ) )
            OP_Utils::evalOpParm(myRadius, node, "radius", time, 0);
        else myRadius = 0.1;
        if (true)
            OP_Utils::evalOpParm(mySurfaceType, node, "surfacetype", time, 0);
        else mySurfaceType = 5;
        if (true && ( (!(((int64(getSurfaceType())!=1)&&(int64(getSurfaceType())!=2)&&(int64(getSurfaceType())!=3)))) ) )
            OP_Utils::evalOpParm(myUnrollClosedRowCol, node, "unrollclosedrowcol", time, 0);
        else myUnrollClosedRowCol = false;
        if (true)
            OP_Utils::evalOpParm(myEndCapType, node, "endcaptype", time, 0);
        else myEndCapType = 1;
        if (true && ( (!(((int64(getEndCapType())==0))||((int64(getEndCapType())==1)))) ) )
            OP_Utils::evalOpParm(myCapDivs, node, "capdivs", time, 0);
        else myCapDivs = 3;
        if (true)
            OP_Utils::evalOpParm(myAddMetaData, node, "addmetadata", time, 0);
        else myAddMetaData = false;
        if (true && ( (!((((node->getInput(0)!=0)==0)&&(int64(getSurfaceShape())!=0)))) ) )
            OP_Utils::evalOpParm(myDeleteAllCurves, node, "deleteallcurves", time, 0);
        else myDeleteAllCurves = false;
        if (true)
            OP_Utils::evalOpParm(myScale, node, "scale", time, 0);
        else myScale = 1;
        if (true)
            OP_Utils::evalOpParm(myTangentType, node, "tangenttype", time, 0);
        else myTangentType = 0;
        if (true && ( (!(((int64(getTangentType())==4)))) ) )
            OP_Utils::evalOpParm(myExtrapolateEndTangents, node, "extrapolateendtangents", time, 0);
        else myExtrapolateEndTangents = false;
        if (true && ( (!(((int64(getTangentType())==4)))) ) )
            OP_Utils::evalOpParm(myUpVector, node, "upvector", time, 0);
        else myUpVector = UT_Vector3D(0,1,0);
        if (true)
            OP_Utils::evalOpParm(myUseNormalUp, node, "usenormalup", time, 0);
        else myUseNormalUp = false;
        if (true)
            OP_Utils::evalOpParm(myTransformByAttribs, node, "transformbyattribs", time, 0);
        else myTransformByAttribs = false;
        if (true)
            OP_Utils::evalOpParm(myStretchAroundTurns, node, "stretcharoundturns", time, 0);
        else myStretchAroundTurns = false;
        if (true)
            OP_Utils::evalOpParm(myMaxStretchAroundTurns, node, "maxstretcharoundturns", time, 0);
        else myMaxStretchAroundTurns = 10;
        if (true)
            OP_Utils::evalOpParm(myRoll, node, "roll", time, 0);
        else myRoll = 0;
        if (true)
            OP_Utils::evalOpParm(myTwist, node, "twist", time, 0);
        else myTwist = 0;
        if (true)
            OP_Utils::evalOpParm(myTwistPer, node, "twistper", time, 0);
        else myTwistPer = 0;
        if (true)
            OP_Utils::evalOpParm(myYaw, node, "yaw", time, 0);
        else myYaw = 0;
        if (true)
            OP_Utils::evalOpParm(mySpin, node, "spin", time, 0);
        else mySpin = 0;
        if (true)
            OP_Utils::evalOpParm(mySpinPer, node, "spinper", time, 0);
        else mySpinPer = 0;
        if (true)
            OP_Utils::evalOpParm(myPitch, node, "pitch", time, 0);
        else myPitch = 0;
        if (true)
            OP_Utils::evalOpParm(myTumble, node, "tumble", time, 0);
        else myTumble = 0;
        if (true)
            OP_Utils::evalOpParm(myTumblePer, node, "tumbleper", time, 0);
        else myTumblePer = 0;
        if (true && ( (!((((node->getInput(0)!=0)==0)&&(int64(getSurfaceShape())!=0)))) ) )
            OP_Utils::evalOpParm(myOutputXAxis, node, "outputxaxis", time, 0);
        else myOutputXAxis = false;
        if (true && ( (!((((node->getInput(0)!=0)==0)&&(int64(getSurfaceShape())!=0))||((getOutputXAxis()==0)))) ) )
            OP_Utils::evalOpParm(myXAxisName, node, "xaxisname", time, 0);
        else myXAxisName = "bitangent"_sh;
        if (true && ( (!((((node->getInput(0)!=0)==0)&&(int64(getSurfaceShape())!=0)))) ) )
            OP_Utils::evalOpParm(myOutputYAxis, node, "outputyaxis", time, 0);
        else myOutputYAxis = false;
        if (true && ( (!((((node->getInput(0)!=0)==0)&&(int64(getSurfaceShape())!=0))||((getOutputYAxis()==0)))) ) )
            OP_Utils::evalOpParm(myYAxisName, node, "yaxisname", time, 0);
        else myYAxisName = "up"_sh;
        if (true && ( (!((((node->getInput(0)!=0)==0)&&(int64(getSurfaceShape())!=0)))) ) )
            OP_Utils::evalOpParm(myOutputZAxis, node, "outputzaxis", time, 0);
        else myOutputZAxis = false;
        if (true && ( (!((((node->getInput(0)!=0)==0)&&(int64(getSurfaceShape())!=0))||((getOutputZAxis()==0)))) ) )
            OP_Utils::evalOpParm(myZAxisName, node, "zaxisname", time, 0);
        else myZAxisName = "N"_sh;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_Sweep_2_0Parms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myCrossSectionGroup);
                break;
            case 1:
                coerceValue(value, myCurveGroup);
                break;
            case 2:
                coerceValue(value, myComputeUVs);
                break;
            case 3:
                coerceValue(value, myOverrideExistingUVs);
                break;
            case 4:
                coerceValue(value, myLengthWeightedUVs);
                break;
            case 5:
                coerceValue(value, mySeparateVs);
                break;
            case 6:
                coerceValue(value, myCopyOrder);
                break;
            case 7:
                coerceValue(value, myCrossSectionAttrib);
                break;
            case 8:
                coerceValue(value, mySurfaceShape);
                break;
            case 9:
                coerceValue(value, myNumVEdges);
                break;
            case 10:
                coerceValue(value, myRadius);
                break;
            case 11:
                coerceValue(value, mySurfaceType);
                break;
            case 12:
                coerceValue(value, myUnrollClosedRowCol);
                break;
            case 13:
                coerceValue(value, myEndCapType);
                break;
            case 14:
                coerceValue(value, myCapDivs);
                break;
            case 15:
                coerceValue(value, myAddMetaData);
                break;
            case 16:
                coerceValue(value, myDeleteAllCurves);
                break;
            case 17:
                coerceValue(value, myScale);
                break;
            case 18:
                coerceValue(value, myTangentType);
                break;
            case 19:
                coerceValue(value, myExtrapolateEndTangents);
                break;
            case 20:
                coerceValue(value, myUpVector);
                break;
            case 21:
                coerceValue(value, myUseNormalUp);
                break;
            case 22:
                coerceValue(value, myTransformByAttribs);
                break;
            case 23:
                coerceValue(value, myStretchAroundTurns);
                break;
            case 24:
                coerceValue(value, myMaxStretchAroundTurns);
                break;
            case 25:
                coerceValue(value, myRoll);
                break;
            case 26:
                coerceValue(value, myTwist);
                break;
            case 27:
                coerceValue(value, myTwistPer);
                break;
            case 28:
                coerceValue(value, myYaw);
                break;
            case 29:
                coerceValue(value, mySpin);
                break;
            case 30:
                coerceValue(value, mySpinPer);
                break;
            case 31:
                coerceValue(value, myPitch);
                break;
            case 32:
                coerceValue(value, myTumble);
                break;
            case 33:
                coerceValue(value, myTumblePer);
                break;
            case 34:
                coerceValue(value, myOutputXAxis);
                break;
            case 35:
                coerceValue(value, myXAxisName);
                break;
            case 36:
                coerceValue(value, myOutputYAxis);
                break;
            case 37:
                coerceValue(value, myYAxisName);
                break;
            case 38:
                coerceValue(value, myOutputZAxis);
                break;
            case 39:
                coerceValue(value, myZAxisName);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myCrossSectionGroup, value);
                break;
            case 1:
                coerceValue(myCurveGroup, value);
                break;
            case 2:
                coerceValue(myComputeUVs, value);
                break;
            case 3:
                coerceValue(myOverrideExistingUVs, value);
                break;
            case 4:
                coerceValue(myLengthWeightedUVs, value);
                break;
            case 5:
                coerceValue(mySeparateVs, value);
                break;
            case 6:
                coerceValue(myCopyOrder, value);
                break;
            case 7:
                coerceValue(myCrossSectionAttrib, value);
                break;
            case 8:
                coerceValue(mySurfaceShape, value);
                break;
            case 9:
                coerceValue(myNumVEdges, value);
                break;
            case 10:
                coerceValue(myRadius, value);
                break;
            case 11:
                coerceValue(mySurfaceType, value);
                break;
            case 12:
                coerceValue(myUnrollClosedRowCol, value);
                break;
            case 13:
                coerceValue(myEndCapType, value);
                break;
            case 14:
                coerceValue(myCapDivs, value);
                break;
            case 15:
                coerceValue(myAddMetaData, value);
                break;
            case 16:
                coerceValue(myDeleteAllCurves, value);
                break;
            case 17:
                coerceValue(myScale, value);
                break;
            case 18:
                coerceValue(myTangentType, value);
                break;
            case 19:
                coerceValue(myExtrapolateEndTangents, value);
                break;
            case 20:
                coerceValue(myUpVector, value);
                break;
            case 21:
                coerceValue(myUseNormalUp, value);
                break;
            case 22:
                coerceValue(myTransformByAttribs, value);
                break;
            case 23:
                coerceValue(myStretchAroundTurns, value);
                break;
            case 24:
                coerceValue(myMaxStretchAroundTurns, value);
                break;
            case 25:
                coerceValue(myRoll, value);
                break;
            case 26:
                coerceValue(myTwist, value);
                break;
            case 27:
                coerceValue(myTwistPer, value);
                break;
            case 28:
                coerceValue(myYaw, value);
                break;
            case 29:
                coerceValue(mySpin, value);
                break;
            case 30:
                coerceValue(mySpinPer, value);
                break;
            case 31:
                coerceValue(myPitch, value);
                break;
            case 32:
                coerceValue(myTumble, value);
                break;
            case 33:
                coerceValue(myTumblePer, value);
                break;
            case 34:
                coerceValue(myOutputXAxis, value);
                break;
            case 35:
                coerceValue(myXAxisName, value);
                break;
            case 36:
                coerceValue(myOutputYAxis, value);
                break;
            case 37:
                coerceValue(myYAxisName, value);
                break;
            case 38:
                coerceValue(myOutputZAxis, value);
                break;
            case 39:
                coerceValue(myZAxisName, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 40;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "crosssectiongroup";
            case 1:
                return "curvegroup";
            case 2:
                return "computeuvs";
            case 3:
                return "overrideexistinguvs";
            case 4:
                return "lengthweighteduvs";
            case 5:
                return "separatevs";
            case 6:
                return "copyorder";
            case 7:
                return "crosssectionattrib";
            case 8:
                return "surfaceshape";
            case 9:
                return "numvedges";
            case 10:
                return "radius";
            case 11:
                return "surfacetype";
            case 12:
                return "unrollclosedrowcol";
            case 13:
                return "endcaptype";
            case 14:
                return "capdivs";
            case 15:
                return "addmetadata";
            case 16:
                return "deleteallcurves";
            case 17:
                return "scale";
            case 18:
                return "tangenttype";
            case 19:
                return "extrapolateendtangents";
            case 20:
                return "upvector";
            case 21:
                return "usenormalup";
            case 22:
                return "transformbyattribs";
            case 23:
                return "stretcharoundturns";
            case 24:
                return "maxstretcharoundturns";
            case 25:
                return "roll";
            case 26:
                return "twist";
            case 27:
                return "twistper";
            case 28:
                return "yaw";
            case 29:
                return "spin";
            case 30:
                return "spinper";
            case 31:
                return "pitch";
            case 32:
                return "tumble";
            case 33:
                return "tumbleper";
            case 34:
                return "outputxaxis";
            case 35:
                return "xaxisname";
            case 36:
                return "outputyaxis";
            case 37:
                return "yaxisname";
            case 38:
                return "outputzaxis";
            case 39:
                return "zaxisname";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_STRING;
                case 2:
                    return PARM_INTEGER;
                case 3:
                    return PARM_INTEGER;
                case 4:
                    return PARM_INTEGER;
                case 5:
                    return PARM_INTEGER;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_STRING;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_FLOAT;
                case 11:
                    return PARM_INTEGER;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_INTEGER;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_INTEGER;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_FLOAT;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_INTEGER;
                case 20:
                    return PARM_VECTOR3;
                case 21:
                    return PARM_INTEGER;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_INTEGER;
                case 24:
                    return PARM_FLOAT;
                case 25:
                    return PARM_FLOAT;
                case 26:
                    return PARM_FLOAT;
                case 27:
                    return PARM_INTEGER;
                case 28:
                    return PARM_FLOAT;
                case 29:
                    return PARM_FLOAT;
                case 30:
                    return PARM_INTEGER;
                case 31:
                    return PARM_FLOAT;
                case 32:
                    return PARM_FLOAT;
                case 33:
                    return PARM_INTEGER;
                case 34:
                    return PARM_INTEGER;
                case 35:
                    return PARM_STRING;
                case 36:
                    return PARM_INTEGER;
                case 37:
                    return PARM_STRING;
                case 38:
                    return PARM_INTEGER;
                case 39:
                    return PARM_STRING;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myCrossSectionGroup);
        saveData(os, myCurveGroup);
        saveData(os, myComputeUVs);
        saveData(os, myOverrideExistingUVs);
        saveData(os, myLengthWeightedUVs);
        saveData(os, mySeparateVs);
        saveData(os, myCopyOrder);
        saveData(os, myCrossSectionAttrib);
        saveData(os, mySurfaceShape);
        saveData(os, myNumVEdges);
        saveData(os, myRadius);
        saveData(os, mySurfaceType);
        saveData(os, myUnrollClosedRowCol);
        saveData(os, myEndCapType);
        saveData(os, myCapDivs);
        saveData(os, myAddMetaData);
        saveData(os, myDeleteAllCurves);
        saveData(os, myScale);
        saveData(os, myTangentType);
        saveData(os, myExtrapolateEndTangents);
        saveData(os, myUpVector);
        saveData(os, myUseNormalUp);
        saveData(os, myTransformByAttribs);
        saveData(os, myStretchAroundTurns);
        saveData(os, myMaxStretchAroundTurns);
        saveData(os, myRoll);
        saveData(os, myTwist);
        saveData(os, myTwistPer);
        saveData(os, myYaw);
        saveData(os, mySpin);
        saveData(os, mySpinPer);
        saveData(os, myPitch);
        saveData(os, myTumble);
        saveData(os, myTumblePer);
        saveData(os, myOutputXAxis);
        saveData(os, myXAxisName);
        saveData(os, myOutputYAxis);
        saveData(os, myYAxisName);
        saveData(os, myOutputZAxis);
        saveData(os, myZAxisName);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myCrossSectionGroup);
        loadData(is, myCurveGroup);
        loadData(is, myComputeUVs);
        loadData(is, myOverrideExistingUVs);
        loadData(is, myLengthWeightedUVs);
        loadData(is, mySeparateVs);
        loadData(is, myCopyOrder);
        loadData(is, myCrossSectionAttrib);
        loadData(is, mySurfaceShape);
        loadData(is, myNumVEdges);
        loadData(is, myRadius);
        loadData(is, mySurfaceType);
        loadData(is, myUnrollClosedRowCol);
        loadData(is, myEndCapType);
        loadData(is, myCapDivs);
        loadData(is, myAddMetaData);
        loadData(is, myDeleteAllCurves);
        loadData(is, myScale);
        loadData(is, myTangentType);
        loadData(is, myExtrapolateEndTangents);
        loadData(is, myUpVector);
        loadData(is, myUseNormalUp);
        loadData(is, myTransformByAttribs);
        loadData(is, myStretchAroundTurns);
        loadData(is, myMaxStretchAroundTurns);
        loadData(is, myRoll);
        loadData(is, myTwist);
        loadData(is, myTwistPer);
        loadData(is, myYaw);
        loadData(is, mySpin);
        loadData(is, mySpinPer);
        loadData(is, myPitch);
        loadData(is, myTumble);
        loadData(is, myTumblePer);
        loadData(is, myOutputXAxis);
        loadData(is, myXAxisName);
        loadData(is, myOutputYAxis);
        loadData(is, myYAxisName);
        loadData(is, myOutputZAxis);
        loadData(is, myZAxisName);

        return true;
    }

    const UT_StringHolder & getCrossSectionGroup() const { return myCrossSectionGroup; }
    void setCrossSectionGroup(const UT_StringHolder & val) { myCrossSectionGroup = val; }
    UT_StringHolder opCrossSectionGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCrossSectionGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "crosssectiongroup", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getCurveGroup() const { return myCurveGroup; }
    void setCurveGroup(const UT_StringHolder & val) { myCurveGroup = val; }
    UT_StringHolder opCurveGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCurveGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "curvegroup", cookparms.getCookTime(), 0);
        return result;
    }
    bool getComputeUVs() const { return myComputeUVs; }
    void setComputeUVs(bool val) { myComputeUVs = val; }
    bool opComputeUVs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getComputeUVs();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "computeuvs", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOverrideExistingUVs() const { return myOverrideExistingUVs; }
    void setOverrideExistingUVs(bool val) { myOverrideExistingUVs = val; }
    bool opOverrideExistingUVs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOverrideExistingUVs();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "overrideexistinguvs", cookparms.getCookTime(), 0);
        return result;
    }
    bool getLengthWeightedUVs() const { return myLengthWeightedUVs; }
    void setLengthWeightedUVs(bool val) { myLengthWeightedUVs = val; }
    bool opLengthWeightedUVs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthWeightedUVs();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "lengthweighteduvs", cookparms.getCookTime(), 0);
        return result;
    }
    bool getSeparateVs() const { return mySeparateVs; }
    void setSeparateVs(bool val) { mySeparateVs = val; }
    bool opSeparateVs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSeparateVs();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "separatevs", cookparms.getCookTime(), 0);
        return result;
    }
    CopyOrder getCopyOrder() const { return CopyOrder(myCopyOrder); }
    void setCopyOrder(CopyOrder val) { myCopyOrder = int64(val); }
    CopyOrder opCopyOrder(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCopyOrder();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "copyorder", cookparms.getCookTime(), 0);
        return CopyOrder(result);
    }
    const UT_StringHolder & getCrossSectionAttrib() const { return myCrossSectionAttrib; }
    void setCrossSectionAttrib(const UT_StringHolder & val) { myCrossSectionAttrib = val; }
    UT_StringHolder opCrossSectionAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCrossSectionAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "crosssectionattrib", cookparms.getCookTime(), 0);
        return result;
    }
    SurfaceShape getSurfaceShape() const { return SurfaceShape(mySurfaceShape); }
    void setSurfaceShape(SurfaceShape val) { mySurfaceShape = int64(val); }
    SurfaceShape opSurfaceShape(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSurfaceShape();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "surfaceshape", cookparms.getCookTime(), 0);
        return SurfaceShape(result);
    }
    int64 getNumVEdges() const { return myNumVEdges; }
    void setNumVEdges(int64 val) { myNumVEdges = val; }
    int64 opNumVEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNumVEdges();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "numvedges", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getRadius() const { return myRadius; }
    void setRadius(fpreal64 val) { myRadius = val; }
    fpreal64 opRadius(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRadius();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "radius", cookparms.getCookTime(), 0);
        return result;
    }
    SurfaceType getSurfaceType() const { return SurfaceType(mySurfaceType); }
    void setSurfaceType(SurfaceType val) { mySurfaceType = int64(val); }
    SurfaceType opSurfaceType(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSurfaceType();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "surfacetype", cookparms.getCookTime(), 0);
        return SurfaceType(result);
    }
    bool getUnrollClosedRowCol() const { return myUnrollClosedRowCol; }
    void setUnrollClosedRowCol(bool val) { myUnrollClosedRowCol = val; }
    bool opUnrollClosedRowCol(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUnrollClosedRowCol();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "unrollclosedrowcol", cookparms.getCookTime(), 0);
        return result;
    }
    EndCapType getEndCapType() const { return EndCapType(myEndCapType); }
    void setEndCapType(EndCapType val) { myEndCapType = int64(val); }
    EndCapType opEndCapType(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getEndCapType();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "endcaptype", cookparms.getCookTime(), 0);
        return EndCapType(result);
    }
    int64 getCapDivs() const { return myCapDivs; }
    void setCapDivs(int64 val) { myCapDivs = val; }
    int64 opCapDivs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCapDivs();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "capdivs", cookparms.getCookTime(), 0);
        return result;
    }
    bool getAddMetaData() const { return myAddMetaData; }
    void setAddMetaData(bool val) { myAddMetaData = val; }
    bool opAddMetaData(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAddMetaData();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "addmetadata", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDeleteAllCurves() const { return myDeleteAllCurves; }
    void setDeleteAllCurves(bool val) { myDeleteAllCurves = val; }
    bool opDeleteAllCurves(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDeleteAllCurves();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "deleteallcurves", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getScale() const { return myScale; }
    void setScale(fpreal64 val) { myScale = val; }
    fpreal64 opScale(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getScale();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "scale", cookparms.getCookTime(), 0);
        return result;
    }
    TangentType getTangentType() const { return TangentType(myTangentType); }
    void setTangentType(TangentType val) { myTangentType = int64(val); }
    TangentType opTangentType(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTangentType();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "tangenttype", cookparms.getCookTime(), 0);
        return TangentType(result);
    }
    bool getExtrapolateEndTangents() const { return myExtrapolateEndTangents; }
    void setExtrapolateEndTangents(bool val) { myExtrapolateEndTangents = val; }
    bool opExtrapolateEndTangents(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getExtrapolateEndTangents();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "extrapolateendtangents", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getUpVector() const { return myUpVector; }
    void setUpVector(UT_Vector3D val) { myUpVector = val; }
    UT_Vector3D opUpVector(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUpVector();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "upvector", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseNormalUp() const { return myUseNormalUp; }
    void setUseNormalUp(bool val) { myUseNormalUp = val; }
    bool opUseNormalUp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseNormalUp();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usenormalup", cookparms.getCookTime(), 0);
        return result;
    }
    bool getTransformByAttribs() const { return myTransformByAttribs; }
    void setTransformByAttribs(bool val) { myTransformByAttribs = val; }
    bool opTransformByAttribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTransformByAttribs();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "transformbyattribs", cookparms.getCookTime(), 0);
        return result;
    }
    bool getStretchAroundTurns() const { return myStretchAroundTurns; }
    void setStretchAroundTurns(bool val) { myStretchAroundTurns = val; }
    bool opStretchAroundTurns(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getStretchAroundTurns();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "stretcharoundturns", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getMaxStretchAroundTurns() const { return myMaxStretchAroundTurns; }
    void setMaxStretchAroundTurns(fpreal64 val) { myMaxStretchAroundTurns = val; }
    fpreal64 opMaxStretchAroundTurns(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxStretchAroundTurns();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "maxstretcharoundturns", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getRoll() const { return myRoll; }
    void setRoll(fpreal64 val) { myRoll = val; }
    fpreal64 opRoll(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRoll();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "roll", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getTwist() const { return myTwist; }
    void setTwist(fpreal64 val) { myTwist = val; }
    fpreal64 opTwist(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTwist();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "twist", cookparms.getCookTime(), 0);
        return result;
    }
    TwistPer getTwistPer() const { return TwistPer(myTwistPer); }
    void setTwistPer(TwistPer val) { myTwistPer = int64(val); }
    TwistPer opTwistPer(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTwistPer();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "twistper", cookparms.getCookTime(), 0);
        return TwistPer(result);
    }
    fpreal64 getYaw() const { return myYaw; }
    void setYaw(fpreal64 val) { myYaw = val; }
    fpreal64 opYaw(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getYaw();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "yaw", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getSpin() const { return mySpin; }
    void setSpin(fpreal64 val) { mySpin = val; }
    fpreal64 opSpin(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSpin();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "spin", cookparms.getCookTime(), 0);
        return result;
    }
    SpinPer getSpinPer() const { return SpinPer(mySpinPer); }
    void setSpinPer(SpinPer val) { mySpinPer = int64(val); }
    SpinPer opSpinPer(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSpinPer();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "spinper", cookparms.getCookTime(), 0);
        return SpinPer(result);
    }
    fpreal64 getPitch() const { return myPitch; }
    void setPitch(fpreal64 val) { myPitch = val; }
    fpreal64 opPitch(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPitch();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "pitch", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getTumble() const { return myTumble; }
    void setTumble(fpreal64 val) { myTumble = val; }
    fpreal64 opTumble(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTumble();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "tumble", cookparms.getCookTime(), 0);
        return result;
    }
    TumblePer getTumblePer() const { return TumblePer(myTumblePer); }
    void setTumblePer(TumblePer val) { myTumblePer = int64(val); }
    TumblePer opTumblePer(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTumblePer();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "tumbleper", cookparms.getCookTime(), 0);
        return TumblePer(result);
    }
    bool getOutputXAxis() const { return myOutputXAxis; }
    void setOutputXAxis(bool val) { myOutputXAxis = val; }
    bool opOutputXAxis(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputXAxis();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "outputxaxis", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getXAxisName() const { return myXAxisName; }
    void setXAxisName(const UT_StringHolder & val) { myXAxisName = val; }
    UT_StringHolder opXAxisName(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getXAxisName();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "xaxisname", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOutputYAxis() const { return myOutputYAxis; }
    void setOutputYAxis(bool val) { myOutputYAxis = val; }
    bool opOutputYAxis(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputYAxis();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "outputyaxis", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getYAxisName() const { return myYAxisName; }
    void setYAxisName(const UT_StringHolder & val) { myYAxisName = val; }
    UT_StringHolder opYAxisName(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getYAxisName();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "yaxisname", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOutputZAxis() const { return myOutputZAxis; }
    void setOutputZAxis(bool val) { myOutputZAxis = val; }
    bool opOutputZAxis(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutputZAxis();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "outputzaxis", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getZAxisName() const { return myZAxisName; }
    void setZAxisName(const UT_StringHolder & val) { myZAxisName = val; }
    UT_StringHolder opZAxisName(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getZAxisName();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "zaxisname", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myCrossSectionGroup;
    UT_StringHolder myCurveGroup;
    bool myComputeUVs;
    bool myOverrideExistingUVs;
    bool myLengthWeightedUVs;
    bool mySeparateVs;
    int64 myCopyOrder;
    UT_StringHolder myCrossSectionAttrib;
    int64 mySurfaceShape;
    int64 myNumVEdges;
    fpreal64 myRadius;
    int64 mySurfaceType;
    bool myUnrollClosedRowCol;
    int64 myEndCapType;
    int64 myCapDivs;
    bool myAddMetaData;
    bool myDeleteAllCurves;
    fpreal64 myScale;
    int64 myTangentType;
    bool myExtrapolateEndTangents;
    UT_Vector3D myUpVector;
    bool myUseNormalUp;
    bool myTransformByAttribs;
    bool myStretchAroundTurns;
    fpreal64 myMaxStretchAroundTurns;
    fpreal64 myRoll;
    fpreal64 myTwist;
    int64 myTwistPer;
    fpreal64 myYaw;
    fpreal64 mySpin;
    int64 mySpinPer;
    fpreal64 myPitch;
    fpreal64 myTumble;
    int64 myTumblePer;
    bool myOutputXAxis;
    UT_StringHolder myXAxisName;
    bool myOutputYAxis;
    UT_StringHolder myYAxisName;
    bool myOutputZAxis;
    UT_StringHolder myZAxisName;

};
