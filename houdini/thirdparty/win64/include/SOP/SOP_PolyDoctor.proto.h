/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_PolyDoctorEnums
{
    enum class IllFormedAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class ManyEdgesAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class NonConvexAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class OverlappingAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class SelfIntersectingAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class GloballySmallAreasAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class LocallySmallAreasAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class NonUniformAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class GloballySmallEdgesAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class LocallySmallEdgesAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class DisconnectedPointsAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
    enum class NonManifoldPointsAction
    {
        IGNORE = 0,
        MARK,
        REPAIR
    };
}


class SOP_API SOP_PolyDoctorParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_PolyDoctorParms()
    {
        myGroup = ""_sh;
        myMaxPasses = 50;
        myRandomSeed = 3;
        myIllFormedAction = 2;
        myManyEdgesAction = 2;
        myNonConvexAction = 2;
        myOverlappingAction = 2;
        myPairOverlaps = false;
        mySelfIntersectingAction = 1;
        myThickness = 0.0001;
        myGloballySmallAreasAction = 0;
        myGlobalAreaThreshold = 1e-06;
        myLocallySmallAreasAction = 0;
        myLocalAreaThreshold = 0.01;
        myNonUniformAction = 0;
        myUniformityThreshold = 0.01;
        myGloballySmallEdgesAction = 0;
        myGlobalEdgeThreshold = 0.001;
        myLocallySmallEdgesAction = 0;
        myLocalEdgeThreshold = 0.3;
        myDisconnectedPointsAction = 0;
        myNonManifoldPointsAction = 0;
        myIgnoreWindings = false;
        myPreferLargeAngles = false;
        myVisualizeMaxManifold = false;
        myExportManifoldNumbers = false;
        myFixWindings = false;
        myDeleteSmallManifolds = false;
        mySmallManifoldSize = 0;
        myAddValidPolyAttrib = false;
        myValidPolyAttribName = "valid_poly"_sh;
        myAddRepairedPolyAttrib = false;
        myRepairedPolyAttribName = "repaired_poly"_sh;
        myAddValidPtsAttrib = false;
        myValidPtsAttribName = "valid_pt"_sh;
        myAddModifiedPtsAttrib = false;
        myModifiedPtsAttribName = "modified_pt"_sh;
        myCreateGroups = false;
        myVisualizeInvalidPts = false;
        myInvalidPtsColor = UT_Vector3D(0.9,0,0);
        myVisualizeRepairedPts = false;
        myRepairedPtsColor = UT_Vector3D(0,0,0.9);
        myVisualizeInvalidPolys = false;
        myInvalidPolysColor = UT_Vector3D(0.9,0,0);
        myVisualizeRepairedPolys = false;
        myRepairedPolysColor = UT_Vector3D(0,0,0.9);

    }

    explicit SOP_PolyDoctorParms(const SOP_PolyDoctorParms &) = default;

    virtual ~SOP_PolyDoctorParms() {}

    bool operator==(const SOP_PolyDoctorParms &src) const
    {
        if (myGroup != src.myGroup) return false;
        if (myMaxPasses != src.myMaxPasses) return false;
        if (myRandomSeed != src.myRandomSeed) return false;
        if (myIllFormedAction != src.myIllFormedAction) return false;
        if (myManyEdgesAction != src.myManyEdgesAction) return false;
        if (myNonConvexAction != src.myNonConvexAction) return false;
        if (myOverlappingAction != src.myOverlappingAction) return false;
        if (myPairOverlaps != src.myPairOverlaps) return false;
        if (mySelfIntersectingAction != src.mySelfIntersectingAction) return false;
        if (myThickness != src.myThickness) return false;
        if (myGloballySmallAreasAction != src.myGloballySmallAreasAction) return false;
        if (myGlobalAreaThreshold != src.myGlobalAreaThreshold) return false;
        if (myLocallySmallAreasAction != src.myLocallySmallAreasAction) return false;
        if (myLocalAreaThreshold != src.myLocalAreaThreshold) return false;
        if (myNonUniformAction != src.myNonUniformAction) return false;
        if (myUniformityThreshold != src.myUniformityThreshold) return false;
        if (myGloballySmallEdgesAction != src.myGloballySmallEdgesAction) return false;
        if (myGlobalEdgeThreshold != src.myGlobalEdgeThreshold) return false;
        if (myLocallySmallEdgesAction != src.myLocallySmallEdgesAction) return false;
        if (myLocalEdgeThreshold != src.myLocalEdgeThreshold) return false;
        if (myDisconnectedPointsAction != src.myDisconnectedPointsAction) return false;
        if (myNonManifoldPointsAction != src.myNonManifoldPointsAction) return false;
        if (myIgnoreWindings != src.myIgnoreWindings) return false;
        if (myPreferLargeAngles != src.myPreferLargeAngles) return false;
        if (myVisualizeMaxManifold != src.myVisualizeMaxManifold) return false;
        if (myExportManifoldNumbers != src.myExportManifoldNumbers) return false;
        if (myFixWindings != src.myFixWindings) return false;
        if (myDeleteSmallManifolds != src.myDeleteSmallManifolds) return false;
        if (mySmallManifoldSize != src.mySmallManifoldSize) return false;
        if (myAddValidPolyAttrib != src.myAddValidPolyAttrib) return false;
        if (myValidPolyAttribName != src.myValidPolyAttribName) return false;
        if (myAddRepairedPolyAttrib != src.myAddRepairedPolyAttrib) return false;
        if (myRepairedPolyAttribName != src.myRepairedPolyAttribName) return false;
        if (myAddValidPtsAttrib != src.myAddValidPtsAttrib) return false;
        if (myValidPtsAttribName != src.myValidPtsAttribName) return false;
        if (myAddModifiedPtsAttrib != src.myAddModifiedPtsAttrib) return false;
        if (myModifiedPtsAttribName != src.myModifiedPtsAttribName) return false;
        if (myCreateGroups != src.myCreateGroups) return false;
        if (myVisualizeInvalidPts != src.myVisualizeInvalidPts) return false;
        if (myInvalidPtsColor != src.myInvalidPtsColor) return false;
        if (myVisualizeRepairedPts != src.myVisualizeRepairedPts) return false;
        if (myRepairedPtsColor != src.myRepairedPtsColor) return false;
        if (myVisualizeInvalidPolys != src.myVisualizeInvalidPolys) return false;
        if (myInvalidPolysColor != src.myInvalidPolysColor) return false;
        if (myVisualizeRepairedPolys != src.myVisualizeRepairedPolys) return false;
        if (myRepairedPolysColor != src.myRepairedPolysColor) return false;

        return true;
    }
    bool operator!=(const SOP_PolyDoctorParms &src) const
    {
        return !operator==(src);
    }
    using IllFormedAction = SOP_PolyDoctorEnums::IllFormedAction;
    using ManyEdgesAction = SOP_PolyDoctorEnums::ManyEdgesAction;
    using NonConvexAction = SOP_PolyDoctorEnums::NonConvexAction;
    using OverlappingAction = SOP_PolyDoctorEnums::OverlappingAction;
    using SelfIntersectingAction = SOP_PolyDoctorEnums::SelfIntersectingAction;
    using GloballySmallAreasAction = SOP_PolyDoctorEnums::GloballySmallAreasAction;
    using LocallySmallAreasAction = SOP_PolyDoctorEnums::LocallySmallAreasAction;
    using NonUniformAction = SOP_PolyDoctorEnums::NonUniformAction;
    using GloballySmallEdgesAction = SOP_PolyDoctorEnums::GloballySmallEdgesAction;
    using LocallySmallEdgesAction = SOP_PolyDoctorEnums::LocallySmallEdgesAction;
    using DisconnectedPointsAction = SOP_PolyDoctorEnums::DisconnectedPointsAction;
    using NonManifoldPointsAction = SOP_PolyDoctorEnums::NonManifoldPointsAction;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myGroup, node, "group", time, 0);
        else myGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myMaxPasses, node, "maxpasses", time, 0);
        else myMaxPasses = 50;
        if (true)
            OP_Utils::evalOpParm(myRandomSeed, node, "randomseed", time, 0);
        else myRandomSeed = 3;
        if (true)
            OP_Utils::evalOpParm(myIllFormedAction, node, "illformed", time, 0);
        else myIllFormedAction = 2;
        if (true && ( (!(((int64(getIllFormedAction())==0)))) ) )
            OP_Utils::evalOpParm(myManyEdgesAction, node, "manyedges", time, 0);
        else myManyEdgesAction = 2;
        if (true && ( (!(((int64(getIllFormedAction())==0))||((int64(getManyEdgesAction())==0)))) ) )
            OP_Utils::evalOpParm(myNonConvexAction, node, "nonconvex", time, 0);
        else myNonConvexAction = 2;
        if (true && ( (!(((int64(getIllFormedAction())==0)))) ) )
            OP_Utils::evalOpParm(myOverlappingAction, node, "overlapping", time, 0);
        else myOverlappingAction = 2;
        if (true && ( (!(((int64(getIllFormedAction())==0))||((int64(getOverlappingAction())==0)))) ) )
            OP_Utils::evalOpParm(myPairOverlaps, node, "pairoverlaps", time, 0);
        else myPairOverlaps = false;
        if (true && ( (!(((int64(getIllFormedAction())==0))||((int64(getManyEdgesAction())==0))||((int64(getNonConvexAction())==0)))) ) )
            OP_Utils::evalOpParm(mySelfIntersectingAction, node, "intersect", time, 0);
        else mySelfIntersectingAction = 1;
        if (true && ( (!(((int64(getIllFormedAction())==0))||((int64(getManyEdgesAction())==0))||((int64(getNonConvexAction())==0)))) ) )
            OP_Utils::evalOpParm(myThickness, node, "thickness", time, 0);
        else myThickness = 0.0001;
        if (true && ( (!(((int64(getIllFormedAction())==0)))) ) )
            OP_Utils::evalOpParm(myGloballySmallAreasAction, node, "glosmallarea", time, 0);
        else myGloballySmallAreasAction = 0;
        if (true && ( (!(((int64(getIllFormedAction())==0)))) ) )
            OP_Utils::evalOpParm(myGlobalAreaThreshold, node, "gloareathres", time, 0);
        else myGlobalAreaThreshold = 1e-06;
        if (true && ( (!(((int64(getIllFormedAction())==0)))) ) )
            OP_Utils::evalOpParm(myLocallySmallAreasAction, node, "locsmallarea", time, 0);
        else myLocallySmallAreasAction = 0;
        if (true && ( (!(((int64(getIllFormedAction())==0)))) ) )
            OP_Utils::evalOpParm(myLocalAreaThreshold, node, "locareathres", time, 0);
        else myLocalAreaThreshold = 0.01;
        if (true && ( (!(((int64(getIllFormedAction())==0))||((int64(getManyEdgesAction())==0))||((int64(getNonConvexAction())==0)))) ) )
            OP_Utils::evalOpParm(myNonUniformAction, node, "nonuni", time, 0);
        else myNonUniformAction = 0;
        if (true && ( (!(((int64(getIllFormedAction())==0))||((int64(getManyEdgesAction())==0))||((int64(getNonConvexAction())==0)))) ) )
            OP_Utils::evalOpParm(myUniformityThreshold, node, "unithres", time, 0);
        else myUniformityThreshold = 0.01;
        if (true)
            OP_Utils::evalOpParm(myGloballySmallEdgesAction, node, "glosmalledge", time, 0);
        else myGloballySmallEdgesAction = 0;
        if (true)
            OP_Utils::evalOpParm(myGlobalEdgeThreshold, node, "gloedgethres", time, 0);
        else myGlobalEdgeThreshold = 0.001;
        if (true)
            OP_Utils::evalOpParm(myLocallySmallEdgesAction, node, "locsmalledge", time, 0);
        else myLocallySmallEdgesAction = 0;
        if (true)
            OP_Utils::evalOpParm(myLocalEdgeThreshold, node, "locedgethres", time, 0);
        else myLocalEdgeThreshold = 0.3;
        if (true)
            OP_Utils::evalOpParm(myDisconnectedPointsAction, node, "disconnectpt", time, 0);
        else myDisconnectedPointsAction = 0;
        if (true)
            OP_Utils::evalOpParm(myNonManifoldPointsAction, node, "nonmanifoldpt", time, 0);
        else myNonManifoldPointsAction = 0;
        if (true)
            OP_Utils::evalOpParm(myIgnoreWindings, node, "ignorewindings", time, 0);
        else myIgnoreWindings = false;
        if (true && ( (!(((int64(getNonManifoldPointsAction())!=2)))) ) )
            OP_Utils::evalOpParm(myPreferLargeAngles, node, "preferlargeangles", time, 0);
        else myPreferLargeAngles = false;
        if (true)
            OP_Utils::evalOpParm(myVisualizeMaxManifold, node, "vismaxmanifold", time, 0);
        else myVisualizeMaxManifold = false;
        if (true)
            OP_Utils::evalOpParm(myExportManifoldNumbers, node, "exportmanifoldnumbers", time, 0);
        else myExportManifoldNumbers = false;
        if (true)
            OP_Utils::evalOpParm(myFixWindings, node, "fixwindings", time, 0);
        else myFixWindings = false;
        if (true)
            OP_Utils::evalOpParm(myDeleteSmallManifolds, node, "deletesmallmanifolds", time, 0);
        else myDeleteSmallManifolds = false;
        if (true && ( (!(((getDeleteSmallManifolds()==0)))) ) )
            OP_Utils::evalOpParm(mySmallManifoldSize, node, "smallmanifoldsize", time, 0);
        else mySmallManifoldSize = 0;
        if (true)
            OP_Utils::evalOpParm(myAddValidPolyAttrib, node, "usevalidpoly", time, 0);
        else myAddValidPolyAttrib = false;
        if (true)
            OP_Utils::evalOpParm(myValidPolyAttribName, node, "validpoly", time, 0);
        else myValidPolyAttribName = "valid_poly"_sh;
        if (true)
            OP_Utils::evalOpParm(myAddRepairedPolyAttrib, node, "userepairedpoly", time, 0);
        else myAddRepairedPolyAttrib = false;
        if (true)
            OP_Utils::evalOpParm(myRepairedPolyAttribName, node, "repairedpoly", time, 0);
        else myRepairedPolyAttribName = "repaired_poly"_sh;
        if (true)
            OP_Utils::evalOpParm(myAddValidPtsAttrib, node, "usevalidpts", time, 0);
        else myAddValidPtsAttrib = false;
        if (true)
            OP_Utils::evalOpParm(myValidPtsAttribName, node, "validpts", time, 0);
        else myValidPtsAttribName = "valid_pt"_sh;
        if (true)
            OP_Utils::evalOpParm(myAddModifiedPtsAttrib, node, "usemodifiedpts", time, 0);
        else myAddModifiedPtsAttrib = false;
        if (true)
            OP_Utils::evalOpParm(myModifiedPtsAttribName, node, "modifiedpts", time, 0);
        else myModifiedPtsAttribName = "modified_pt"_sh;
        if (true)
            OP_Utils::evalOpParm(myCreateGroups, node, "creategrps", time, 0);
        else myCreateGroups = false;
        if (true)
            OP_Utils::evalOpParm(myVisualizeInvalidPts, node, "visinvalidpts", time, 0);
        else myVisualizeInvalidPts = false;
        if (true && ( (!(((getVisualizeInvalidPts()==0)))) ) )
            OP_Utils::evalOpParm(myInvalidPtsColor, node, "visinvalidptsfg", time, 0);
        else myInvalidPtsColor = UT_Vector3D(0.9,0,0);
        if (true)
            OP_Utils::evalOpParm(myVisualizeRepairedPts, node, "visrepairedpts", time, 0);
        else myVisualizeRepairedPts = false;
        if (true && ( (!(((getVisualizeRepairedPts()==0)))) ) )
            OP_Utils::evalOpParm(myRepairedPtsColor, node, "visrepairedptsfg", time, 0);
        else myRepairedPtsColor = UT_Vector3D(0,0,0.9);
        if (true)
            OP_Utils::evalOpParm(myVisualizeInvalidPolys, node, "visinvalidpolys", time, 0);
        else myVisualizeInvalidPolys = false;
        if (true && ( (!(((getVisualizeInvalidPolys()==0)))) ) )
            OP_Utils::evalOpParm(myInvalidPolysColor, node, "visinvalidpolysfg", time, 0);
        else myInvalidPolysColor = UT_Vector3D(0.9,0,0);
        if (true)
            OP_Utils::evalOpParm(myVisualizeRepairedPolys, node, "visrepairedpolys", time, 0);
        else myVisualizeRepairedPolys = false;
        if (true && ( (!(((getVisualizeRepairedPolys()==0)))) ) )
            OP_Utils::evalOpParm(myRepairedPolysColor, node, "visrepairedpolysfg", time, 0);
        else myRepairedPolysColor = UT_Vector3D(0,0,0.9);

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_PolyDoctorParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myGroup);
                break;
            case 1:
                coerceValue(value, myMaxPasses);
                break;
            case 2:
                coerceValue(value, myRandomSeed);
                break;
            case 3:
                coerceValue(value, myIllFormedAction);
                break;
            case 4:
                coerceValue(value, myManyEdgesAction);
                break;
            case 5:
                coerceValue(value, myNonConvexAction);
                break;
            case 6:
                coerceValue(value, myOverlappingAction);
                break;
            case 7:
                coerceValue(value, myPairOverlaps);
                break;
            case 8:
                coerceValue(value, mySelfIntersectingAction);
                break;
            case 9:
                coerceValue(value, myThickness);
                break;
            case 10:
                coerceValue(value, myGloballySmallAreasAction);
                break;
            case 11:
                coerceValue(value, myGlobalAreaThreshold);
                break;
            case 12:
                coerceValue(value, myLocallySmallAreasAction);
                break;
            case 13:
                coerceValue(value, myLocalAreaThreshold);
                break;
            case 14:
                coerceValue(value, myNonUniformAction);
                break;
            case 15:
                coerceValue(value, myUniformityThreshold);
                break;
            case 16:
                coerceValue(value, myGloballySmallEdgesAction);
                break;
            case 17:
                coerceValue(value, myGlobalEdgeThreshold);
                break;
            case 18:
                coerceValue(value, myLocallySmallEdgesAction);
                break;
            case 19:
                coerceValue(value, myLocalEdgeThreshold);
                break;
            case 20:
                coerceValue(value, myDisconnectedPointsAction);
                break;
            case 21:
                coerceValue(value, myNonManifoldPointsAction);
                break;
            case 22:
                coerceValue(value, myIgnoreWindings);
                break;
            case 23:
                coerceValue(value, myPreferLargeAngles);
                break;
            case 24:
                coerceValue(value, myVisualizeMaxManifold);
                break;
            case 25:
                coerceValue(value, myExportManifoldNumbers);
                break;
            case 26:
                coerceValue(value, myFixWindings);
                break;
            case 27:
                coerceValue(value, myDeleteSmallManifolds);
                break;
            case 28:
                coerceValue(value, mySmallManifoldSize);
                break;
            case 29:
                coerceValue(value, myAddValidPolyAttrib);
                break;
            case 30:
                coerceValue(value, myValidPolyAttribName);
                break;
            case 31:
                coerceValue(value, myAddRepairedPolyAttrib);
                break;
            case 32:
                coerceValue(value, myRepairedPolyAttribName);
                break;
            case 33:
                coerceValue(value, myAddValidPtsAttrib);
                break;
            case 34:
                coerceValue(value, myValidPtsAttribName);
                break;
            case 35:
                coerceValue(value, myAddModifiedPtsAttrib);
                break;
            case 36:
                coerceValue(value, myModifiedPtsAttribName);
                break;
            case 37:
                coerceValue(value, myCreateGroups);
                break;
            case 38:
                coerceValue(value, myVisualizeInvalidPts);
                break;
            case 39:
                coerceValue(value, myInvalidPtsColor);
                break;
            case 40:
                coerceValue(value, myVisualizeRepairedPts);
                break;
            case 41:
                coerceValue(value, myRepairedPtsColor);
                break;
            case 42:
                coerceValue(value, myVisualizeInvalidPolys);
                break;
            case 43:
                coerceValue(value, myInvalidPolysColor);
                break;
            case 44:
                coerceValue(value, myVisualizeRepairedPolys);
                break;
            case 45:
                coerceValue(value, myRepairedPolysColor);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myGroup, value);
                break;
            case 1:
                coerceValue(myMaxPasses, value);
                break;
            case 2:
                coerceValue(myRandomSeed, value);
                break;
            case 3:
                coerceValue(myIllFormedAction, value);
                break;
            case 4:
                coerceValue(myManyEdgesAction, value);
                break;
            case 5:
                coerceValue(myNonConvexAction, value);
                break;
            case 6:
                coerceValue(myOverlappingAction, value);
                break;
            case 7:
                coerceValue(myPairOverlaps, value);
                break;
            case 8:
                coerceValue(mySelfIntersectingAction, value);
                break;
            case 9:
                coerceValue(myThickness, value);
                break;
            case 10:
                coerceValue(myGloballySmallAreasAction, value);
                break;
            case 11:
                coerceValue(myGlobalAreaThreshold, value);
                break;
            case 12:
                coerceValue(myLocallySmallAreasAction, value);
                break;
            case 13:
                coerceValue(myLocalAreaThreshold, value);
                break;
            case 14:
                coerceValue(myNonUniformAction, value);
                break;
            case 15:
                coerceValue(myUniformityThreshold, value);
                break;
            case 16:
                coerceValue(myGloballySmallEdgesAction, value);
                break;
            case 17:
                coerceValue(myGlobalEdgeThreshold, value);
                break;
            case 18:
                coerceValue(myLocallySmallEdgesAction, value);
                break;
            case 19:
                coerceValue(myLocalEdgeThreshold, value);
                break;
            case 20:
                coerceValue(myDisconnectedPointsAction, value);
                break;
            case 21:
                coerceValue(myNonManifoldPointsAction, value);
                break;
            case 22:
                coerceValue(myIgnoreWindings, value);
                break;
            case 23:
                coerceValue(myPreferLargeAngles, value);
                break;
            case 24:
                coerceValue(myVisualizeMaxManifold, value);
                break;
            case 25:
                coerceValue(myExportManifoldNumbers, value);
                break;
            case 26:
                coerceValue(myFixWindings, value);
                break;
            case 27:
                coerceValue(myDeleteSmallManifolds, value);
                break;
            case 28:
                coerceValue(mySmallManifoldSize, value);
                break;
            case 29:
                coerceValue(myAddValidPolyAttrib, value);
                break;
            case 30:
                coerceValue(myValidPolyAttribName, value);
                break;
            case 31:
                coerceValue(myAddRepairedPolyAttrib, value);
                break;
            case 32:
                coerceValue(myRepairedPolyAttribName, value);
                break;
            case 33:
                coerceValue(myAddValidPtsAttrib, value);
                break;
            case 34:
                coerceValue(myValidPtsAttribName, value);
                break;
            case 35:
                coerceValue(myAddModifiedPtsAttrib, value);
                break;
            case 36:
                coerceValue(myModifiedPtsAttribName, value);
                break;
            case 37:
                coerceValue(myCreateGroups, value);
                break;
            case 38:
                coerceValue(myVisualizeInvalidPts, value);
                break;
            case 39:
                coerceValue(myInvalidPtsColor, value);
                break;
            case 40:
                coerceValue(myVisualizeRepairedPts, value);
                break;
            case 41:
                coerceValue(myRepairedPtsColor, value);
                break;
            case 42:
                coerceValue(myVisualizeInvalidPolys, value);
                break;
            case 43:
                coerceValue(myInvalidPolysColor, value);
                break;
            case 44:
                coerceValue(myVisualizeRepairedPolys, value);
                break;
            case 45:
                coerceValue(myRepairedPolysColor, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 46;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "group";
            case 1:
                return "maxpasses";
            case 2:
                return "randomseed";
            case 3:
                return "illformed";
            case 4:
                return "manyedges";
            case 5:
                return "nonconvex";
            case 6:
                return "overlapping";
            case 7:
                return "pairoverlaps";
            case 8:
                return "intersect";
            case 9:
                return "thickness";
            case 10:
                return "glosmallarea";
            case 11:
                return "gloareathres";
            case 12:
                return "locsmallarea";
            case 13:
                return "locareathres";
            case 14:
                return "nonuni";
            case 15:
                return "unithres";
            case 16:
                return "glosmalledge";
            case 17:
                return "gloedgethres";
            case 18:
                return "locsmalledge";
            case 19:
                return "locedgethres";
            case 20:
                return "disconnectpt";
            case 21:
                return "nonmanifoldpt";
            case 22:
                return "ignorewindings";
            case 23:
                return "preferlargeangles";
            case 24:
                return "vismaxmanifold";
            case 25:
                return "exportmanifoldnumbers";
            case 26:
                return "fixwindings";
            case 27:
                return "deletesmallmanifolds";
            case 28:
                return "smallmanifoldsize";
            case 29:
                return "usevalidpoly";
            case 30:
                return "validpoly";
            case 31:
                return "userepairedpoly";
            case 32:
                return "repairedpoly";
            case 33:
                return "usevalidpts";
            case 34:
                return "validpts";
            case 35:
                return "usemodifiedpts";
            case 36:
                return "modifiedpts";
            case 37:
                return "creategrps";
            case 38:
                return "visinvalidpts";
            case 39:
                return "visinvalidptsfg";
            case 40:
                return "visrepairedpts";
            case 41:
                return "visrepairedptsfg";
            case 42:
                return "visinvalidpolys";
            case 43:
                return "visinvalidpolysfg";
            case 44:
                return "visrepairedpolys";
            case 45:
                return "visrepairedpolysfg";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_INTEGER;
                case 3:
                    return PARM_INTEGER;
                case 4:
                    return PARM_INTEGER;
                case 5:
                    return PARM_INTEGER;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_INTEGER;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_FLOAT;
                case 10:
                    return PARM_INTEGER;
                case 11:
                    return PARM_FLOAT;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_FLOAT;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_FLOAT;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_FLOAT;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_FLOAT;
                case 20:
                    return PARM_INTEGER;
                case 21:
                    return PARM_INTEGER;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_INTEGER;
                case 24:
                    return PARM_INTEGER;
                case 25:
                    return PARM_INTEGER;
                case 26:
                    return PARM_INTEGER;
                case 27:
                    return PARM_INTEGER;
                case 28:
                    return PARM_INTEGER;
                case 29:
                    return PARM_INTEGER;
                case 30:
                    return PARM_STRING;
                case 31:
                    return PARM_INTEGER;
                case 32:
                    return PARM_STRING;
                case 33:
                    return PARM_INTEGER;
                case 34:
                    return PARM_STRING;
                case 35:
                    return PARM_INTEGER;
                case 36:
                    return PARM_STRING;
                case 37:
                    return PARM_INTEGER;
                case 38:
                    return PARM_INTEGER;
                case 39:
                    return PARM_VECTOR3;
                case 40:
                    return PARM_INTEGER;
                case 41:
                    return PARM_VECTOR3;
                case 42:
                    return PARM_INTEGER;
                case 43:
                    return PARM_VECTOR3;
                case 44:
                    return PARM_INTEGER;
                case 45:
                    return PARM_VECTOR3;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myGroup);
        saveData(os, myMaxPasses);
        saveData(os, myRandomSeed);
        saveData(os, myIllFormedAction);
        saveData(os, myManyEdgesAction);
        saveData(os, myNonConvexAction);
        saveData(os, myOverlappingAction);
        saveData(os, myPairOverlaps);
        saveData(os, mySelfIntersectingAction);
        saveData(os, myThickness);
        saveData(os, myGloballySmallAreasAction);
        saveData(os, myGlobalAreaThreshold);
        saveData(os, myLocallySmallAreasAction);
        saveData(os, myLocalAreaThreshold);
        saveData(os, myNonUniformAction);
        saveData(os, myUniformityThreshold);
        saveData(os, myGloballySmallEdgesAction);
        saveData(os, myGlobalEdgeThreshold);
        saveData(os, myLocallySmallEdgesAction);
        saveData(os, myLocalEdgeThreshold);
        saveData(os, myDisconnectedPointsAction);
        saveData(os, myNonManifoldPointsAction);
        saveData(os, myIgnoreWindings);
        saveData(os, myPreferLargeAngles);
        saveData(os, myVisualizeMaxManifold);
        saveData(os, myExportManifoldNumbers);
        saveData(os, myFixWindings);
        saveData(os, myDeleteSmallManifolds);
        saveData(os, mySmallManifoldSize);
        saveData(os, myAddValidPolyAttrib);
        saveData(os, myValidPolyAttribName);
        saveData(os, myAddRepairedPolyAttrib);
        saveData(os, myRepairedPolyAttribName);
        saveData(os, myAddValidPtsAttrib);
        saveData(os, myValidPtsAttribName);
        saveData(os, myAddModifiedPtsAttrib);
        saveData(os, myModifiedPtsAttribName);
        saveData(os, myCreateGroups);
        saveData(os, myVisualizeInvalidPts);
        saveData(os, myInvalidPtsColor);
        saveData(os, myVisualizeRepairedPts);
        saveData(os, myRepairedPtsColor);
        saveData(os, myVisualizeInvalidPolys);
        saveData(os, myInvalidPolysColor);
        saveData(os, myVisualizeRepairedPolys);
        saveData(os, myRepairedPolysColor);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myGroup);
        loadData(is, myMaxPasses);
        loadData(is, myRandomSeed);
        loadData(is, myIllFormedAction);
        loadData(is, myManyEdgesAction);
        loadData(is, myNonConvexAction);
        loadData(is, myOverlappingAction);
        loadData(is, myPairOverlaps);
        loadData(is, mySelfIntersectingAction);
        loadData(is, myThickness);
        loadData(is, myGloballySmallAreasAction);
        loadData(is, myGlobalAreaThreshold);
        loadData(is, myLocallySmallAreasAction);
        loadData(is, myLocalAreaThreshold);
        loadData(is, myNonUniformAction);
        loadData(is, myUniformityThreshold);
        loadData(is, myGloballySmallEdgesAction);
        loadData(is, myGlobalEdgeThreshold);
        loadData(is, myLocallySmallEdgesAction);
        loadData(is, myLocalEdgeThreshold);
        loadData(is, myDisconnectedPointsAction);
        loadData(is, myNonManifoldPointsAction);
        loadData(is, myIgnoreWindings);
        loadData(is, myPreferLargeAngles);
        loadData(is, myVisualizeMaxManifold);
        loadData(is, myExportManifoldNumbers);
        loadData(is, myFixWindings);
        loadData(is, myDeleteSmallManifolds);
        loadData(is, mySmallManifoldSize);
        loadData(is, myAddValidPolyAttrib);
        loadData(is, myValidPolyAttribName);
        loadData(is, myAddRepairedPolyAttrib);
        loadData(is, myRepairedPolyAttribName);
        loadData(is, myAddValidPtsAttrib);
        loadData(is, myValidPtsAttribName);
        loadData(is, myAddModifiedPtsAttrib);
        loadData(is, myModifiedPtsAttribName);
        loadData(is, myCreateGroups);
        loadData(is, myVisualizeInvalidPts);
        loadData(is, myInvalidPtsColor);
        loadData(is, myVisualizeRepairedPts);
        loadData(is, myRepairedPtsColor);
        loadData(is, myVisualizeInvalidPolys);
        loadData(is, myInvalidPolysColor);
        loadData(is, myVisualizeRepairedPolys);
        loadData(is, myRepairedPolysColor);

        return true;
    }

    const UT_StringHolder & getGroup() const { return myGroup; }
    void setGroup(const UT_StringHolder & val) { myGroup = val; }
    UT_StringHolder opGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "group", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getMaxPasses() const { return myMaxPasses; }
    void setMaxPasses(int64 val) { myMaxPasses = val; }
    int64 opMaxPasses(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxPasses();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "maxpasses", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getRandomSeed() const { return myRandomSeed; }
    void setRandomSeed(int64 val) { myRandomSeed = val; }
    int64 opRandomSeed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandomSeed();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "randomseed", cookparms.getCookTime(), 0);
        return result;
    }
    IllFormedAction getIllFormedAction() const { return IllFormedAction(myIllFormedAction); }
    void setIllFormedAction(IllFormedAction val) { myIllFormedAction = int64(val); }
    IllFormedAction opIllFormedAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIllFormedAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "illformed", cookparms.getCookTime(), 0);
        return IllFormedAction(result);
    }
    ManyEdgesAction getManyEdgesAction() const { return ManyEdgesAction(myManyEdgesAction); }
    void setManyEdgesAction(ManyEdgesAction val) { myManyEdgesAction = int64(val); }
    ManyEdgesAction opManyEdgesAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getManyEdgesAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "manyedges", cookparms.getCookTime(), 0);
        return ManyEdgesAction(result);
    }
    NonConvexAction getNonConvexAction() const { return NonConvexAction(myNonConvexAction); }
    void setNonConvexAction(NonConvexAction val) { myNonConvexAction = int64(val); }
    NonConvexAction opNonConvexAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNonConvexAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "nonconvex", cookparms.getCookTime(), 0);
        return NonConvexAction(result);
    }
    OverlappingAction getOverlappingAction() const { return OverlappingAction(myOverlappingAction); }
    void setOverlappingAction(OverlappingAction val) { myOverlappingAction = int64(val); }
    OverlappingAction opOverlappingAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOverlappingAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "overlapping", cookparms.getCookTime(), 0);
        return OverlappingAction(result);
    }
    bool getPairOverlaps() const { return myPairOverlaps; }
    void setPairOverlaps(bool val) { myPairOverlaps = val; }
    bool opPairOverlaps(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPairOverlaps();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "pairoverlaps", cookparms.getCookTime(), 0);
        return result;
    }
    SelfIntersectingAction getSelfIntersectingAction() const { return SelfIntersectingAction(mySelfIntersectingAction); }
    void setSelfIntersectingAction(SelfIntersectingAction val) { mySelfIntersectingAction = int64(val); }
    SelfIntersectingAction opSelfIntersectingAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSelfIntersectingAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "intersect", cookparms.getCookTime(), 0);
        return SelfIntersectingAction(result);
    }
    fpreal64 getThickness() const { return myThickness; }
    void setThickness(fpreal64 val) { myThickness = val; }
    fpreal64 opThickness(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getThickness();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "thickness", cookparms.getCookTime(), 0);
        return result;
    }
    GloballySmallAreasAction getGloballySmallAreasAction() const { return GloballySmallAreasAction(myGloballySmallAreasAction); }
    void setGloballySmallAreasAction(GloballySmallAreasAction val) { myGloballySmallAreasAction = int64(val); }
    GloballySmallAreasAction opGloballySmallAreasAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGloballySmallAreasAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "glosmallarea", cookparms.getCookTime(), 0);
        return GloballySmallAreasAction(result);
    }
    fpreal64 getGlobalAreaThreshold() const { return myGlobalAreaThreshold; }
    void setGlobalAreaThreshold(fpreal64 val) { myGlobalAreaThreshold = val; }
    fpreal64 opGlobalAreaThreshold(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGlobalAreaThreshold();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "gloareathres", cookparms.getCookTime(), 0);
        return result;
    }
    LocallySmallAreasAction getLocallySmallAreasAction() const { return LocallySmallAreasAction(myLocallySmallAreasAction); }
    void setLocallySmallAreasAction(LocallySmallAreasAction val) { myLocallySmallAreasAction = int64(val); }
    LocallySmallAreasAction opLocallySmallAreasAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLocallySmallAreasAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "locsmallarea", cookparms.getCookTime(), 0);
        return LocallySmallAreasAction(result);
    }
    fpreal64 getLocalAreaThreshold() const { return myLocalAreaThreshold; }
    void setLocalAreaThreshold(fpreal64 val) { myLocalAreaThreshold = val; }
    fpreal64 opLocalAreaThreshold(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLocalAreaThreshold();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "locareathres", cookparms.getCookTime(), 0);
        return result;
    }
    NonUniformAction getNonUniformAction() const { return NonUniformAction(myNonUniformAction); }
    void setNonUniformAction(NonUniformAction val) { myNonUniformAction = int64(val); }
    NonUniformAction opNonUniformAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNonUniformAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "nonuni", cookparms.getCookTime(), 0);
        return NonUniformAction(result);
    }
    fpreal64 getUniformityThreshold() const { return myUniformityThreshold; }
    void setUniformityThreshold(fpreal64 val) { myUniformityThreshold = val; }
    fpreal64 opUniformityThreshold(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUniformityThreshold();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "unithres", cookparms.getCookTime(), 0);
        return result;
    }
    GloballySmallEdgesAction getGloballySmallEdgesAction() const { return GloballySmallEdgesAction(myGloballySmallEdgesAction); }
    void setGloballySmallEdgesAction(GloballySmallEdgesAction val) { myGloballySmallEdgesAction = int64(val); }
    GloballySmallEdgesAction opGloballySmallEdgesAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGloballySmallEdgesAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "glosmalledge", cookparms.getCookTime(), 0);
        return GloballySmallEdgesAction(result);
    }
    fpreal64 getGlobalEdgeThreshold() const { return myGlobalEdgeThreshold; }
    void setGlobalEdgeThreshold(fpreal64 val) { myGlobalEdgeThreshold = val; }
    fpreal64 opGlobalEdgeThreshold(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGlobalEdgeThreshold();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "gloedgethres", cookparms.getCookTime(), 0);
        return result;
    }
    LocallySmallEdgesAction getLocallySmallEdgesAction() const { return LocallySmallEdgesAction(myLocallySmallEdgesAction); }
    void setLocallySmallEdgesAction(LocallySmallEdgesAction val) { myLocallySmallEdgesAction = int64(val); }
    LocallySmallEdgesAction opLocallySmallEdgesAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLocallySmallEdgesAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "locsmalledge", cookparms.getCookTime(), 0);
        return LocallySmallEdgesAction(result);
    }
    fpreal64 getLocalEdgeThreshold() const { return myLocalEdgeThreshold; }
    void setLocalEdgeThreshold(fpreal64 val) { myLocalEdgeThreshold = val; }
    fpreal64 opLocalEdgeThreshold(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLocalEdgeThreshold();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "locedgethres", cookparms.getCookTime(), 0);
        return result;
    }
    DisconnectedPointsAction getDisconnectedPointsAction() const { return DisconnectedPointsAction(myDisconnectedPointsAction); }
    void setDisconnectedPointsAction(DisconnectedPointsAction val) { myDisconnectedPointsAction = int64(val); }
    DisconnectedPointsAction opDisconnectedPointsAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDisconnectedPointsAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "disconnectpt", cookparms.getCookTime(), 0);
        return DisconnectedPointsAction(result);
    }
    NonManifoldPointsAction getNonManifoldPointsAction() const { return NonManifoldPointsAction(myNonManifoldPointsAction); }
    void setNonManifoldPointsAction(NonManifoldPointsAction val) { myNonManifoldPointsAction = int64(val); }
    NonManifoldPointsAction opNonManifoldPointsAction(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNonManifoldPointsAction();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "nonmanifoldpt", cookparms.getCookTime(), 0);
        return NonManifoldPointsAction(result);
    }
    bool getIgnoreWindings() const { return myIgnoreWindings; }
    void setIgnoreWindings(bool val) { myIgnoreWindings = val; }
    bool opIgnoreWindings(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIgnoreWindings();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "ignorewindings", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPreferLargeAngles() const { return myPreferLargeAngles; }
    void setPreferLargeAngles(bool val) { myPreferLargeAngles = val; }
    bool opPreferLargeAngles(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPreferLargeAngles();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "preferlargeangles", cookparms.getCookTime(), 0);
        return result;
    }
    bool getVisualizeMaxManifold() const { return myVisualizeMaxManifold; }
    void setVisualizeMaxManifold(bool val) { myVisualizeMaxManifold = val; }
    bool opVisualizeMaxManifold(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVisualizeMaxManifold();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "vismaxmanifold", cookparms.getCookTime(), 0);
        return result;
    }
    bool getExportManifoldNumbers() const { return myExportManifoldNumbers; }
    void setExportManifoldNumbers(bool val) { myExportManifoldNumbers = val; }
    bool opExportManifoldNumbers(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getExportManifoldNumbers();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "exportmanifoldnumbers", cookparms.getCookTime(), 0);
        return result;
    }
    bool getFixWindings() const { return myFixWindings; }
    void setFixWindings(bool val) { myFixWindings = val; }
    bool opFixWindings(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getFixWindings();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "fixwindings", cookparms.getCookTime(), 0);
        return result;
    }
    bool getDeleteSmallManifolds() const { return myDeleteSmallManifolds; }
    void setDeleteSmallManifolds(bool val) { myDeleteSmallManifolds = val; }
    bool opDeleteSmallManifolds(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDeleteSmallManifolds();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "deletesmallmanifolds", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getSmallManifoldSize() const { return mySmallManifoldSize; }
    void setSmallManifoldSize(int64 val) { mySmallManifoldSize = val; }
    int64 opSmallManifoldSize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSmallManifoldSize();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "smallmanifoldsize", cookparms.getCookTime(), 0);
        return result;
    }
    bool getAddValidPolyAttrib() const { return myAddValidPolyAttrib; }
    void setAddValidPolyAttrib(bool val) { myAddValidPolyAttrib = val; }
    bool opAddValidPolyAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAddValidPolyAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usevalidpoly", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getValidPolyAttribName() const { return myValidPolyAttribName; }
    void setValidPolyAttribName(const UT_StringHolder & val) { myValidPolyAttribName = val; }
    UT_StringHolder opValidPolyAttribName(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getValidPolyAttribName();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "validpoly", cookparms.getCookTime(), 0);
        return result;
    }
    bool getAddRepairedPolyAttrib() const { return myAddRepairedPolyAttrib; }
    void setAddRepairedPolyAttrib(bool val) { myAddRepairedPolyAttrib = val; }
    bool opAddRepairedPolyAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAddRepairedPolyAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "userepairedpoly", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getRepairedPolyAttribName() const { return myRepairedPolyAttribName; }
    void setRepairedPolyAttribName(const UT_StringHolder & val) { myRepairedPolyAttribName = val; }
    UT_StringHolder opRepairedPolyAttribName(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRepairedPolyAttribName();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "repairedpoly", cookparms.getCookTime(), 0);
        return result;
    }
    bool getAddValidPtsAttrib() const { return myAddValidPtsAttrib; }
    void setAddValidPtsAttrib(bool val) { myAddValidPtsAttrib = val; }
    bool opAddValidPtsAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAddValidPtsAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usevalidpts", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getValidPtsAttribName() const { return myValidPtsAttribName; }
    void setValidPtsAttribName(const UT_StringHolder & val) { myValidPtsAttribName = val; }
    UT_StringHolder opValidPtsAttribName(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getValidPtsAttribName();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "validpts", cookparms.getCookTime(), 0);
        return result;
    }
    bool getAddModifiedPtsAttrib() const { return myAddModifiedPtsAttrib; }
    void setAddModifiedPtsAttrib(bool val) { myAddModifiedPtsAttrib = val; }
    bool opAddModifiedPtsAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAddModifiedPtsAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usemodifiedpts", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getModifiedPtsAttribName() const { return myModifiedPtsAttribName; }
    void setModifiedPtsAttribName(const UT_StringHolder & val) { myModifiedPtsAttribName = val; }
    UT_StringHolder opModifiedPtsAttribName(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getModifiedPtsAttribName();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "modifiedpts", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCreateGroups() const { return myCreateGroups; }
    void setCreateGroups(bool val) { myCreateGroups = val; }
    bool opCreateGroups(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCreateGroups();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "creategrps", cookparms.getCookTime(), 0);
        return result;
    }
    bool getVisualizeInvalidPts() const { return myVisualizeInvalidPts; }
    void setVisualizeInvalidPts(bool val) { myVisualizeInvalidPts = val; }
    bool opVisualizeInvalidPts(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVisualizeInvalidPts();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "visinvalidpts", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getInvalidPtsColor() const { return myInvalidPtsColor; }
    void setInvalidPtsColor(UT_Vector3D val) { myInvalidPtsColor = val; }
    UT_Vector3D opInvalidPtsColor(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInvalidPtsColor();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "visinvalidptsfg", cookparms.getCookTime(), 0);
        return result;
    }
    bool getVisualizeRepairedPts() const { return myVisualizeRepairedPts; }
    void setVisualizeRepairedPts(bool val) { myVisualizeRepairedPts = val; }
    bool opVisualizeRepairedPts(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVisualizeRepairedPts();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "visrepairedpts", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getRepairedPtsColor() const { return myRepairedPtsColor; }
    void setRepairedPtsColor(UT_Vector3D val) { myRepairedPtsColor = val; }
    UT_Vector3D opRepairedPtsColor(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRepairedPtsColor();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "visrepairedptsfg", cookparms.getCookTime(), 0);
        return result;
    }
    bool getVisualizeInvalidPolys() const { return myVisualizeInvalidPolys; }
    void setVisualizeInvalidPolys(bool val) { myVisualizeInvalidPolys = val; }
    bool opVisualizeInvalidPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVisualizeInvalidPolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "visinvalidpolys", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getInvalidPolysColor() const { return myInvalidPolysColor; }
    void setInvalidPolysColor(UT_Vector3D val) { myInvalidPolysColor = val; }
    UT_Vector3D opInvalidPolysColor(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInvalidPolysColor();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "visinvalidpolysfg", cookparms.getCookTime(), 0);
        return result;
    }
    bool getVisualizeRepairedPolys() const { return myVisualizeRepairedPolys; }
    void setVisualizeRepairedPolys(bool val) { myVisualizeRepairedPolys = val; }
    bool opVisualizeRepairedPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVisualizeRepairedPolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "visrepairedpolys", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getRepairedPolysColor() const { return myRepairedPolysColor; }
    void setRepairedPolysColor(UT_Vector3D val) { myRepairedPolysColor = val; }
    UT_Vector3D opRepairedPolysColor(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRepairedPolysColor();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "visrepairedpolysfg", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myGroup;
    int64 myMaxPasses;
    int64 myRandomSeed;
    int64 myIllFormedAction;
    int64 myManyEdgesAction;
    int64 myNonConvexAction;
    int64 myOverlappingAction;
    bool myPairOverlaps;
    int64 mySelfIntersectingAction;
    fpreal64 myThickness;
    int64 myGloballySmallAreasAction;
    fpreal64 myGlobalAreaThreshold;
    int64 myLocallySmallAreasAction;
    fpreal64 myLocalAreaThreshold;
    int64 myNonUniformAction;
    fpreal64 myUniformityThreshold;
    int64 myGloballySmallEdgesAction;
    fpreal64 myGlobalEdgeThreshold;
    int64 myLocallySmallEdgesAction;
    fpreal64 myLocalEdgeThreshold;
    int64 myDisconnectedPointsAction;
    int64 myNonManifoldPointsAction;
    bool myIgnoreWindings;
    bool myPreferLargeAngles;
    bool myVisualizeMaxManifold;
    bool myExportManifoldNumbers;
    bool myFixWindings;
    bool myDeleteSmallManifolds;
    int64 mySmallManifoldSize;
    bool myAddValidPolyAttrib;
    UT_StringHolder myValidPolyAttribName;
    bool myAddRepairedPolyAttrib;
    UT_StringHolder myRepairedPolyAttribName;
    bool myAddValidPtsAttrib;
    UT_StringHolder myValidPtsAttribName;
    bool myAddModifiedPtsAttrib;
    UT_StringHolder myModifiedPtsAttribName;
    bool myCreateGroups;
    bool myVisualizeInvalidPts;
    UT_Vector3D myInvalidPtsColor;
    bool myVisualizeRepairedPts;
    UT_Vector3D myRepairedPtsColor;
    bool myVisualizeInvalidPolys;
    UT_Vector3D myInvalidPolysColor;
    bool myVisualizeRepairedPolys;
    UT_Vector3D myRepairedPolysColor;

};
