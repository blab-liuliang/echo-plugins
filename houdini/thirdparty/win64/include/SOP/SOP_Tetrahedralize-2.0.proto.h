/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_Tetrahedralize_2_0Enums
{
    enum class Batch
    {
        ENTIRE = 0,
        CONNECTED,
        ATTRIB
    };
    enum class Mode
    {
        CONFORM = 0,
        REFINE,
        CONVEXHULL,
        DETECT
    };
    enum class Output
    {
        POLYLINE = 0,
        TETRAHEDRA,
        POLYGONS,
        POLYTET
    };
    enum class Failures
    {
        REMOVEFAILED = 0,
        KEEPFAILED,
        FAILONERROR
    };
}


class SOP_API SOP_Tetrahedralize_2_0Parms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_Tetrahedralize_2_0Parms()
    {
        myGroup = ""_sh;
        myBatch = 0;
        myPieceAttrib = "name"_sh;
        myRemove = true;
        myMode = 0;
        myOutput = 1;
        myKeepPrims = false;
        myNoBoundMod = true;
        myOneFacePerTet = false;
        myPropNormal = true;
        myInternAttrib = true;
        myUseQuality = true;
        myRadEdgeTol = 1.5;
        myMinDihedralAngle = 10;
        myUseTargetSizeAttrib = false;
        myTargetSizeAttrib = "target_size"_sh;
        myUseUniformMaxSize = false;
        myUniformMaxSize = 0.1;
        myUseMaxSizeAttrib = false;
        myMaxSizeAttrib = "max_size"_sh;
        myUseMaxIter = false;
        myMaxIter = 100000;
        myUseMaxSteiner = false;
        myMaxSteiner = 1000;
        myOptIterations = 2;
        myOptEdgeFace = true;
        myOptVtxSmooth = true;
        myOptVtxMod = true;
        myUseIsectColor = true;
        myIsectPolyClr = UT_Vector3D(0.9,0,0);
        myUseIsectGrp = true;
        myIsectPolyGrp = "intersecting_polygon_grp"_sh;
        myFailures = 0;
        myRandomSeed = 3;
        myPrecisionTol = 1e-09;
        myDihedralAngleTol = 1e-05;
        myMaxAttempts = 5;
        myUseInvalidColor = true;
        myInvalidPrimClr = UT_Vector3D(0.2,0,0);
        myUseInvalidGrp = true;
        myInvalidPrimGrp = "invalid_prim_grp"_sh;

    }

    explicit SOP_Tetrahedralize_2_0Parms(const SOP_Tetrahedralize_2_0Parms &) = default;

    virtual ~SOP_Tetrahedralize_2_0Parms() {}

    bool operator==(const SOP_Tetrahedralize_2_0Parms &src) const
    {
        if (myGroup != src.myGroup) return false;
        if (myBatch != src.myBatch) return false;
        if (myPieceAttrib != src.myPieceAttrib) return false;
        if (myRemove != src.myRemove) return false;
        if (myMode != src.myMode) return false;
        if (myOutput != src.myOutput) return false;
        if (myKeepPrims != src.myKeepPrims) return false;
        if (myNoBoundMod != src.myNoBoundMod) return false;
        if (myOneFacePerTet != src.myOneFacePerTet) return false;
        if (myPropNormal != src.myPropNormal) return false;
        if (myInternAttrib != src.myInternAttrib) return false;
        if (myUseQuality != src.myUseQuality) return false;
        if (myRadEdgeTol != src.myRadEdgeTol) return false;
        if (myMinDihedralAngle != src.myMinDihedralAngle) return false;
        if (myUseTargetSizeAttrib != src.myUseTargetSizeAttrib) return false;
        if (myTargetSizeAttrib != src.myTargetSizeAttrib) return false;
        if (myUseUniformMaxSize != src.myUseUniformMaxSize) return false;
        if (myUniformMaxSize != src.myUniformMaxSize) return false;
        if (myUseMaxSizeAttrib != src.myUseMaxSizeAttrib) return false;
        if (myMaxSizeAttrib != src.myMaxSizeAttrib) return false;
        if (myUseMaxIter != src.myUseMaxIter) return false;
        if (myMaxIter != src.myMaxIter) return false;
        if (myUseMaxSteiner != src.myUseMaxSteiner) return false;
        if (myMaxSteiner != src.myMaxSteiner) return false;
        if (myOptIterations != src.myOptIterations) return false;
        if (myOptEdgeFace != src.myOptEdgeFace) return false;
        if (myOptVtxSmooth != src.myOptVtxSmooth) return false;
        if (myOptVtxMod != src.myOptVtxMod) return false;
        if (myUseIsectColor != src.myUseIsectColor) return false;
        if (myIsectPolyClr != src.myIsectPolyClr) return false;
        if (myUseIsectGrp != src.myUseIsectGrp) return false;
        if (myIsectPolyGrp != src.myIsectPolyGrp) return false;
        if (myFailures != src.myFailures) return false;
        if (myRandomSeed != src.myRandomSeed) return false;
        if (myPrecisionTol != src.myPrecisionTol) return false;
        if (myDihedralAngleTol != src.myDihedralAngleTol) return false;
        if (myMaxAttempts != src.myMaxAttempts) return false;
        if (myUseInvalidColor != src.myUseInvalidColor) return false;
        if (myInvalidPrimClr != src.myInvalidPrimClr) return false;
        if (myUseInvalidGrp != src.myUseInvalidGrp) return false;
        if (myInvalidPrimGrp != src.myInvalidPrimGrp) return false;

        return true;
    }
    bool operator!=(const SOP_Tetrahedralize_2_0Parms &src) const
    {
        return !operator==(src);
    }
    using Batch = SOP_Tetrahedralize_2_0Enums::Batch;
    using Mode = SOP_Tetrahedralize_2_0Enums::Mode;
    using Output = SOP_Tetrahedralize_2_0Enums::Output;
    using Failures = SOP_Tetrahedralize_2_0Enums::Failures;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myGroup, node, "group", time, 0);
        else myGroup = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myBatch, node, "batch", time, 0);
        else myBatch = 0;
        if (true && ( (!(((int64(getBatch())==0)))) ) )
            OP_Utils::evalOpParm(myPieceAttrib, node, "pieceattrib", time, 0);
        else myPieceAttrib = "name"_sh;
        if (true)
            OP_Utils::evalOpParm(myRemove, node, "remove", time, 0);
        else myRemove = true;
        if (true)
            OP_Utils::evalOpParm(myMode, node, "mode", time, 0);
        else myMode = 0;
        if (true && ( (!(((int64(getMode())==3)))) ) )
            OP_Utils::evalOpParm(myOutput, node, "output", time, 0);
        else myOutput = 1;
        if (true && ( (!(((int64(getMode())==3)))) ) )
            OP_Utils::evalOpParm(myKeepPrims, node, "keepprims", time, 0);
        else myKeepPrims = false;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3)))) ) )
            OP_Utils::evalOpParm(myNoBoundMod, node, "noboundmod", time, 0);
        else myNoBoundMod = true;
        if (true && ( (!(((int64(getMode())!=0))||((int64(getOutput())==0))||((int64(getOutput())==2)))) ) )
            OP_Utils::evalOpParm(myOneFacePerTet, node, "onefacepertet", time, 0);
        else myOneFacePerTet = false;
        if (true && ( (!(((int64(getMode())!=0))||((int64(getOutput())==0))||((int64(getOutput())==2)))) ) )
            OP_Utils::evalOpParm(myPropNormal, node, "propnormal", time, 0);
        else myPropNormal = true;
        if (true && ( (!(((int64(getMode())!=0))||((int64(getOutput())==0))||((int64(getOutput())==2)))) ) )
            OP_Utils::evalOpParm(myInternAttrib, node, "internattrib", time, 0);
        else myInternAttrib = true;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3)))) ) )
            OP_Utils::evalOpParm(myUseQuality, node, "usequality", time, 0);
        else myUseQuality = true;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0)))) ) )
            OP_Utils::evalOpParm(myRadEdgeTol, node, "radedgetol", time, 0);
        else myRadEdgeTol = 1.5;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0)))) ) )
            OP_Utils::evalOpParm(myMinDihedralAngle, node, "mindihedralang", time, 0);
        else myMinDihedralAngle = 10;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0)))) ) )
            OP_Utils::evalOpParm(myUseTargetSizeAttrib, node, "usetargetsizeattrib", time, 0);
        else myUseTargetSizeAttrib = false;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0))||((getUseTargetSizeAttrib()==0)))) ) )
            OP_Utils::evalOpParm(myTargetSizeAttrib, node, "targetsizeattrib", time, 0);
        else myTargetSizeAttrib = "target_size"_sh;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0)))) ) )
            OP_Utils::evalOpParm(myUseUniformMaxSize, node, "useuniformmaxsize", time, 0);
        else myUseUniformMaxSize = false;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0))||((getUseUniformMaxSize()==0)))) ) )
            OP_Utils::evalOpParm(myUniformMaxSize, node, "uniformmaxsize", time, 0);
        else myUniformMaxSize = 0.1;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0))||((int64(getMode())!=1)))) ) )
            OP_Utils::evalOpParm(myUseMaxSizeAttrib, node, "usemaxsizeattrib", time, 0);
        else myUseMaxSizeAttrib = false;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0))||((getUseMaxSizeAttrib()==0))||((int64(getMode())!=1)))) ) )
            OP_Utils::evalOpParm(myMaxSizeAttrib, node, "maxsizeattrib", time, 0);
        else myMaxSizeAttrib = "max_size"_sh;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0)))) ) )
            OP_Utils::evalOpParm(myUseMaxIter, node, "usemaxiter", time, 0);
        else myUseMaxIter = false;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0))||((getUseMaxIter()==0)))) ) )
            OP_Utils::evalOpParm(myMaxIter, node, "maxiter", time, 0);
        else myMaxIter = 100000;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0)))) ) )
            OP_Utils::evalOpParm(myUseMaxSteiner, node, "usemaxsteiner", time, 0);
        else myUseMaxSteiner = false;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3))||((getUseQuality()==0))||((getUseMaxSteiner()==0)))) ) )
            OP_Utils::evalOpParm(myMaxSteiner, node, "maxsteiner", time, 0);
        else myMaxSteiner = 1000;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3)))) ) )
            OP_Utils::evalOpParm(myOptIterations, node, "optiterations", time, 0);
        else myOptIterations = 2;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3)))) ) )
            OP_Utils::evalOpParm(myOptEdgeFace, node, "optedgeface", time, 0);
        else myOptEdgeFace = true;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3)))) ) )
            OP_Utils::evalOpParm(myOptVtxSmooth, node, "optvtxsmooth", time, 0);
        else myOptVtxSmooth = true;
        if (true && ( (!(((int64(getMode())==2))||((int64(getMode())==3)))) ) )
            OP_Utils::evalOpParm(myOptVtxMod, node, "optvtxmod", time, 0);
        else myOptVtxMod = true;
        if (true && ( (!(((int64(getMode())!=3)))) ) )
            OP_Utils::evalOpParm(myUseIsectColor, node, "useisectcolor", time, 0);
        else myUseIsectColor = true;
        if (true && ( (!(((getUseIsectColor()==0))||((int64(getMode())!=3)))) ) )
            OP_Utils::evalOpParm(myIsectPolyClr, node, "isectpolyclr", time, 0);
        else myIsectPolyClr = UT_Vector3D(0.9,0,0);
        if (true && ( (!(((int64(getMode())!=3)))) ) )
            OP_Utils::evalOpParm(myUseIsectGrp, node, "useisectgrp", time, 0);
        else myUseIsectGrp = true;
        if (true && ( (!(((getUseIsectGrp()==0))||((int64(getMode())!=3)))) ) )
            OP_Utils::evalOpParm(myIsectPolyGrp, node, "isectpolygrp", time, 0);
        else myIsectPolyGrp = "intersecting_polygon_grp"_sh;
        if (true)
            OP_Utils::evalOpParm(myFailures, node, "failures", time, 0);
        else myFailures = 0;
        if (true)
            OP_Utils::evalOpParm(myRandomSeed, node, "randomseed", time, 0);
        else myRandomSeed = 3;
        if (true)
            OP_Utils::evalOpParm(myPrecisionTol, node, "precisiontol", time, 0);
        else myPrecisionTol = 1e-09;
        if (true)
            OP_Utils::evalOpParm(myDihedralAngleTol, node, "dihedralangtol", time, 0);
        else myDihedralAngleTol = 1e-05;
        if (true)
            OP_Utils::evalOpParm(myMaxAttempts, node, "maxattempts", time, 0);
        else myMaxAttempts = 5;
        if (true)
            OP_Utils::evalOpParm(myUseInvalidColor, node, "useinvalidcolor", time, 0);
        else myUseInvalidColor = true;
        if (true && ( (!(((getUseInvalidColor()==0)))) ) )
            OP_Utils::evalOpParm(myInvalidPrimClr, node, "invalidprimclr", time, 0);
        else myInvalidPrimClr = UT_Vector3D(0.2,0,0);
        if (true)
            OP_Utils::evalOpParm(myUseInvalidGrp, node, "useinvalidgrp", time, 0);
        else myUseInvalidGrp = true;
        if (true && ( (!(((getUseInvalidGrp()==0)))) ) )
            OP_Utils::evalOpParm(myInvalidPrimGrp, node, "invalidprimgrp", time, 0);
        else myInvalidPrimGrp = "invalid_prim_grp"_sh;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_Tetrahedralize_2_0Parms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myGroup);
                break;
            case 1:
                coerceValue(value, myBatch);
                break;
            case 2:
                coerceValue(value, myPieceAttrib);
                break;
            case 3:
                coerceValue(value, myRemove);
                break;
            case 4:
                coerceValue(value, myMode);
                break;
            case 5:
                coerceValue(value, myOutput);
                break;
            case 6:
                coerceValue(value, myKeepPrims);
                break;
            case 7:
                coerceValue(value, myNoBoundMod);
                break;
            case 8:
                coerceValue(value, myOneFacePerTet);
                break;
            case 9:
                coerceValue(value, myPropNormal);
                break;
            case 10:
                coerceValue(value, myInternAttrib);
                break;
            case 11:
                coerceValue(value, myUseQuality);
                break;
            case 12:
                coerceValue(value, myRadEdgeTol);
                break;
            case 13:
                coerceValue(value, myMinDihedralAngle);
                break;
            case 14:
                coerceValue(value, myUseTargetSizeAttrib);
                break;
            case 15:
                coerceValue(value, myTargetSizeAttrib);
                break;
            case 16:
                coerceValue(value, myUseUniformMaxSize);
                break;
            case 17:
                coerceValue(value, myUniformMaxSize);
                break;
            case 18:
                coerceValue(value, myUseMaxSizeAttrib);
                break;
            case 19:
                coerceValue(value, myMaxSizeAttrib);
                break;
            case 20:
                coerceValue(value, myUseMaxIter);
                break;
            case 21:
                coerceValue(value, myMaxIter);
                break;
            case 22:
                coerceValue(value, myUseMaxSteiner);
                break;
            case 23:
                coerceValue(value, myMaxSteiner);
                break;
            case 24:
                coerceValue(value, myOptIterations);
                break;
            case 25:
                coerceValue(value, myOptEdgeFace);
                break;
            case 26:
                coerceValue(value, myOptVtxSmooth);
                break;
            case 27:
                coerceValue(value, myOptVtxMod);
                break;
            case 28:
                coerceValue(value, myUseIsectColor);
                break;
            case 29:
                coerceValue(value, myIsectPolyClr);
                break;
            case 30:
                coerceValue(value, myUseIsectGrp);
                break;
            case 31:
                coerceValue(value, myIsectPolyGrp);
                break;
            case 32:
                coerceValue(value, myFailures);
                break;
            case 33:
                coerceValue(value, myRandomSeed);
                break;
            case 34:
                coerceValue(value, myPrecisionTol);
                break;
            case 35:
                coerceValue(value, myDihedralAngleTol);
                break;
            case 36:
                coerceValue(value, myMaxAttempts);
                break;
            case 37:
                coerceValue(value, myUseInvalidColor);
                break;
            case 38:
                coerceValue(value, myInvalidPrimClr);
                break;
            case 39:
                coerceValue(value, myUseInvalidGrp);
                break;
            case 40:
                coerceValue(value, myInvalidPrimGrp);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myGroup, value);
                break;
            case 1:
                coerceValue(myBatch, value);
                break;
            case 2:
                coerceValue(myPieceAttrib, value);
                break;
            case 3:
                coerceValue(myRemove, value);
                break;
            case 4:
                coerceValue(myMode, value);
                break;
            case 5:
                coerceValue(myOutput, value);
                break;
            case 6:
                coerceValue(myKeepPrims, value);
                break;
            case 7:
                coerceValue(myNoBoundMod, value);
                break;
            case 8:
                coerceValue(myOneFacePerTet, value);
                break;
            case 9:
                coerceValue(myPropNormal, value);
                break;
            case 10:
                coerceValue(myInternAttrib, value);
                break;
            case 11:
                coerceValue(myUseQuality, value);
                break;
            case 12:
                coerceValue(myRadEdgeTol, value);
                break;
            case 13:
                coerceValue(myMinDihedralAngle, value);
                break;
            case 14:
                coerceValue(myUseTargetSizeAttrib, value);
                break;
            case 15:
                coerceValue(myTargetSizeAttrib, value);
                break;
            case 16:
                coerceValue(myUseUniformMaxSize, value);
                break;
            case 17:
                coerceValue(myUniformMaxSize, value);
                break;
            case 18:
                coerceValue(myUseMaxSizeAttrib, value);
                break;
            case 19:
                coerceValue(myMaxSizeAttrib, value);
                break;
            case 20:
                coerceValue(myUseMaxIter, value);
                break;
            case 21:
                coerceValue(myMaxIter, value);
                break;
            case 22:
                coerceValue(myUseMaxSteiner, value);
                break;
            case 23:
                coerceValue(myMaxSteiner, value);
                break;
            case 24:
                coerceValue(myOptIterations, value);
                break;
            case 25:
                coerceValue(myOptEdgeFace, value);
                break;
            case 26:
                coerceValue(myOptVtxSmooth, value);
                break;
            case 27:
                coerceValue(myOptVtxMod, value);
                break;
            case 28:
                coerceValue(myUseIsectColor, value);
                break;
            case 29:
                coerceValue(myIsectPolyClr, value);
                break;
            case 30:
                coerceValue(myUseIsectGrp, value);
                break;
            case 31:
                coerceValue(myIsectPolyGrp, value);
                break;
            case 32:
                coerceValue(myFailures, value);
                break;
            case 33:
                coerceValue(myRandomSeed, value);
                break;
            case 34:
                coerceValue(myPrecisionTol, value);
                break;
            case 35:
                coerceValue(myDihedralAngleTol, value);
                break;
            case 36:
                coerceValue(myMaxAttempts, value);
                break;
            case 37:
                coerceValue(myUseInvalidColor, value);
                break;
            case 38:
                coerceValue(myInvalidPrimClr, value);
                break;
            case 39:
                coerceValue(myUseInvalidGrp, value);
                break;
            case 40:
                coerceValue(myInvalidPrimGrp, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 41;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "group";
            case 1:
                return "batch";
            case 2:
                return "pieceattrib";
            case 3:
                return "remove";
            case 4:
                return "mode";
            case 5:
                return "output";
            case 6:
                return "keepprims";
            case 7:
                return "noboundmod";
            case 8:
                return "onefacepertet";
            case 9:
                return "propnormal";
            case 10:
                return "internattrib";
            case 11:
                return "usequality";
            case 12:
                return "radedgetol";
            case 13:
                return "mindihedralang";
            case 14:
                return "usetargetsizeattrib";
            case 15:
                return "targetsizeattrib";
            case 16:
                return "useuniformmaxsize";
            case 17:
                return "uniformmaxsize";
            case 18:
                return "usemaxsizeattrib";
            case 19:
                return "maxsizeattrib";
            case 20:
                return "usemaxiter";
            case 21:
                return "maxiter";
            case 22:
                return "usemaxsteiner";
            case 23:
                return "maxsteiner";
            case 24:
                return "optiterations";
            case 25:
                return "optedgeface";
            case 26:
                return "optvtxsmooth";
            case 27:
                return "optvtxmod";
            case 28:
                return "useisectcolor";
            case 29:
                return "isectpolyclr";
            case 30:
                return "useisectgrp";
            case 31:
                return "isectpolygrp";
            case 32:
                return "failures";
            case 33:
                return "randomseed";
            case 34:
                return "precisiontol";
            case 35:
                return "dihedralangtol";
            case 36:
                return "maxattempts";
            case 37:
                return "useinvalidcolor";
            case 38:
                return "invalidprimclr";
            case 39:
                return "useinvalidgrp";
            case 40:
                return "invalidprimgrp";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_STRING;
                case 3:
                    return PARM_INTEGER;
                case 4:
                    return PARM_INTEGER;
                case 5:
                    return PARM_INTEGER;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_INTEGER;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_INTEGER;
                case 11:
                    return PARM_INTEGER;
                case 12:
                    return PARM_FLOAT;
                case 13:
                    return PARM_FLOAT;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_STRING;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_FLOAT;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_STRING;
                case 20:
                    return PARM_INTEGER;
                case 21:
                    return PARM_INTEGER;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_INTEGER;
                case 24:
                    return PARM_INTEGER;
                case 25:
                    return PARM_INTEGER;
                case 26:
                    return PARM_INTEGER;
                case 27:
                    return PARM_INTEGER;
                case 28:
                    return PARM_INTEGER;
                case 29:
                    return PARM_VECTOR3;
                case 30:
                    return PARM_INTEGER;
                case 31:
                    return PARM_STRING;
                case 32:
                    return PARM_INTEGER;
                case 33:
                    return PARM_INTEGER;
                case 34:
                    return PARM_FLOAT;
                case 35:
                    return PARM_FLOAT;
                case 36:
                    return PARM_INTEGER;
                case 37:
                    return PARM_INTEGER;
                case 38:
                    return PARM_VECTOR3;
                case 39:
                    return PARM_INTEGER;
                case 40:
                    return PARM_STRING;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myGroup);
        saveData(os, myBatch);
        saveData(os, myPieceAttrib);
        saveData(os, myRemove);
        saveData(os, myMode);
        saveData(os, myOutput);
        saveData(os, myKeepPrims);
        saveData(os, myNoBoundMod);
        saveData(os, myOneFacePerTet);
        saveData(os, myPropNormal);
        saveData(os, myInternAttrib);
        saveData(os, myUseQuality);
        saveData(os, myRadEdgeTol);
        saveData(os, myMinDihedralAngle);
        saveData(os, myUseTargetSizeAttrib);
        saveData(os, myTargetSizeAttrib);
        saveData(os, myUseUniformMaxSize);
        saveData(os, myUniformMaxSize);
        saveData(os, myUseMaxSizeAttrib);
        saveData(os, myMaxSizeAttrib);
        saveData(os, myUseMaxIter);
        saveData(os, myMaxIter);
        saveData(os, myUseMaxSteiner);
        saveData(os, myMaxSteiner);
        saveData(os, myOptIterations);
        saveData(os, myOptEdgeFace);
        saveData(os, myOptVtxSmooth);
        saveData(os, myOptVtxMod);
        saveData(os, myUseIsectColor);
        saveData(os, myIsectPolyClr);
        saveData(os, myUseIsectGrp);
        saveData(os, myIsectPolyGrp);
        saveData(os, myFailures);
        saveData(os, myRandomSeed);
        saveData(os, myPrecisionTol);
        saveData(os, myDihedralAngleTol);
        saveData(os, myMaxAttempts);
        saveData(os, myUseInvalidColor);
        saveData(os, myInvalidPrimClr);
        saveData(os, myUseInvalidGrp);
        saveData(os, myInvalidPrimGrp);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myGroup);
        loadData(is, myBatch);
        loadData(is, myPieceAttrib);
        loadData(is, myRemove);
        loadData(is, myMode);
        loadData(is, myOutput);
        loadData(is, myKeepPrims);
        loadData(is, myNoBoundMod);
        loadData(is, myOneFacePerTet);
        loadData(is, myPropNormal);
        loadData(is, myInternAttrib);
        loadData(is, myUseQuality);
        loadData(is, myRadEdgeTol);
        loadData(is, myMinDihedralAngle);
        loadData(is, myUseTargetSizeAttrib);
        loadData(is, myTargetSizeAttrib);
        loadData(is, myUseUniformMaxSize);
        loadData(is, myUniformMaxSize);
        loadData(is, myUseMaxSizeAttrib);
        loadData(is, myMaxSizeAttrib);
        loadData(is, myUseMaxIter);
        loadData(is, myMaxIter);
        loadData(is, myUseMaxSteiner);
        loadData(is, myMaxSteiner);
        loadData(is, myOptIterations);
        loadData(is, myOptEdgeFace);
        loadData(is, myOptVtxSmooth);
        loadData(is, myOptVtxMod);
        loadData(is, myUseIsectColor);
        loadData(is, myIsectPolyClr);
        loadData(is, myUseIsectGrp);
        loadData(is, myIsectPolyGrp);
        loadData(is, myFailures);
        loadData(is, myRandomSeed);
        loadData(is, myPrecisionTol);
        loadData(is, myDihedralAngleTol);
        loadData(is, myMaxAttempts);
        loadData(is, myUseInvalidColor);
        loadData(is, myInvalidPrimClr);
        loadData(is, myUseInvalidGrp);
        loadData(is, myInvalidPrimGrp);

        return true;
    }

    const UT_StringHolder & getGroup() const { return myGroup; }
    void setGroup(const UT_StringHolder & val) { myGroup = val; }
    UT_StringHolder opGroup(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroup();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "group", cookparms.getCookTime(), 0);
        return result;
    }
    Batch getBatch() const { return Batch(myBatch); }
    void setBatch(Batch val) { myBatch = int64(val); }
    Batch opBatch(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBatch();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "batch", cookparms.getCookTime(), 0);
        return Batch(result);
    }
    const UT_StringHolder & getPieceAttrib() const { return myPieceAttrib; }
    void setPieceAttrib(const UT_StringHolder & val) { myPieceAttrib = val; }
    UT_StringHolder opPieceAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPieceAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "pieceattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getRemove() const { return myRemove; }
    void setRemove(bool val) { myRemove = val; }
    bool opRemove(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRemove();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "remove", cookparms.getCookTime(), 0);
        return result;
    }
    Mode getMode() const { return Mode(myMode); }
    void setMode(Mode val) { myMode = int64(val); }
    Mode opMode(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMode();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "mode", cookparms.getCookTime(), 0);
        return Mode(result);
    }
    Output getOutput() const { return Output(myOutput); }
    void setOutput(Output val) { myOutput = int64(val); }
    Output opOutput(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOutput();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "output", cookparms.getCookTime(), 0);
        return Output(result);
    }
    bool getKeepPrims() const { return myKeepPrims; }
    void setKeepPrims(bool val) { myKeepPrims = val; }
    bool opKeepPrims(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getKeepPrims();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "keepprims", cookparms.getCookTime(), 0);
        return result;
    }
    bool getNoBoundMod() const { return myNoBoundMod; }
    void setNoBoundMod(bool val) { myNoBoundMod = val; }
    bool opNoBoundMod(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getNoBoundMod();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "noboundmod", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOneFacePerTet() const { return myOneFacePerTet; }
    void setOneFacePerTet(bool val) { myOneFacePerTet = val; }
    bool opOneFacePerTet(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOneFacePerTet();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "onefacepertet", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPropNormal() const { return myPropNormal; }
    void setPropNormal(bool val) { myPropNormal = val; }
    bool opPropNormal(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPropNormal();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "propnormal", cookparms.getCookTime(), 0);
        return result;
    }
    bool getInternAttrib() const { return myInternAttrib; }
    void setInternAttrib(bool val) { myInternAttrib = val; }
    bool opInternAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInternAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "internattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseQuality() const { return myUseQuality; }
    void setUseQuality(bool val) { myUseQuality = val; }
    bool opUseQuality(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseQuality();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usequality", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getRadEdgeTol() const { return myRadEdgeTol; }
    void setRadEdgeTol(fpreal64 val) { myRadEdgeTol = val; }
    fpreal64 opRadEdgeTol(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRadEdgeTol();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "radedgetol", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getMinDihedralAngle() const { return myMinDihedralAngle; }
    void setMinDihedralAngle(fpreal64 val) { myMinDihedralAngle = val; }
    fpreal64 opMinDihedralAngle(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMinDihedralAngle();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "mindihedralang", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseTargetSizeAttrib() const { return myUseTargetSizeAttrib; }
    void setUseTargetSizeAttrib(bool val) { myUseTargetSizeAttrib = val; }
    bool opUseTargetSizeAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseTargetSizeAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usetargetsizeattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getTargetSizeAttrib() const { return myTargetSizeAttrib; }
    void setTargetSizeAttrib(const UT_StringHolder & val) { myTargetSizeAttrib = val; }
    UT_StringHolder opTargetSizeAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getTargetSizeAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "targetsizeattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseUniformMaxSize() const { return myUseUniformMaxSize; }
    void setUseUniformMaxSize(bool val) { myUseUniformMaxSize = val; }
    bool opUseUniformMaxSize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseUniformMaxSize();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useuniformmaxsize", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getUniformMaxSize() const { return myUniformMaxSize; }
    void setUniformMaxSize(fpreal64 val) { myUniformMaxSize = val; }
    fpreal64 opUniformMaxSize(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUniformMaxSize();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "uniformmaxsize", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseMaxSizeAttrib() const { return myUseMaxSizeAttrib; }
    void setUseMaxSizeAttrib(bool val) { myUseMaxSizeAttrib = val; }
    bool opUseMaxSizeAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseMaxSizeAttrib();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usemaxsizeattrib", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getMaxSizeAttrib() const { return myMaxSizeAttrib; }
    void setMaxSizeAttrib(const UT_StringHolder & val) { myMaxSizeAttrib = val; }
    UT_StringHolder opMaxSizeAttrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxSizeAttrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "maxsizeattrib", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseMaxIter() const { return myUseMaxIter; }
    void setUseMaxIter(bool val) { myUseMaxIter = val; }
    bool opUseMaxIter(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseMaxIter();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usemaxiter", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getMaxIter() const { return myMaxIter; }
    void setMaxIter(int64 val) { myMaxIter = val; }
    int64 opMaxIter(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxIter();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "maxiter", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseMaxSteiner() const { return myUseMaxSteiner; }
    void setUseMaxSteiner(bool val) { myUseMaxSteiner = val; }
    bool opUseMaxSteiner(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseMaxSteiner();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usemaxsteiner", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getMaxSteiner() const { return myMaxSteiner; }
    void setMaxSteiner(int64 val) { myMaxSteiner = val; }
    int64 opMaxSteiner(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxSteiner();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "maxsteiner", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getOptIterations() const { return myOptIterations; }
    void setOptIterations(int64 val) { myOptIterations = val; }
    int64 opOptIterations(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOptIterations();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "optiterations", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOptEdgeFace() const { return myOptEdgeFace; }
    void setOptEdgeFace(bool val) { myOptEdgeFace = val; }
    bool opOptEdgeFace(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOptEdgeFace();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "optedgeface", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOptVtxSmooth() const { return myOptVtxSmooth; }
    void setOptVtxSmooth(bool val) { myOptVtxSmooth = val; }
    bool opOptVtxSmooth(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOptVtxSmooth();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "optvtxsmooth", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOptVtxMod() const { return myOptVtxMod; }
    void setOptVtxMod(bool val) { myOptVtxMod = val; }
    bool opOptVtxMod(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOptVtxMod();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "optvtxmod", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseIsectColor() const { return myUseIsectColor; }
    void setUseIsectColor(bool val) { myUseIsectColor = val; }
    bool opUseIsectColor(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseIsectColor();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useisectcolor", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getIsectPolyClr() const { return myIsectPolyClr; }
    void setIsectPolyClr(UT_Vector3D val) { myIsectPolyClr = val; }
    UT_Vector3D opIsectPolyClr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIsectPolyClr();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "isectpolyclr", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseIsectGrp() const { return myUseIsectGrp; }
    void setUseIsectGrp(bool val) { myUseIsectGrp = val; }
    bool opUseIsectGrp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseIsectGrp();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useisectgrp", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getIsectPolyGrp() const { return myIsectPolyGrp; }
    void setIsectPolyGrp(const UT_StringHolder & val) { myIsectPolyGrp = val; }
    UT_StringHolder opIsectPolyGrp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getIsectPolyGrp();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "isectpolygrp", cookparms.getCookTime(), 0);
        return result;
    }
    Failures getFailures() const { return Failures(myFailures); }
    void setFailures(Failures val) { myFailures = int64(val); }
    Failures opFailures(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getFailures();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "failures", cookparms.getCookTime(), 0);
        return Failures(result);
    }
    int64 getRandomSeed() const { return myRandomSeed; }
    void setRandomSeed(int64 val) { myRandomSeed = val; }
    int64 opRandomSeed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRandomSeed();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "randomseed", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getPrecisionTol() const { return myPrecisionTol; }
    void setPrecisionTol(fpreal64 val) { myPrecisionTol = val; }
    fpreal64 opPrecisionTol(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrecisionTol();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "precisiontol", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getDihedralAngleTol() const { return myDihedralAngleTol; }
    void setDihedralAngleTol(fpreal64 val) { myDihedralAngleTol = val; }
    fpreal64 opDihedralAngleTol(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDihedralAngleTol();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "dihedralangtol", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getMaxAttempts() const { return myMaxAttempts; }
    void setMaxAttempts(int64 val) { myMaxAttempts = val; }
    int64 opMaxAttempts(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMaxAttempts();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "maxattempts", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseInvalidColor() const { return myUseInvalidColor; }
    void setUseInvalidColor(bool val) { myUseInvalidColor = val; }
    bool opUseInvalidColor(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseInvalidColor();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useinvalidcolor", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getInvalidPrimClr() const { return myInvalidPrimClr; }
    void setInvalidPrimClr(UT_Vector3D val) { myInvalidPrimClr = val; }
    UT_Vector3D opInvalidPrimClr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInvalidPrimClr();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "invalidprimclr", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseInvalidGrp() const { return myUseInvalidGrp; }
    void setUseInvalidGrp(bool val) { myUseInvalidGrp = val; }
    bool opUseInvalidGrp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseInvalidGrp();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useinvalidgrp", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getInvalidPrimGrp() const { return myInvalidPrimGrp; }
    void setInvalidPrimGrp(const UT_StringHolder & val) { myInvalidPrimGrp = val; }
    UT_StringHolder opInvalidPrimGrp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getInvalidPrimGrp();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "invalidprimgrp", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myGroup;
    int64 myBatch;
    UT_StringHolder myPieceAttrib;
    bool myRemove;
    int64 myMode;
    int64 myOutput;
    bool myKeepPrims;
    bool myNoBoundMod;
    bool myOneFacePerTet;
    bool myPropNormal;
    bool myInternAttrib;
    bool myUseQuality;
    fpreal64 myRadEdgeTol;
    fpreal64 myMinDihedralAngle;
    bool myUseTargetSizeAttrib;
    UT_StringHolder myTargetSizeAttrib;
    bool myUseUniformMaxSize;
    fpreal64 myUniformMaxSize;
    bool myUseMaxSizeAttrib;
    UT_StringHolder myMaxSizeAttrib;
    bool myUseMaxIter;
    int64 myMaxIter;
    bool myUseMaxSteiner;
    int64 myMaxSteiner;
    int64 myOptIterations;
    bool myOptEdgeFace;
    bool myOptVtxSmooth;
    bool myOptVtxMod;
    bool myUseIsectColor;
    UT_Vector3D myIsectPolyClr;
    bool myUseIsectGrp;
    UT_StringHolder myIsectPolyGrp;
    int64 myFailures;
    int64 myRandomSeed;
    fpreal64 myPrecisionTol;
    fpreal64 myDihedralAngleTol;
    int64 myMaxAttempts;
    bool myUseInvalidColor;
    UT_Vector3D myInvalidPrimClr;
    bool myUseInvalidGrp;
    UT_StringHolder myInvalidPrimGrp;

};
