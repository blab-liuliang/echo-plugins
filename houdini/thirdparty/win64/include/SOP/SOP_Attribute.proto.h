/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;

class SOP_API SOP_AttributeParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }
    struct Ptrenames
    {
        UT_StringHolder frompt;
        UT_StringHolder topt;


        Ptrenames()
        {
            frompt = ""_sh;
            topt = ""_sh;

        }

        bool operator==(const Ptrenames &src) const
        {
            if (frompt != src.frompt) return false;
            if (topt != src.topt) return false;

            return true;
        }
        bool operator!=(const Ptrenames &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Ptrenames> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            { UT_String tmp; tmp = UT_StringWrap(list(i).frompt).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).topt).makeQuotedString('"'); buf.strcat(tmp); }

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }
    struct Vtxrenames
    {
        UT_StringHolder fromvtx;
        UT_StringHolder tovtx;


        Vtxrenames()
        {
            fromvtx = ""_sh;
            tovtx = ""_sh;

        }

        bool operator==(const Vtxrenames &src) const
        {
            if (fromvtx != src.fromvtx) return false;
            if (tovtx != src.tovtx) return false;

            return true;
        }
        bool operator!=(const Vtxrenames &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Vtxrenames> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            { UT_String tmp; tmp = UT_StringWrap(list(i).fromvtx).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).tovtx).makeQuotedString('"'); buf.strcat(tmp); }

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }
    struct Primrenames
    {
        UT_StringHolder frompr;
        UT_StringHolder topr;


        Primrenames()
        {
            frompr = ""_sh;
            topr = ""_sh;

        }

        bool operator==(const Primrenames &src) const
        {
            if (frompr != src.frompr) return false;
            if (topr != src.topr) return false;

            return true;
        }
        bool operator!=(const Primrenames &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Primrenames> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            { UT_String tmp; tmp = UT_StringWrap(list(i).frompr).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).topr).makeQuotedString('"'); buf.strcat(tmp); }

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }
    struct Detailrenames
    {
        UT_StringHolder fromdtl;
        UT_StringHolder todtl;


        Detailrenames()
        {
            fromdtl = ""_sh;
            todtl = ""_sh;

        }

        bool operator==(const Detailrenames &src) const
        {
            if (fromdtl != src.fromdtl) return false;
            if (todtl != src.todtl) return false;

            return true;
        }
        bool operator!=(const Detailrenames &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Detailrenames> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            { UT_String tmp; tmp = UT_StringWrap(list(i).fromdtl).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).todtl).makeQuotedString('"'); buf.strcat(tmp); }

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }
    struct Rmanconversions
    {
        UT_StringHolder hname;
        UT_StringHolder riname;
        UT_StringHolder ritype;
        int64 rioff;


        Rmanconversions()
        {
            hname = ""_sh;
            riname = ""_sh;
            ritype = "vtx_float"_sh;
            rioff = 0;

        }

        bool operator==(const Rmanconversions &src) const
        {
            if (hname != src.hname) return false;
            if (riname != src.riname) return false;
            if (ritype != src.ritype) return false;
            if (rioff != src.rioff) return false;

            return true;
        }
        bool operator!=(const Rmanconversions &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<Rmanconversions> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            { UT_String tmp; tmp = UT_StringWrap(list(i).hname).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).riname).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).ritype).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).rioff);

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }

    SOP_AttributeParms()
    {
        myPtdel = ""_sh;
        myPtkeep = "*"_sh;
        myVtxdel = ""_sh;
        myVtxkeep = "*"_sh;
        myPrimdel = ""_sh;
        myPrimkeep = "*"_sh;
        myDtldel = ""_sh;
        myDtlkeep = "*"_sh;
        myRidefault = false;
        myUpdatevar = true;
        myOverwrite = false;

    }

    explicit SOP_AttributeParms(const SOP_AttributeParms &) = default;

    virtual ~SOP_AttributeParms() {}

    bool operator==(const SOP_AttributeParms &src) const
    {
        if (myPtrenames != src.myPtrenames) return false;
        if (myPtdel != src.myPtdel) return false;
        if (myPtkeep != src.myPtkeep) return false;
        if (myVtxrenames != src.myVtxrenames) return false;
        if (myVtxdel != src.myVtxdel) return false;
        if (myVtxkeep != src.myVtxkeep) return false;
        if (myPrimrenames != src.myPrimrenames) return false;
        if (myPrimdel != src.myPrimdel) return false;
        if (myPrimkeep != src.myPrimkeep) return false;
        if (myDetailrenames != src.myDetailrenames) return false;
        if (myDtldel != src.myDtldel) return false;
        if (myDtlkeep != src.myDtlkeep) return false;
        if (myRmanconversions != src.myRmanconversions) return false;
        if (myRidefault != src.myRidefault) return false;
        if (myUpdatevar != src.myUpdatevar) return false;
        if (myOverwrite != src.myOverwrite) return false;

        return true;
    }
    bool operator!=(const SOP_AttributeParms &src) const
    {
        return !operator==(src);
    }



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
            if (true)
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "ptrenames", time, 0);
                myPtrenames.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myPtrenames(i);
                    (void) _curentry;
                    if (true)
                        OP_Utils::evalOpParmInst(myPtrenames(i).frompt, node, "frompt#", &parmidx, time, 0);
                    else myPtrenames(i).frompt = ""_sh;
                    if (true)
                        OP_Utils::evalOpParmInst(myPtrenames(i).topt, node, "topt#", &parmidx, time, 0);
                    else myPtrenames(i).topt = ""_sh;

                }
            }
            else
                myPtrenames.clear();
        if (true)
            OP_Utils::evalOpParm(myPtdel, node, "ptdel", time, 0);
        else myPtdel = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myPtkeep, node, "ptkeep", time, 0);
        else myPtkeep = "*"_sh;
            if (true)
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "vtxrenames", time, 0);
                myVtxrenames.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myVtxrenames(i);
                    (void) _curentry;
                    if (true)
                        OP_Utils::evalOpParmInst(myVtxrenames(i).fromvtx, node, "fromvtx#", &parmidx, time, 0);
                    else myVtxrenames(i).fromvtx = ""_sh;
                    if (true)
                        OP_Utils::evalOpParmInst(myVtxrenames(i).tovtx, node, "tovtx#", &parmidx, time, 0);
                    else myVtxrenames(i).tovtx = ""_sh;

                }
            }
            else
                myVtxrenames.clear();
        if (true)
            OP_Utils::evalOpParm(myVtxdel, node, "vtxdel", time, 0);
        else myVtxdel = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myVtxkeep, node, "vtxkeep", time, 0);
        else myVtxkeep = "*"_sh;
            if (true)
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "primrenames", time, 0);
                myPrimrenames.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myPrimrenames(i);
                    (void) _curentry;
                    if (true)
                        OP_Utils::evalOpParmInst(myPrimrenames(i).frompr, node, "frompr#", &parmidx, time, 0);
                    else myPrimrenames(i).frompr = ""_sh;
                    if (true)
                        OP_Utils::evalOpParmInst(myPrimrenames(i).topr, node, "topr#", &parmidx, time, 0);
                    else myPrimrenames(i).topr = ""_sh;

                }
            }
            else
                myPrimrenames.clear();
        if (true)
            OP_Utils::evalOpParm(myPrimdel, node, "primdel", time, 0);
        else myPrimdel = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myPrimkeep, node, "primkeep", time, 0);
        else myPrimkeep = "*"_sh;
            if (true)
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "detailrenames", time, 0);
                myDetailrenames.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myDetailrenames(i);
                    (void) _curentry;
                    if (true)
                        OP_Utils::evalOpParmInst(myDetailrenames(i).fromdtl, node, "fromdtl#", &parmidx, time, 0);
                    else myDetailrenames(i).fromdtl = ""_sh;
                    if (true)
                        OP_Utils::evalOpParmInst(myDetailrenames(i).todtl, node, "todtl#", &parmidx, time, 0);
                    else myDetailrenames(i).todtl = ""_sh;

                }
            }
            else
                myDetailrenames.clear();
        if (true)
            OP_Utils::evalOpParm(myDtldel, node, "dtldel", time, 0);
        else myDtldel = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myDtlkeep, node, "dtlkeep", time, 0);
        else myDtlkeep = "*"_sh;
            if (true)
            {
                int64   length;
                OP_Utils::evalOpParm(length, node, "rmanconversions", time, 0);
                myRmanconversions.entries(length);
                for (exint i = 0; i < length; i++)
                {
                    int     parmidx = i+0;
                    auto && _curentry = myRmanconversions(i);
                    (void) _curentry;
                    if (true)
                        OP_Utils::evalOpParmInst(myRmanconversions(i).hname, node, "hname#", &parmidx, time, 0);
                    else myRmanconversions(i).hname = ""_sh;
                    if (true)
                        OP_Utils::evalOpParmInst(myRmanconversions(i).riname, node, "riname#", &parmidx, time, 0);
                    else myRmanconversions(i).riname = ""_sh;
                    if (true)
                        OP_Utils::evalOpParmInst(myRmanconversions(i).ritype, node, "ritype#", &parmidx, time, 0);
                    else myRmanconversions(i).ritype = "vtx_float"_sh;
                    if (true)
                        OP_Utils::evalOpParmInst(myRmanconversions(i).rioff, node, "rioff#", &parmidx, time, 0);
                    else myRmanconversions(i).rioff = 0;

                }
            }
            else
                myRmanconversions.clear();
        if (true)
            OP_Utils::evalOpParm(myRidefault, node, "ridefault", time, 0);
        else myRidefault = false;
        if (true)
            OP_Utils::evalOpParm(myUpdatevar, node, "updatevar", time, 0);
        else myUpdatevar = true;
        if (true)
            OP_Utils::evalOpParm(myOverwrite, node, "overwrite", time, 0);
        else myOverwrite = false;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_AttributeParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 1:
                coerceValue(value, myPtdel);
                break;
            case 2:
                coerceValue(value, myPtkeep);
                break;
            case 4:
                coerceValue(value, myVtxdel);
                break;
            case 5:
                coerceValue(value, myVtxkeep);
                break;
            case 7:
                coerceValue(value, myPrimdel);
                break;
            case 8:
                coerceValue(value, myPrimkeep);
                break;
            case 10:
                coerceValue(value, myDtldel);
                break;
            case 11:
                coerceValue(value, myDtlkeep);
                break;
            case 13:
                coerceValue(value, myRidefault);
                break;
            case 14:
                coerceValue(value, myUpdatevar);
                break;
            case 15:
                coerceValue(value, myOverwrite);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 1:
                coerceValue(myPtdel, value);
                break;
            case 2:
                coerceValue(myPtkeep, value);
                break;
            case 4:
                coerceValue(myVtxdel, value);
                break;
            case 5:
                coerceValue(myVtxkeep, value);
                break;
            case 7:
                coerceValue(myPrimdel, value);
                break;
            case 8:
                coerceValue(myPrimkeep, value);
                break;
            case 10:
                coerceValue(myDtldel, value);
                break;
            case 11:
                coerceValue(myDtlkeep, value);
                break;
            case 13:
                coerceValue(myRidefault, value);
                break;
            case 14:
                coerceValue(myUpdatevar, value);
                break;
            case 15:
                coerceValue(myOverwrite, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 16;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return "ptrenames";
            case 1:
                return "ptdel";
            case 2:
                return "ptkeep";
                case 3:
                    return "vtxrenames";
            case 4:
                return "vtxdel";
            case 5:
                return "vtxkeep";
                case 6:
                    return "primrenames";
            case 7:
                return "primdel";
            case 8:
                return "primkeep";
                case 9:
                    return "detailrenames";
            case 10:
                return "dtldel";
            case 11:
                return "dtlkeep";
                case 12:
                    return "rmanconversions";
            case 13:
                return "ridefault";
            case 14:
                return "updatevar";
            case 15:
                return "overwrite";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 1:
                    return PARM_STRING;
                case 2:
                    return PARM_STRING;
                case 4:
                    return PARM_STRING;
                case 5:
                    return PARM_STRING;
                case 7:
                    return PARM_STRING;
                case 8:
                    return PARM_STRING;
                case 10:
                    return PARM_STRING;
                case 11:
                    return PARM_STRING;
                case 13:
                    return PARM_INTEGER;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_INTEGER;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        {
            int64   length = myPtrenames.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myPtrenames(i).frompt);
                saveData(os, myPtrenames(i).topt);

            }
        }
        saveData(os, myPtdel);
        saveData(os, myPtkeep);
        {
            int64   length = myVtxrenames.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myVtxrenames(i).fromvtx);
                saveData(os, myVtxrenames(i).tovtx);

            }
        }
        saveData(os, myVtxdel);
        saveData(os, myVtxkeep);
        {
            int64   length = myPrimrenames.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myPrimrenames(i).frompr);
                saveData(os, myPrimrenames(i).topr);

            }
        }
        saveData(os, myPrimdel);
        saveData(os, myPrimkeep);
        {
            int64   length = myDetailrenames.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myDetailrenames(i).fromdtl);
                saveData(os, myDetailrenames(i).todtl);

            }
        }
        saveData(os, myDtldel);
        saveData(os, myDtlkeep);
        {
            int64   length = myRmanconversions.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                saveData(os, myRmanconversions(i).hname);
                saveData(os, myRmanconversions(i).riname);
                saveData(os, myRmanconversions(i).ritype);
                saveData(os, myRmanconversions(i).rioff);

            }
        }
        saveData(os, myRidefault);
        saveData(os, myUpdatevar);
        saveData(os, myOverwrite);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        {
            int64   length;
            is.read(&length, 1);
            myPtrenames.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myPtrenames(i).frompt);
                loadData(is, myPtrenames(i).topt);

            }
        }
        loadData(is, myPtdel);
        loadData(is, myPtkeep);
        {
            int64   length;
            is.read(&length, 1);
            myVtxrenames.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myVtxrenames(i).fromvtx);
                loadData(is, myVtxrenames(i).tovtx);

            }
        }
        loadData(is, myVtxdel);
        loadData(is, myVtxkeep);
        {
            int64   length;
            is.read(&length, 1);
            myPrimrenames.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myPrimrenames(i).frompr);
                loadData(is, myPrimrenames(i).topr);

            }
        }
        loadData(is, myPrimdel);
        loadData(is, myPrimkeep);
        {
            int64   length;
            is.read(&length, 1);
            myDetailrenames.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myDetailrenames(i).fromdtl);
                loadData(is, myDetailrenames(i).todtl);

            }
        }
        loadData(is, myDtldel);
        loadData(is, myDtlkeep);
        {
            int64   length;
            is.read(&length, 1);
            myRmanconversions.entries(length);
            for (exint i = 0; i < length; i++)
            {
                loadData(is, myRmanconversions(i).hname);
                loadData(is, myRmanconversions(i).riname);
                loadData(is, myRmanconversions(i).ritype);
                loadData(is, myRmanconversions(i).rioff);

            }
        }
        loadData(is, myRidefault);
        loadData(is, myUpdatevar);
        loadData(is, myOverwrite);

        return true;
    }

    const UT_Array<Ptrenames> &getPtrenames() const { return myPtrenames; }
    void setPtrenames(const UT_Array<Ptrenames> &val) { myPtrenames = val; }
    exint opPtrenames(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPtrenames().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "ptrenames", cookparms.getCookTime(), 0);
        return result;
    }
            UT_StringHolder opPtrenames_frompt(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myPtrenames(_idx).frompt);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "frompt#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opPtrenames_topt(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myPtrenames(_idx).topt);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "topt#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    const UT_StringHolder & getPtdel() const { return myPtdel; }
    void setPtdel(const UT_StringHolder & val) { myPtdel = val; }
    UT_StringHolder opPtdel(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPtdel();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "ptdel", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPtkeep() const { return myPtkeep; }
    void setPtkeep(const UT_StringHolder & val) { myPtkeep = val; }
    UT_StringHolder opPtkeep(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPtkeep();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "ptkeep", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Vtxrenames> &getVtxrenames() const { return myVtxrenames; }
    void setVtxrenames(const UT_Array<Vtxrenames> &val) { myVtxrenames = val; }
    exint opVtxrenames(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVtxrenames().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "vtxrenames", cookparms.getCookTime(), 0);
        return result;
    }
            UT_StringHolder opVtxrenames_fromvtx(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myVtxrenames(_idx).fromvtx);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "fromvtx#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opVtxrenames_tovtx(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myVtxrenames(_idx).tovtx);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "tovtx#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    const UT_StringHolder & getVtxdel() const { return myVtxdel; }
    void setVtxdel(const UT_StringHolder & val) { myVtxdel = val; }
    UT_StringHolder opVtxdel(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVtxdel();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "vtxdel", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getVtxkeep() const { return myVtxkeep; }
    void setVtxkeep(const UT_StringHolder & val) { myVtxkeep = val; }
    UT_StringHolder opVtxkeep(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVtxkeep();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "vtxkeep", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Primrenames> &getPrimrenames() const { return myPrimrenames; }
    void setPrimrenames(const UT_Array<Primrenames> &val) { myPrimrenames = val; }
    exint opPrimrenames(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimrenames().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "primrenames", cookparms.getCookTime(), 0);
        return result;
    }
            UT_StringHolder opPrimrenames_frompr(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myPrimrenames(_idx).frompr);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "frompr#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opPrimrenames_topr(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myPrimrenames(_idx).topr);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "topr#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    const UT_StringHolder & getPrimdel() const { return myPrimdel; }
    void setPrimdel(const UT_StringHolder & val) { myPrimdel = val; }
    UT_StringHolder opPrimdel(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimdel();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primdel", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPrimkeep() const { return myPrimkeep; }
    void setPrimkeep(const UT_StringHolder & val) { myPrimkeep = val; }
    UT_StringHolder opPrimkeep(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimkeep();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primkeep", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Detailrenames> &getDetailrenames() const { return myDetailrenames; }
    void setDetailrenames(const UT_Array<Detailrenames> &val) { myDetailrenames = val; }
    exint opDetailrenames(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDetailrenames().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "detailrenames", cookparms.getCookTime(), 0);
        return result;
    }
            UT_StringHolder opDetailrenames_fromdtl(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myDetailrenames(_idx).fromdtl);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "fromdtl#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opDetailrenames_todtl(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myDetailrenames(_idx).todtl);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "todtl#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    const UT_StringHolder & getDtldel() const { return myDtldel; }
    void setDtldel(const UT_StringHolder & val) { myDtldel = val; }
    UT_StringHolder opDtldel(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDtldel();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "dtldel", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getDtlkeep() const { return myDtlkeep; }
    void setDtlkeep(const UT_StringHolder & val) { myDtlkeep = val; }
    UT_StringHolder opDtlkeep(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDtlkeep();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "dtlkeep", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<Rmanconversions> &getRmanconversions() const { return myRmanconversions; }
    void setRmanconversions(const UT_Array<Rmanconversions> &val) { myRmanconversions = val; }
    exint opRmanconversions(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRmanconversions().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "rmanconversions", cookparms.getCookTime(), 0);
        return result;
    }
            UT_StringHolder opRmanconversions_hname(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myRmanconversions(_idx).hname);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "hname#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opRmanconversions_riname(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myRmanconversions(_idx).riname);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "riname#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        UT_StringHolder opRmanconversions_ritype(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myRmanconversions(_idx).ritype);
            int _parmidx = _idx + 0;
            UT_StringHolder result;
            OP_Utils::evalOpParmInst(result, thissop, "ritype#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }
        int64 opRmanconversions_rioff(const SOP_NodeVerb::CookParms &cookparms, exint _idx) const
        {
            SOP_Node *thissop = cookparms.getNode();
            if (!thissop) return (myRmanconversions(_idx).rioff);
            int _parmidx = _idx + 0;
            int64 result;
            OP_Utils::evalOpParmInst(result, thissop, "rioff#", &_parmidx, cookparms.getCookTime(), 0);
            return (result);
        }

    bool getRidefault() const { return myRidefault; }
    void setRidefault(bool val) { myRidefault = val; }
    bool opRidefault(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRidefault();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "ridefault", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUpdatevar() const { return myUpdatevar; }
    void setUpdatevar(bool val) { myUpdatevar = val; }
    bool opUpdatevar(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUpdatevar();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "updatevar", cookparms.getCookTime(), 0);
        return result;
    }
    bool getOverwrite() const { return myOverwrite; }
    void setOverwrite(bool val) { myOverwrite = val; }
    bool opOverwrite(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOverwrite();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "overwrite", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_Array<Ptrenames> myPtrenames;
    UT_StringHolder myPtdel;
    UT_StringHolder myPtkeep;
    UT_Array<Vtxrenames> myVtxrenames;
    UT_StringHolder myVtxdel;
    UT_StringHolder myVtxkeep;
    UT_Array<Primrenames> myPrimrenames;
    UT_StringHolder myPrimdel;
    UT_StringHolder myPrimkeep;
    UT_Array<Detailrenames> myDetailrenames;
    UT_StringHolder myDtldel;
    UT_StringHolder myDtlkeep;
    UT_Array<Rmanconversions> myRmanconversions;
    bool myRidefault;
    bool myUpdatevar;
    bool myOverwrite;

};
