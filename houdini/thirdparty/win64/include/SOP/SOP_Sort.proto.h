/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_SortEnums
{
    enum class Ptsort
    {
        NONE = 0,
        VTXORD,
        BYX,
        BYY,
        BYZ,
        REV,
        SEED,
        SHIF,
        PROX,
        VECTOR,
        EXPRESSION,
        SPATIAL,
        ATTRIBUTE
    };
    enum class Primsort
    {
        NONE = 0,
        BYX,
        BYY,
        BYZ,
        REV,
        SEED,
        SHIF,
        PROX,
        VECTOR,
        EXPRESSION,
        SPATIAL,
        ATTRIBUTE
    };
}


class SOP_API SOP_SortParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_SortParms()
    {
        myPtsort = 0;
        myPointseed = 0;
        myPointoffset = 0;
        myPointprox = UT_Vector3D(0,0,0);
        myPointobjpath = ""_sh;
        myPointdir = UT_Vector3D(0,1,0);
        myPointexpr = 0;
        myPointattrib = ""_sh;
        myPointattribcomp = 0;
        myPointreverse = false;
        myPrimsort = 0;
        myPrimseed = 0;
        myPrimoffset = 0;
        myPrimprox = UT_Vector3D(0,0,0);
        myPrimobjpath = ""_sh;
        myPrimdir = UT_Vector3D(0,1,0);
        myPrimexpr = 0;
        myPrimattrib = ""_sh;
        myPrimattribcomp = 0;
        myPrimreverse = false;
        myVertexPrimOrder = false;

    }

    explicit SOP_SortParms(const SOP_SortParms &) = default;

    virtual ~SOP_SortParms() {}

    bool operator==(const SOP_SortParms &src) const
    {
        if (myPtsort != src.myPtsort) return false;
        if (myPointseed != src.myPointseed) return false;
        if (myPointoffset != src.myPointoffset) return false;
        if (myPointprox != src.myPointprox) return false;
        if (myPointobjpath != src.myPointobjpath) return false;
        if (myPointdir != src.myPointdir) return false;
        if (myPointexpr != src.myPointexpr) return false;
        if (myPointattrib != src.myPointattrib) return false;
        if (myPointattribcomp != src.myPointattribcomp) return false;
        if (myPointreverse != src.myPointreverse) return false;
        if (myPrimsort != src.myPrimsort) return false;
        if (myPrimseed != src.myPrimseed) return false;
        if (myPrimoffset != src.myPrimoffset) return false;
        if (myPrimprox != src.myPrimprox) return false;
        if (myPrimobjpath != src.myPrimobjpath) return false;
        if (myPrimdir != src.myPrimdir) return false;
        if (myPrimexpr != src.myPrimexpr) return false;
        if (myPrimattrib != src.myPrimattrib) return false;
        if (myPrimattribcomp != src.myPrimattribcomp) return false;
        if (myPrimreverse != src.myPrimreverse) return false;
        if (myVertexPrimOrder != src.myVertexPrimOrder) return false;

        return true;
    }
    bool operator!=(const SOP_SortParms &src) const
    {
        return !operator==(src);
    }
    using Ptsort = SOP_SortEnums::Ptsort;
    using Primsort = SOP_SortEnums::Primsort;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myPtsort, node, "ptsort", time, 0);
        else myPtsort = 0;
        if (true && ( (!(((int64(getPtsort())!=6)))) ) )
            OP_Utils::evalOpParm(myPointseed, node, "pointseed", time, 0);
        else myPointseed = 0;
        if (true && ( (!(((int64(getPtsort())!=7)))) ) )
            OP_Utils::evalOpParm(myPointoffset, node, "pointoffset", time, 0);
        else myPointoffset = 0;
        if (true && ( (!(((int64(getPtsort())!=8)))) ) )
            OP_Utils::evalOpParm(myPointprox, node, "pointprox", time, 0);
        else myPointprox = UT_Vector3D(0,0,0);
        if (true && ( (!(((int64(getPtsort())!=9)))) ) )
            OP_Utils::evalOpParm(myPointobjpath, node, "pointobjpath", time, 0);
        else myPointobjpath = ""_sh;
        if (true && ( (!(((int64(getPtsort())!=9)))) ) )
            OP_Utils::evalOpParm(myPointdir, node, "pointdir", time, 0);
        else myPointdir = UT_Vector3D(0,1,0);
        if (true && ( (!(((int64(getPtsort())!=10)))) ) )
            OP_Utils::evalOpParm(myPointexpr, node, "pointexpr", time, 0);
        else myPointexpr = 0;
        if (true && ( (!(((int64(getPtsort())!=12)))) ) )
            OP_Utils::evalOpParm(myPointattrib, node, "pointattrib", time, 0);
        else myPointattrib = ""_sh;
        if (true && ( (!(((int64(getPtsort())!=12)))) ) )
            OP_Utils::evalOpParm(myPointattribcomp, node, "pointattribcomp", time, 0);
        else myPointattribcomp = 0;
        if (true)
            OP_Utils::evalOpParm(myPointreverse, node, "pointreverse", time, 0);
        else myPointreverse = false;
        if (true)
            OP_Utils::evalOpParm(myPrimsort, node, "primsort", time, 0);
        else myPrimsort = 0;
        if (true && ( (!(((int64(getPrimsort())!=5)))) ) )
            OP_Utils::evalOpParm(myPrimseed, node, "primseed", time, 0);
        else myPrimseed = 0;
        if (true && ( (!(((int64(getPrimsort())!=6)))) ) )
            OP_Utils::evalOpParm(myPrimoffset, node, "primoffset", time, 0);
        else myPrimoffset = 0;
        if (true && ( (!(((int64(getPrimsort())!=7)))) ) )
            OP_Utils::evalOpParm(myPrimprox, node, "primprox", time, 0);
        else myPrimprox = UT_Vector3D(0,0,0);
        if (true && ( (!(((int64(getPrimsort())!=8)))) ) )
            OP_Utils::evalOpParm(myPrimobjpath, node, "primobjpath", time, 0);
        else myPrimobjpath = ""_sh;
        if (true && ( (!(((int64(getPrimsort())!=8)))) ) )
            OP_Utils::evalOpParm(myPrimdir, node, "primdir", time, 0);
        else myPrimdir = UT_Vector3D(0,1,0);
        if (true && ( (!(((int64(getPrimsort())!=9)))) ) )
            OP_Utils::evalOpParm(myPrimexpr, node, "primexpr", time, 0);
        else myPrimexpr = 0;
        if (true && ( (!(((int64(getPrimsort())!=11)))) ) )
            OP_Utils::evalOpParm(myPrimattrib, node, "primattrib", time, 0);
        else myPrimattrib = ""_sh;
        if (true && ( (!(((int64(getPrimsort())!=11)))) ) )
            OP_Utils::evalOpParm(myPrimattribcomp, node, "primattribcomp", time, 0);
        else myPrimattribcomp = 0;
        if (true)
            OP_Utils::evalOpParm(myPrimreverse, node, "primreverse", time, 0);
        else myPrimreverse = false;
        if (true)
            OP_Utils::evalOpParm(myVertexPrimOrder, node, "vertexprimorder", time, 0);
        else myVertexPrimOrder = false;

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_SortParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myPtsort);
                break;
            case 1:
                coerceValue(value, myPointseed);
                break;
            case 2:
                coerceValue(value, myPointoffset);
                break;
            case 3:
                coerceValue(value, myPointprox);
                break;
            case 4:
                coerceValue(value, myPointobjpath);
                break;
            case 5:
                coerceValue(value, myPointdir);
                break;
            case 6:
                coerceValue(value, myPointexpr);
                break;
            case 7:
                coerceValue(value, myPointattrib);
                break;
            case 8:
                coerceValue(value, myPointattribcomp);
                break;
            case 9:
                coerceValue(value, myPointreverse);
                break;
            case 10:
                coerceValue(value, myPrimsort);
                break;
            case 11:
                coerceValue(value, myPrimseed);
                break;
            case 12:
                coerceValue(value, myPrimoffset);
                break;
            case 13:
                coerceValue(value, myPrimprox);
                break;
            case 14:
                coerceValue(value, myPrimobjpath);
                break;
            case 15:
                coerceValue(value, myPrimdir);
                break;
            case 16:
                coerceValue(value, myPrimexpr);
                break;
            case 17:
                coerceValue(value, myPrimattrib);
                break;
            case 18:
                coerceValue(value, myPrimattribcomp);
                break;
            case 19:
                coerceValue(value, myPrimreverse);
                break;
            case 20:
                coerceValue(value, myVertexPrimOrder);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myPtsort, value);
                break;
            case 1:
                coerceValue(myPointseed, value);
                break;
            case 2:
                coerceValue(myPointoffset, value);
                break;
            case 3:
                coerceValue(myPointprox, value);
                break;
            case 4:
                coerceValue(myPointobjpath, value);
                break;
            case 5:
                coerceValue(myPointdir, value);
                break;
            case 6:
                coerceValue(myPointexpr, value);
                break;
            case 7:
                coerceValue(myPointattrib, value);
                break;
            case 8:
                coerceValue(myPointattribcomp, value);
                break;
            case 9:
                coerceValue(myPointreverse, value);
                break;
            case 10:
                coerceValue(myPrimsort, value);
                break;
            case 11:
                coerceValue(myPrimseed, value);
                break;
            case 12:
                coerceValue(myPrimoffset, value);
                break;
            case 13:
                coerceValue(myPrimprox, value);
                break;
            case 14:
                coerceValue(myPrimobjpath, value);
                break;
            case 15:
                coerceValue(myPrimdir, value);
                break;
            case 16:
                coerceValue(myPrimexpr, value);
                break;
            case 17:
                coerceValue(myPrimattrib, value);
                break;
            case 18:
                coerceValue(myPrimattribcomp, value);
                break;
            case 19:
                coerceValue(myPrimreverse, value);
                break;
            case 20:
                coerceValue(myVertexPrimOrder, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 21;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "ptsort";
            case 1:
                return "pointseed";
            case 2:
                return "pointoffset";
            case 3:
                return "pointprox";
            case 4:
                return "pointobjpath";
            case 5:
                return "pointdir";
            case 6:
                return "pointexpr";
            case 7:
                return "pointattrib";
            case 8:
                return "pointattribcomp";
            case 9:
                return "pointreverse";
            case 10:
                return "primsort";
            case 11:
                return "primseed";
            case 12:
                return "primoffset";
            case 13:
                return "primprox";
            case 14:
                return "primobjpath";
            case 15:
                return "primdir";
            case 16:
                return "primexpr";
            case 17:
                return "primattrib";
            case 18:
                return "primattribcomp";
            case 19:
                return "primreverse";
            case 20:
                return "vertexprimorder";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_INTEGER;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_INTEGER;
                case 3:
                    return PARM_VECTOR3;
                case 4:
                    return PARM_STRING;
                case 5:
                    return PARM_VECTOR3;
                case 6:
                    return PARM_FLOAT;
                case 7:
                    return PARM_STRING;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_INTEGER;
                case 11:
                    return PARM_INTEGER;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_VECTOR3;
                case 14:
                    return PARM_STRING;
                case 15:
                    return PARM_VECTOR3;
                case 16:
                    return PARM_FLOAT;
                case 17:
                    return PARM_STRING;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_INTEGER;
                case 20:
                    return PARM_INTEGER;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myPtsort);
        saveData(os, myPointseed);
        saveData(os, myPointoffset);
        saveData(os, myPointprox);
        saveData(os, myPointobjpath);
        saveData(os, myPointdir);
        saveData(os, myPointexpr);
        saveData(os, myPointattrib);
        saveData(os, myPointattribcomp);
        saveData(os, myPointreverse);
        saveData(os, myPrimsort);
        saveData(os, myPrimseed);
        saveData(os, myPrimoffset);
        saveData(os, myPrimprox);
        saveData(os, myPrimobjpath);
        saveData(os, myPrimdir);
        saveData(os, myPrimexpr);
        saveData(os, myPrimattrib);
        saveData(os, myPrimattribcomp);
        saveData(os, myPrimreverse);
        saveData(os, myVertexPrimOrder);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myPtsort);
        loadData(is, myPointseed);
        loadData(is, myPointoffset);
        loadData(is, myPointprox);
        loadData(is, myPointobjpath);
        loadData(is, myPointdir);
        loadData(is, myPointexpr);
        loadData(is, myPointattrib);
        loadData(is, myPointattribcomp);
        loadData(is, myPointreverse);
        loadData(is, myPrimsort);
        loadData(is, myPrimseed);
        loadData(is, myPrimoffset);
        loadData(is, myPrimprox);
        loadData(is, myPrimobjpath);
        loadData(is, myPrimdir);
        loadData(is, myPrimexpr);
        loadData(is, myPrimattrib);
        loadData(is, myPrimattribcomp);
        loadData(is, myPrimreverse);
        loadData(is, myVertexPrimOrder);

        return true;
    }

    Ptsort getPtsort() const { return Ptsort(myPtsort); }
    void setPtsort(Ptsort val) { myPtsort = int64(val); }
    Ptsort opPtsort(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPtsort();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "ptsort", cookparms.getCookTime(), 0);
        return Ptsort(result);
    }
    int64 getPointseed() const { return myPointseed; }
    void setPointseed(int64 val) { myPointseed = val; }
    int64 opPointseed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointseed();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "pointseed", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getPointoffset() const { return myPointoffset; }
    void setPointoffset(int64 val) { myPointoffset = val; }
    int64 opPointoffset(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointoffset();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "pointoffset", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getPointprox() const { return myPointprox; }
    void setPointprox(UT_Vector3D val) { myPointprox = val; }
    UT_Vector3D opPointprox(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointprox();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "pointprox", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPointobjpath() const { return myPointobjpath; }
    void setPointobjpath(const UT_StringHolder & val) { myPointobjpath = val; }
    UT_StringHolder opPointobjpath(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointobjpath();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "pointobjpath", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getPointdir() const { return myPointdir; }
    void setPointdir(UT_Vector3D val) { myPointdir = val; }
    UT_Vector3D opPointdir(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointdir();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "pointdir", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getPointexpr() const { return myPointexpr; }
    void setPointexpr(fpreal64 val) { myPointexpr = val; }
    fpreal64 opPointexpr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointexpr();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "pointexpr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPointattrib() const { return myPointattrib; }
    void setPointattrib(const UT_StringHolder & val) { myPointattrib = val; }
    UT_StringHolder opPointattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "pointattrib", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getPointattribcomp() const { return myPointattribcomp; }
    void setPointattribcomp(int64 val) { myPointattribcomp = val; }
    int64 opPointattribcomp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointattribcomp();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "pointattribcomp", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPointreverse() const { return myPointreverse; }
    void setPointreverse(bool val) { myPointreverse = val; }
    bool opPointreverse(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPointreverse();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "pointreverse", cookparms.getCookTime(), 0);
        return result;
    }
    Primsort getPrimsort() const { return Primsort(myPrimsort); }
    void setPrimsort(Primsort val) { myPrimsort = int64(val); }
    Primsort opPrimsort(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimsort();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "primsort", cookparms.getCookTime(), 0);
        return Primsort(result);
    }
    int64 getPrimseed() const { return myPrimseed; }
    void setPrimseed(int64 val) { myPrimseed = val; }
    int64 opPrimseed(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimseed();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "primseed", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getPrimoffset() const { return myPrimoffset; }
    void setPrimoffset(int64 val) { myPrimoffset = val; }
    int64 opPrimoffset(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimoffset();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "primoffset", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getPrimprox() const { return myPrimprox; }
    void setPrimprox(UT_Vector3D val) { myPrimprox = val; }
    UT_Vector3D opPrimprox(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimprox();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "primprox", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPrimobjpath() const { return myPrimobjpath; }
    void setPrimobjpath(const UT_StringHolder & val) { myPrimobjpath = val; }
    UT_StringHolder opPrimobjpath(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimobjpath();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primobjpath", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector3D getPrimdir() const { return myPrimdir; }
    void setPrimdir(UT_Vector3D val) { myPrimdir = val; }
    UT_Vector3D opPrimdir(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimdir();
        UT_Vector3D result;
        OP_Utils::evalOpParm(result, thissop, "primdir", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getPrimexpr() const { return myPrimexpr; }
    void setPrimexpr(fpreal64 val) { myPrimexpr = val; }
    fpreal64 opPrimexpr(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimexpr();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "primexpr", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPrimattrib() const { return myPrimattrib; }
    void setPrimattrib(const UT_StringHolder & val) { myPrimattrib = val; }
    UT_StringHolder opPrimattrib(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimattrib();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primattrib", cookparms.getCookTime(), 0);
        return result;
    }
    int64 getPrimattribcomp() const { return myPrimattribcomp; }
    void setPrimattribcomp(int64 val) { myPrimattribcomp = val; }
    int64 opPrimattribcomp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimattribcomp();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "primattribcomp", cookparms.getCookTime(), 0);
        return result;
    }
    bool getPrimreverse() const { return myPrimreverse; }
    void setPrimreverse(bool val) { myPrimreverse = val; }
    bool opPrimreverse(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimreverse();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "primreverse", cookparms.getCookTime(), 0);
        return result;
    }
    bool getVertexPrimOrder() const { return myVertexPrimOrder; }
    void setVertexPrimOrder(bool val) { myVertexPrimOrder = val; }
    bool opVertexPrimOrder(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVertexPrimOrder();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "vertexprimorder", cookparms.getCookTime(), 0);
        return result;
    }

private:
    int64 myPtsort;
    int64 myPointseed;
    int64 myPointoffset;
    UT_Vector3D myPointprox;
    UT_StringHolder myPointobjpath;
    UT_Vector3D myPointdir;
    fpreal64 myPointexpr;
    UT_StringHolder myPointattrib;
    int64 myPointattribcomp;
    bool myPointreverse;
    int64 myPrimsort;
    int64 myPrimseed;
    int64 myPrimoffset;
    UT_Vector3D myPrimprox;
    UT_StringHolder myPrimobjpath;
    UT_Vector3D myPrimdir;
    fpreal64 myPrimexpr;
    UT_StringHolder myPrimattrib;
    int64 myPrimattribcomp;
    bool myPrimreverse;
    bool myVertexPrimOrder;

};
