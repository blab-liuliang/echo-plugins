/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_BooleanEnums
{
    enum class ASurface
    {
        SOLID = 0,
        SURFACE
    };
    enum class BSurface
    {
        SOLID = 0,
        SURFACE
    };
    enum class BooleanOp
    {
        UNION = 0,
        INTERSECT,
        SUBTRACT,
        SHATTER,
        CUSTOM,
        // -- menu separator --
        SEAM = 6,
        // -- menu separator --
        DETECT = 8,
        RESOLVE
    };
    enum class SubtractChoices
    {
        AMINUSB = 0,
        BMINUSA,
        BOTH
    };
    enum class ShatterChoices
    {
        APIECES = 0,
        BPIECES,
        BOTH
    };
    enum class WindingOp
    {
        ARANGE = 0,
        BRANGE,
        AND,
        OR,
        XOR
    };
    enum class Detriangulate
    {
        NONE = 0,
        UNCHANGED,
        ALL
    };
}


class SOP_API SOP_BooleanParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }

    SOP_BooleanParms()
    {
        myGroupA = ""_sh;
        myASurface = 0;
        myResolveA = true;
        myGroupB = ""_sh;
        myBSurface = 0;
        myResolveB = true;
        myBooleanOp = 0;
        mySubtractChoices = 0;
        myShatterChoices = 0;
        myOpenCurvesOnly = true;
        myGenerateAASeams = true;
        myGenerateBBSeams = true;
        myGenerateABSeams = true;
        myWindingOp = 0;
        myMergeNbrs = false;
        myDetriangulate = 2;
        myRemoveInlinePoints = true;
        myUniqueSeams = false;
        myUseAxAPolys = false;
        myAxAPolys = "axapolys"_sh;
        myUseAxBPolys = false;
        myAxBPolys = "axbpolys"_sh;
        myUseAxAList = false;
        myAxAList = "axalist"_sh;
        myUseAxBList = false;
        myAxBList = "axblist"_sh;
        myCollapseTinyEdges = true;
        myLengthThreshold = 0.00001;
        myUseAPolys = false;
        myAPolys = "apolys"_sh;
        myUseAInsideB = false;
        myAInsideB = "ainsideb"_sh;
        myUseAOutsideB = false;
        myAOutsideB = "aoutsideb"_sh;
        myUseBPolys = false;
        myBPolys = "bpolys"_sh;
        myUseBInsideA = false;
        myBInsideA = "binsidea"_sh;
        myUseBOutsideA = false;
        myBOutsideA = "boutsidea"_sh;
        myUseABOverlap = false;
        myABOverlap = "aboverlap"_sh;
        myUseAPieces = false;
        myAPieces = "apieces"_sh;
        myUseBPieces = false;
        myBPieces = "bpieces"_sh;
        myUseABPieces = false;
        myABPieces = "abpieces"_sh;
        myUseAASeamEdges = false;
        myAASeamEdges = "aseams"_sh;
        myUseBBSeamEdges = false;
        myBBSeamEdges = "bseams"_sh;
        myUseABSeamEdges = false;
        myABSeamEdges = "abseams"_sh;
        myDepthInA = UT_Vector2I(1,1000);
        myDepthInB = UT_Vector2I(1,1000);

    }

    explicit SOP_BooleanParms(const SOP_BooleanParms &) = default;

    virtual ~SOP_BooleanParms() {}

    bool operator==(const SOP_BooleanParms &src) const
    {
        if (myGroupA != src.myGroupA) return false;
        if (myASurface != src.myASurface) return false;
        if (myResolveA != src.myResolveA) return false;
        if (myGroupB != src.myGroupB) return false;
        if (myBSurface != src.myBSurface) return false;
        if (myResolveB != src.myResolveB) return false;
        if (myBooleanOp != src.myBooleanOp) return false;
        if (mySubtractChoices != src.mySubtractChoices) return false;
        if (myShatterChoices != src.myShatterChoices) return false;
        if (myOpenCurvesOnly != src.myOpenCurvesOnly) return false;
        if (myGenerateAASeams != src.myGenerateAASeams) return false;
        if (myGenerateBBSeams != src.myGenerateBBSeams) return false;
        if (myGenerateABSeams != src.myGenerateABSeams) return false;
        if (myWindingOp != src.myWindingOp) return false;
        if (myMergeNbrs != src.myMergeNbrs) return false;
        if (myDetriangulate != src.myDetriangulate) return false;
        if (myRemoveInlinePoints != src.myRemoveInlinePoints) return false;
        if (myUniqueSeams != src.myUniqueSeams) return false;
        if (myUseAxAPolys != src.myUseAxAPolys) return false;
        if (myAxAPolys != src.myAxAPolys) return false;
        if (myUseAxBPolys != src.myUseAxBPolys) return false;
        if (myAxBPolys != src.myAxBPolys) return false;
        if (myUseAxAList != src.myUseAxAList) return false;
        if (myAxAList != src.myAxAList) return false;
        if (myUseAxBList != src.myUseAxBList) return false;
        if (myAxBList != src.myAxBList) return false;
        if (myCollapseTinyEdges != src.myCollapseTinyEdges) return false;
        if (myLengthThreshold != src.myLengthThreshold) return false;
        if (myUseAPolys != src.myUseAPolys) return false;
        if (myAPolys != src.myAPolys) return false;
        if (myUseAInsideB != src.myUseAInsideB) return false;
        if (myAInsideB != src.myAInsideB) return false;
        if (myUseAOutsideB != src.myUseAOutsideB) return false;
        if (myAOutsideB != src.myAOutsideB) return false;
        if (myUseBPolys != src.myUseBPolys) return false;
        if (myBPolys != src.myBPolys) return false;
        if (myUseBInsideA != src.myUseBInsideA) return false;
        if (myBInsideA != src.myBInsideA) return false;
        if (myUseBOutsideA != src.myUseBOutsideA) return false;
        if (myBOutsideA != src.myBOutsideA) return false;
        if (myUseABOverlap != src.myUseABOverlap) return false;
        if (myABOverlap != src.myABOverlap) return false;
        if (myUseAPieces != src.myUseAPieces) return false;
        if (myAPieces != src.myAPieces) return false;
        if (myUseBPieces != src.myUseBPieces) return false;
        if (myBPieces != src.myBPieces) return false;
        if (myUseABPieces != src.myUseABPieces) return false;
        if (myABPieces != src.myABPieces) return false;
        if (myUseAASeamEdges != src.myUseAASeamEdges) return false;
        if (myAASeamEdges != src.myAASeamEdges) return false;
        if (myUseBBSeamEdges != src.myUseBBSeamEdges) return false;
        if (myBBSeamEdges != src.myBBSeamEdges) return false;
        if (myUseABSeamEdges != src.myUseABSeamEdges) return false;
        if (myABSeamEdges != src.myABSeamEdges) return false;
        if (myDepthInA != src.myDepthInA) return false;
        if (myDepthInB != src.myDepthInB) return false;

        return true;
    }
    bool operator!=(const SOP_BooleanParms &src) const
    {
        return !operator==(src);
    }
    using ASurface = SOP_BooleanEnums::ASurface;
    using BSurface = SOP_BooleanEnums::BSurface;
    using BooleanOp = SOP_BooleanEnums::BooleanOp;
    using SubtractChoices = SOP_BooleanEnums::SubtractChoices;
    using ShatterChoices = SOP_BooleanEnums::ShatterChoices;
    using WindingOp = SOP_BooleanEnums::WindingOp;
    using Detriangulate = SOP_BooleanEnums::Detriangulate;



    void        buildFromOp(const OP_Node *node, fpreal time, DEP_MicroNode *depnode)
    {
        if (true)
            OP_Utils::evalOpParm(myGroupA, node, "agroup", time, 0);
        else myGroupA = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myASurface, node, "asurface", time, 0);
        else myASurface = 0;
        if (true)
            OP_Utils::evalOpParm(myResolveA, node, "resolvea", time, 0);
        else myResolveA = true;
        if (true)
            OP_Utils::evalOpParm(myGroupB, node, "bgroup", time, 0);
        else myGroupB = ""_sh;
        if (true)
            OP_Utils::evalOpParm(myBSurface, node, "bsurface", time, 0);
        else myBSurface = 0;
        if (true)
            OP_Utils::evalOpParm(myResolveB, node, "resolveb", time, 0);
        else myResolveB = true;
        if (true)
            OP_Utils::evalOpParm(myBooleanOp, node, "booleanop", time, 0);
        else myBooleanOp = 0;
        if (true && ( (!(((int64(getBooleanOp())!=2)))) ) )
            OP_Utils::evalOpParm(mySubtractChoices, node, "subtractchoices", time, 0);
        else mySubtractChoices = 0;
        if (true && ( (!(((int64(getBooleanOp())!=3)))) ) )
            OP_Utils::evalOpParm(myShatterChoices, node, "shatterchoices", time, 0);
        else myShatterChoices = 0;
        if (true && ( (!(((int64(getBooleanOp())!=6)))) ) )
            OP_Utils::evalOpParm(myOpenCurvesOnly, node, "opencurvesonly", time, 0);
        else myOpenCurvesOnly = true;
        if (true && ( (!(((int64(getBooleanOp())!=6)))) ) )
            OP_Utils::evalOpParm(myGenerateAASeams, node, "generateaaseams", time, 0);
        else myGenerateAASeams = true;
        if (true && ( (!(((int64(getBooleanOp())!=6)))) ) )
            OP_Utils::evalOpParm(myGenerateBBSeams, node, "generatebbseams", time, 0);
        else myGenerateBBSeams = true;
        if (true && ( (!(((int64(getBooleanOp())!=6)))) ) )
            OP_Utils::evalOpParm(myGenerateABSeams, node, "generateabseams", time, 0);
        else myGenerateABSeams = true;
        if (true && ( (!(((int64(getBooleanOp())!=4)))) ) )
            OP_Utils::evalOpParm(myWindingOp, node, "windingop", time, 0);
        else myWindingOp = 0;
        if (true && ( (!(((int64(getBooleanOp())!=4)))) ) )
            OP_Utils::evalOpParm(myMergeNbrs, node, "mergenbrs", time, 0);
        else myMergeNbrs = false;
        if (true && ( (!(((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myDetriangulate, node, "detriangulate", time, 0);
        else myDetriangulate = 2;
        if (true && ( (!(((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9))||((int64(getDetriangulate())!=2)))) ) )
            OP_Utils::evalOpParm(myRemoveInlinePoints, node, "removeinlinepoints", time, 0);
        else myRemoveInlinePoints = true;
        if (true && ( (!(((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myUniqueSeams, node, "uniqueseams", time, 0);
        else myUniqueSeams = false;
        if (true && ( (!(((int64(getBooleanOp())!=8)))) ) )
            OP_Utils::evalOpParm(myUseAxAPolys, node, "useaxapolys", time, 0);
        else myUseAxAPolys = false;
        if (true && ( (!(((getUseAxAPolys()==0))||((int64(getBooleanOp())!=8)))) ) )
            OP_Utils::evalOpParm(myAxAPolys, node, "axapolys", time, 0);
        else myAxAPolys = "axapolys"_sh;
        if (true && ( (!(((int64(getBooleanOp())!=8)))) ) )
            OP_Utils::evalOpParm(myUseAxBPolys, node, "useaxbpolys", time, 0);
        else myUseAxBPolys = false;
        if (true && ( (!(((getUseAxBPolys()==0))||((int64(getBooleanOp())!=8)))) ) )
            OP_Utils::evalOpParm(myAxBPolys, node, "axbpolys", time, 0);
        else myAxBPolys = "axbpolys"_sh;
        if (true && ( (!(((int64(getBooleanOp())!=8)))) ) )
            OP_Utils::evalOpParm(myUseAxAList, node, "useaxalist", time, 0);
        else myUseAxAList = false;
        if (true && ( (!(((getUseAxAList()==0))||((int64(getBooleanOp())!=8)))) ) )
            OP_Utils::evalOpParm(myAxAList, node, "axalist", time, 0);
        else myAxAList = "axalist"_sh;
        if (true && ( (!(((int64(getBooleanOp())!=8)))) ) )
            OP_Utils::evalOpParm(myUseAxBList, node, "useaxblist", time, 0);
        else myUseAxBList = false;
        if (true && ( (!(((getUseAxBList()==0))||((int64(getBooleanOp())!=8)))) ) )
            OP_Utils::evalOpParm(myAxBList, node, "axblist", time, 0);
        else myAxBList = "axblist"_sh;
        if (true && ( (!(((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9))||((int64(getBooleanOp())==6)))) ) )
            OP_Utils::evalOpParm(myCollapseTinyEdges, node, "collapsetinyedges", time, 0);
        else myCollapseTinyEdges = true;
        if (true && ( (!(((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9))||((int64(getBooleanOp())==6))||((getCollapseTinyEdges()==0)))) ) )
            OP_Utils::evalOpParm(myLengthThreshold, node, "lengththreshold", time, 0);
        else myLengthThreshold = 0.00001;
        if (true && ( (!(((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9))||((int64(getBSurface())==0)))) ) )
            OP_Utils::evalOpParm(myUseAPolys, node, "useapolys", time, 0);
        else myUseAPolys = false;
        if (true && ( (!(((int64(getBSurface())==0))||((getUseAPolys()==0)))) ) )
            OP_Utils::evalOpParm(myAPolys, node, "apolys", time, 0);
        else myAPolys = "apolys"_sh;
        if (true && ( (!(((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9))||((int64(getBSurface())==1)))) ) )
            OP_Utils::evalOpParm(myUseAInsideB, node, "useainsideb", time, 0);
        else myUseAInsideB = false;
        if (true && ( (!(((int64(getBSurface())==1))||((getUseAInsideB()==0)))) ) )
            OP_Utils::evalOpParm(myAInsideB, node, "ainsideb", time, 0);
        else myAInsideB = "ainsideb"_sh;
        if (true && ( (!(((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9))||((int64(getBSurface())==1)))) ) )
            OP_Utils::evalOpParm(myUseAOutsideB, node, "useaoutsideb", time, 0);
        else myUseAOutsideB = false;
        if (true && ( (!(((int64(getBSurface())==1))||((getUseAOutsideB()==0)))) ) )
            OP_Utils::evalOpParm(myAOutsideB, node, "aoutsideb", time, 0);
        else myAOutsideB = "aoutsideb"_sh;
        if (true && ( (!(((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9))||((int64(getASurface())==0)))) ) )
            OP_Utils::evalOpParm(myUseBPolys, node, "usebpolys", time, 0);
        else myUseBPolys = false;
        if (true && ( (!(((getUseBPolys()==0))||((int64(getASurface())==0)))) ) )
            OP_Utils::evalOpParm(myBPolys, node, "bpolys", time, 0);
        else myBPolys = "bpolys"_sh;
        if (true && ( (!(((int64(getASurface())==1))||((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myUseBInsideA, node, "usebinsidea", time, 0);
        else myUseBInsideA = false;
        if (true && ( (!(((int64(getASurface())==1))||((getUseBInsideA()==0)))) ) )
            OP_Utils::evalOpParm(myBInsideA, node, "binsidea", time, 0);
        else myBInsideA = "binsidea"_sh;
        if (true && ( (!(((int64(getASurface())==1))||((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myUseBOutsideA, node, "useboutsidea", time, 0);
        else myUseBOutsideA = false;
        if (true && ( (!(((int64(getASurface())==1))||((getUseBOutsideA()==0)))) ) )
            OP_Utils::evalOpParm(myBOutsideA, node, "boutsidea", time, 0);
        else myBOutsideA = "boutsidea"_sh;
        if (true && ( (!(((int64(getBooleanOp())==6))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myUseABOverlap, node, "useaboverlap", time, 0);
        else myUseABOverlap = false;
        if (true && ( (!(((getUseABOverlap()==0)))) ) )
            OP_Utils::evalOpParm(myABOverlap, node, "aboverlap", time, 0);
        else myABOverlap = "aboverlap"_sh;
        if (true && ( (!(((int64(getASurface())==1))||((int64(getBooleanOp())!=2)&&(int64(getBooleanOp())!=3))||((int64(getBooleanOp())==2)&&(int64(getSubtractChoices())!=2))||((int64(getBooleanOp())==3)&&(int64(getShatterChoices())==1)))) ) )
            OP_Utils::evalOpParm(myUseAPieces, node, "useaonlypieces", time, 0);
        else myUseAPieces = false;
        if (true && ( (!(((int64(getASurface())==1))||((int64(getBooleanOp())!=2)&&(int64(getBooleanOp())!=3))||((int64(getBooleanOp())==2)&&(int64(getSubtractChoices())!=2))||((int64(getBooleanOp())==3)&&(int64(getShatterChoices())==1))||((getUseAPieces()==0)))) ) )
            OP_Utils::evalOpParm(myAPieces, node, "aonlypieces", time, 0);
        else myAPieces = "apieces"_sh;
        if (true && ( (!(((int64(getBSurface())==1))||((int64(getBooleanOp())!=2)&&(int64(getBooleanOp())!=3))||((int64(getBooleanOp())==2)&&(int64(getSubtractChoices())!=2))||((int64(getBooleanOp())==3)&&(int64(getShatterChoices())==0)))) ) )
            OP_Utils::evalOpParm(myUseBPieces, node, "usebonlypieces", time, 0);
        else myUseBPieces = false;
        if (true && ( (!(((int64(getBSurface())==1))||((int64(getBooleanOp())!=2)&&(int64(getBooleanOp())!=3))||((int64(getBooleanOp())==2)&&(int64(getSubtractChoices())!=2))||((int64(getBooleanOp())==3)&&(int64(getShatterChoices())==0))||((getUseBPieces()==0)))) ) )
            OP_Utils::evalOpParm(myBPieces, node, "bonlypieces", time, 0);
        else myBPieces = "bpieces"_sh;
        if (true && ( (!(((int64(getBSurface())==1)&&(int64(getASurface())==1))||((int64(getBooleanOp())!=3)))) ) )
            OP_Utils::evalOpParm(myUseABPieces, node, "useabpieces", time, 0);
        else myUseABPieces = false;
        if (true && ( (!(((int64(getBSurface())==1)&&(int64(getASurface())==1))||((int64(getBooleanOp())!=3))||((getUseABPieces()==0)))) ) )
            OP_Utils::evalOpParm(myABPieces, node, "abpieces", time, 0);
        else myABPieces = "abpieces"_sh;
        if (true && ( (!(((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myUseAASeamEdges, node, "useaaseamedges", time, 0);
        else myUseAASeamEdges = false;
        if (true && ( (!(((getUseAASeamEdges()==0))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myAASeamEdges, node, "aaseamedges", time, 0);
        else myAASeamEdges = "aseams"_sh;
        if (true && ( (!(((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myUseBBSeamEdges, node, "usebbseamedges", time, 0);
        else myUseBBSeamEdges = false;
        if (true && ( (!(((getUseBBSeamEdges()==0))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myBBSeamEdges, node, "bbseamedges", time, 0);
        else myBBSeamEdges = "bseams"_sh;
        if (true && ( (!(((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myUseABSeamEdges, node, "useabseamedges", time, 0);
        else myUseABSeamEdges = false;
        if (true && ( (!(((getUseABSeamEdges()==0))||((int64(getBooleanOp())==8))||((int64(getBooleanOp())==9)))) ) )
            OP_Utils::evalOpParm(myABSeamEdges, node, "abseamedges", time, 0);
        else myABSeamEdges = "abseams"_sh;
        if (true && ( (!(((int64(getBooleanOp())!=4))||((int64(getWindingOp())==1)))) ) )
            OP_Utils::evalOpParm(myDepthInA, node, "adepth", time, 0);
        else myDepthInA = UT_Vector2I(1,1000);
        if (true && ( (!(((int64(getBooleanOp())!=4))||((int64(getWindingOp())==0)))) ) )
            OP_Utils::evalOpParm(myDepthInB, node, "bdepth", time, 0);
        else myDepthInB = UT_Vector2I(1,1000);

    }


    virtual void loadFromOpSubclass(const LoadParms &loadparms)
    {
        buildFromOp(loadparms.node(), loadparms.context().getTime(), loadparms.depnode());
    }


    virtual void copyFrom(const SOP_NodeParms *src)
    {
        *this = *((const SOP_BooleanParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(exint idx, T &value) const
    {
        switch (idx)
        {
            case 0:
                coerceValue(value, myGroupA);
                break;
            case 1:
                coerceValue(value, myASurface);
                break;
            case 2:
                coerceValue(value, myResolveA);
                break;
            case 3:
                coerceValue(value, myGroupB);
                break;
            case 4:
                coerceValue(value, myBSurface);
                break;
            case 5:
                coerceValue(value, myResolveB);
                break;
            case 6:
                coerceValue(value, myBooleanOp);
                break;
            case 7:
                coerceValue(value, mySubtractChoices);
                break;
            case 8:
                coerceValue(value, myShatterChoices);
                break;
            case 9:
                coerceValue(value, myOpenCurvesOnly);
                break;
            case 10:
                coerceValue(value, myGenerateAASeams);
                break;
            case 11:
                coerceValue(value, myGenerateBBSeams);
                break;
            case 12:
                coerceValue(value, myGenerateABSeams);
                break;
            case 13:
                coerceValue(value, myWindingOp);
                break;
            case 14:
                coerceValue(value, myMergeNbrs);
                break;
            case 15:
                coerceValue(value, myDetriangulate);
                break;
            case 16:
                coerceValue(value, myRemoveInlinePoints);
                break;
            case 17:
                coerceValue(value, myUniqueSeams);
                break;
            case 18:
                coerceValue(value, myUseAxAPolys);
                break;
            case 19:
                coerceValue(value, myAxAPolys);
                break;
            case 20:
                coerceValue(value, myUseAxBPolys);
                break;
            case 21:
                coerceValue(value, myAxBPolys);
                break;
            case 22:
                coerceValue(value, myUseAxAList);
                break;
            case 23:
                coerceValue(value, myAxAList);
                break;
            case 24:
                coerceValue(value, myUseAxBList);
                break;
            case 25:
                coerceValue(value, myAxBList);
                break;
            case 26:
                coerceValue(value, myCollapseTinyEdges);
                break;
            case 27:
                coerceValue(value, myLengthThreshold);
                break;
            case 28:
                coerceValue(value, myUseAPolys);
                break;
            case 29:
                coerceValue(value, myAPolys);
                break;
            case 30:
                coerceValue(value, myUseAInsideB);
                break;
            case 31:
                coerceValue(value, myAInsideB);
                break;
            case 32:
                coerceValue(value, myUseAOutsideB);
                break;
            case 33:
                coerceValue(value, myAOutsideB);
                break;
            case 34:
                coerceValue(value, myUseBPolys);
                break;
            case 35:
                coerceValue(value, myBPolys);
                break;
            case 36:
                coerceValue(value, myUseBInsideA);
                break;
            case 37:
                coerceValue(value, myBInsideA);
                break;
            case 38:
                coerceValue(value, myUseBOutsideA);
                break;
            case 39:
                coerceValue(value, myBOutsideA);
                break;
            case 40:
                coerceValue(value, myUseABOverlap);
                break;
            case 41:
                coerceValue(value, myABOverlap);
                break;
            case 42:
                coerceValue(value, myUseAPieces);
                break;
            case 43:
                coerceValue(value, myAPieces);
                break;
            case 44:
                coerceValue(value, myUseBPieces);
                break;
            case 45:
                coerceValue(value, myBPieces);
                break;
            case 46:
                coerceValue(value, myUseABPieces);
                break;
            case 47:
                coerceValue(value, myABPieces);
                break;
            case 48:
                coerceValue(value, myUseAASeamEdges);
                break;
            case 49:
                coerceValue(value, myAASeamEdges);
                break;
            case 50:
                coerceValue(value, myUseBBSeamEdges);
                break;
            case 51:
                coerceValue(value, myBBSeamEdges);
                break;
            case 52:
                coerceValue(value, myUseABSeamEdges);
                break;
            case 53:
                coerceValue(value, myABSeamEdges);
                break;
            case 54:
                coerceValue(value, myDepthInA);
                break;
            case 55:
                coerceValue(value, myDepthInB);
                break;

        }
    }

    void        getParmValue(exint idx, exint &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, fpreal &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Vector4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix2D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix3D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_Matrix4D &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_StringHolder &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, UT_SharedPtr<UT_Ramp> &value) const
    { doGetParmValue(idx, value); }
    void        getParmValue(exint idx, PRM_DataItemHandle &value) const
    { doGetParmValue(idx, value); }

    template <typename T>
    void
    doSetParmValue(exint idx, const T &value) 
    {
        switch (idx)
        {
            case 0:
                coerceValue(myGroupA, value);
                break;
            case 1:
                coerceValue(myASurface, value);
                break;
            case 2:
                coerceValue(myResolveA, value);
                break;
            case 3:
                coerceValue(myGroupB, value);
                break;
            case 4:
                coerceValue(myBSurface, value);
                break;
            case 5:
                coerceValue(myResolveB, value);
                break;
            case 6:
                coerceValue(myBooleanOp, value);
                break;
            case 7:
                coerceValue(mySubtractChoices, value);
                break;
            case 8:
                coerceValue(myShatterChoices, value);
                break;
            case 9:
                coerceValue(myOpenCurvesOnly, value);
                break;
            case 10:
                coerceValue(myGenerateAASeams, value);
                break;
            case 11:
                coerceValue(myGenerateBBSeams, value);
                break;
            case 12:
                coerceValue(myGenerateABSeams, value);
                break;
            case 13:
                coerceValue(myWindingOp, value);
                break;
            case 14:
                coerceValue(myMergeNbrs, value);
                break;
            case 15:
                coerceValue(myDetriangulate, value);
                break;
            case 16:
                coerceValue(myRemoveInlinePoints, value);
                break;
            case 17:
                coerceValue(myUniqueSeams, value);
                break;
            case 18:
                coerceValue(myUseAxAPolys, value);
                break;
            case 19:
                coerceValue(myAxAPolys, value);
                break;
            case 20:
                coerceValue(myUseAxBPolys, value);
                break;
            case 21:
                coerceValue(myAxBPolys, value);
                break;
            case 22:
                coerceValue(myUseAxAList, value);
                break;
            case 23:
                coerceValue(myAxAList, value);
                break;
            case 24:
                coerceValue(myUseAxBList, value);
                break;
            case 25:
                coerceValue(myAxBList, value);
                break;
            case 26:
                coerceValue(myCollapseTinyEdges, value);
                break;
            case 27:
                coerceValue(myLengthThreshold, value);
                break;
            case 28:
                coerceValue(myUseAPolys, value);
                break;
            case 29:
                coerceValue(myAPolys, value);
                break;
            case 30:
                coerceValue(myUseAInsideB, value);
                break;
            case 31:
                coerceValue(myAInsideB, value);
                break;
            case 32:
                coerceValue(myUseAOutsideB, value);
                break;
            case 33:
                coerceValue(myAOutsideB, value);
                break;
            case 34:
                coerceValue(myUseBPolys, value);
                break;
            case 35:
                coerceValue(myBPolys, value);
                break;
            case 36:
                coerceValue(myUseBInsideA, value);
                break;
            case 37:
                coerceValue(myBInsideA, value);
                break;
            case 38:
                coerceValue(myUseBOutsideA, value);
                break;
            case 39:
                coerceValue(myBOutsideA, value);
                break;
            case 40:
                coerceValue(myUseABOverlap, value);
                break;
            case 41:
                coerceValue(myABOverlap, value);
                break;
            case 42:
                coerceValue(myUseAPieces, value);
                break;
            case 43:
                coerceValue(myAPieces, value);
                break;
            case 44:
                coerceValue(myUseBPieces, value);
                break;
            case 45:
                coerceValue(myBPieces, value);
                break;
            case 46:
                coerceValue(myUseABPieces, value);
                break;
            case 47:
                coerceValue(myABPieces, value);
                break;
            case 48:
                coerceValue(myUseAASeamEdges, value);
                break;
            case 49:
                coerceValue(myAASeamEdges, value);
                break;
            case 50:
                coerceValue(myUseBBSeamEdges, value);
                break;
            case 51:
                coerceValue(myBBSeamEdges, value);
                break;
            case 52:
                coerceValue(myUseABSeamEdges, value);
                break;
            case 53:
                coerceValue(myABSeamEdges, value);
                break;
            case 54:
                coerceValue(myDepthInA, value);
                break;
            case 55:
                coerceValue(myDepthInB, value);
                break;

        }
    }

    void        setParmValue(exint idx, const exint &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const fpreal &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Vector4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix2D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix3D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_Matrix4D &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_StringHolder &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const UT_SharedPtr<UT_Ramp> &value) 
    { doSetParmValue(idx, value); }
    void        setParmValue(exint idx, const PRM_DataItemHandle &value) 
    { doSetParmValue(idx, value); }

    virtual exint    getNumParms() const
    {
        return 56;
    }

    virtual const char *getParmName(exint fieldnum) const
    {
        switch (fieldnum)
        {
            case 0:
                return "agroup";
            case 1:
                return "asurface";
            case 2:
                return "resolvea";
            case 3:
                return "bgroup";
            case 4:
                return "bsurface";
            case 5:
                return "resolveb";
            case 6:
                return "booleanop";
            case 7:
                return "subtractchoices";
            case 8:
                return "shatterchoices";
            case 9:
                return "opencurvesonly";
            case 10:
                return "generateaaseams";
            case 11:
                return "generatebbseams";
            case 12:
                return "generateabseams";
            case 13:
                return "windingop";
            case 14:
                return "mergenbrs";
            case 15:
                return "detriangulate";
            case 16:
                return "removeinlinepoints";
            case 17:
                return "uniqueseams";
            case 18:
                return "useaxapolys";
            case 19:
                return "axapolys";
            case 20:
                return "useaxbpolys";
            case 21:
                return "axbpolys";
            case 22:
                return "useaxalist";
            case 23:
                return "axalist";
            case 24:
                return "useaxblist";
            case 25:
                return "axblist";
            case 26:
                return "collapsetinyedges";
            case 27:
                return "lengththreshold";
            case 28:
                return "useapolys";
            case 29:
                return "apolys";
            case 30:
                return "useainsideb";
            case 31:
                return "ainsideb";
            case 32:
                return "useaoutsideb";
            case 33:
                return "aoutsideb";
            case 34:
                return "usebpolys";
            case 35:
                return "bpolys";
            case 36:
                return "usebinsidea";
            case 37:
                return "binsidea";
            case 38:
                return "useboutsidea";
            case 39:
                return "boutsidea";
            case 40:
                return "useaboverlap";
            case 41:
                return "aboverlap";
            case 42:
                return "useaonlypieces";
            case 43:
                return "aonlypieces";
            case 44:
                return "usebonlypieces";
            case 45:
                return "bonlypieces";
            case 46:
                return "useabpieces";
            case 47:
                return "abpieces";
            case 48:
                return "useaaseamedges";
            case 49:
                return "aaseamedges";
            case 50:
                return "usebbseamedges";
            case 51:
                return "bbseamedges";
            case 52:
                return "useabseamedges";
            case 53:
                return "abseamedges";
            case 54:
                return "adepth";
            case 55:
                return "bdepth";

        }
        return 0;
    }

    virtual ParmType getParmType(exint fieldnum) const
    {
        switch (fieldnum)
        {
                case 0:
                    return PARM_STRING;
                case 1:
                    return PARM_INTEGER;
                case 2:
                    return PARM_INTEGER;
                case 3:
                    return PARM_STRING;
                case 4:
                    return PARM_INTEGER;
                case 5:
                    return PARM_INTEGER;
                case 6:
                    return PARM_INTEGER;
                case 7:
                    return PARM_INTEGER;
                case 8:
                    return PARM_INTEGER;
                case 9:
                    return PARM_INTEGER;
                case 10:
                    return PARM_INTEGER;
                case 11:
                    return PARM_INTEGER;
                case 12:
                    return PARM_INTEGER;
                case 13:
                    return PARM_INTEGER;
                case 14:
                    return PARM_INTEGER;
                case 15:
                    return PARM_INTEGER;
                case 16:
                    return PARM_INTEGER;
                case 17:
                    return PARM_INTEGER;
                case 18:
                    return PARM_INTEGER;
                case 19:
                    return PARM_STRING;
                case 20:
                    return PARM_INTEGER;
                case 21:
                    return PARM_STRING;
                case 22:
                    return PARM_INTEGER;
                case 23:
                    return PARM_STRING;
                case 24:
                    return PARM_INTEGER;
                case 25:
                    return PARM_STRING;
                case 26:
                    return PARM_INTEGER;
                case 27:
                    return PARM_FLOAT;
                case 28:
                    return PARM_INTEGER;
                case 29:
                    return PARM_STRING;
                case 30:
                    return PARM_INTEGER;
                case 31:
                    return PARM_STRING;
                case 32:
                    return PARM_INTEGER;
                case 33:
                    return PARM_STRING;
                case 34:
                    return PARM_INTEGER;
                case 35:
                    return PARM_STRING;
                case 36:
                    return PARM_INTEGER;
                case 37:
                    return PARM_STRING;
                case 38:
                    return PARM_INTEGER;
                case 39:
                    return PARM_STRING;
                case 40:
                    return PARM_INTEGER;
                case 41:
                    return PARM_STRING;
                case 42:
                    return PARM_INTEGER;
                case 43:
                    return PARM_STRING;
                case 44:
                    return PARM_INTEGER;
                case 45:
                    return PARM_STRING;
                case 46:
                    return PARM_INTEGER;
                case 47:
                    return PARM_STRING;
                case 48:
                    return PARM_INTEGER;
                case 49:
                    return PARM_STRING;
                case 50:
                    return PARM_INTEGER;
                case 51:
                    return PARM_STRING;
                case 52:
                    return PARM_INTEGER;
                case 53:
                    return PARM_STRING;
                case 54:
                    return PARM_VECTOR2;
                case 55:
                    return PARM_VECTOR2;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myGroupA);
        saveData(os, myASurface);
        saveData(os, myResolveA);
        saveData(os, myGroupB);
        saveData(os, myBSurface);
        saveData(os, myResolveB);
        saveData(os, myBooleanOp);
        saveData(os, mySubtractChoices);
        saveData(os, myShatterChoices);
        saveData(os, myOpenCurvesOnly);
        saveData(os, myGenerateAASeams);
        saveData(os, myGenerateBBSeams);
        saveData(os, myGenerateABSeams);
        saveData(os, myWindingOp);
        saveData(os, myMergeNbrs);
        saveData(os, myDetriangulate);
        saveData(os, myRemoveInlinePoints);
        saveData(os, myUniqueSeams);
        saveData(os, myUseAxAPolys);
        saveData(os, myAxAPolys);
        saveData(os, myUseAxBPolys);
        saveData(os, myAxBPolys);
        saveData(os, myUseAxAList);
        saveData(os, myAxAList);
        saveData(os, myUseAxBList);
        saveData(os, myAxBList);
        saveData(os, myCollapseTinyEdges);
        saveData(os, myLengthThreshold);
        saveData(os, myUseAPolys);
        saveData(os, myAPolys);
        saveData(os, myUseAInsideB);
        saveData(os, myAInsideB);
        saveData(os, myUseAOutsideB);
        saveData(os, myAOutsideB);
        saveData(os, myUseBPolys);
        saveData(os, myBPolys);
        saveData(os, myUseBInsideA);
        saveData(os, myBInsideA);
        saveData(os, myUseBOutsideA);
        saveData(os, myBOutsideA);
        saveData(os, myUseABOverlap);
        saveData(os, myABOverlap);
        saveData(os, myUseAPieces);
        saveData(os, myAPieces);
        saveData(os, myUseBPieces);
        saveData(os, myBPieces);
        saveData(os, myUseABPieces);
        saveData(os, myABPieces);
        saveData(os, myUseAASeamEdges);
        saveData(os, myAASeamEdges);
        saveData(os, myUseBBSeamEdges);
        saveData(os, myBBSeamEdges);
        saveData(os, myUseABSeamEdges);
        saveData(os, myABSeamEdges);
        saveData(os, myDepthInA);
        saveData(os, myDepthInB);

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myGroupA);
        loadData(is, myASurface);
        loadData(is, myResolveA);
        loadData(is, myGroupB);
        loadData(is, myBSurface);
        loadData(is, myResolveB);
        loadData(is, myBooleanOp);
        loadData(is, mySubtractChoices);
        loadData(is, myShatterChoices);
        loadData(is, myOpenCurvesOnly);
        loadData(is, myGenerateAASeams);
        loadData(is, myGenerateBBSeams);
        loadData(is, myGenerateABSeams);
        loadData(is, myWindingOp);
        loadData(is, myMergeNbrs);
        loadData(is, myDetriangulate);
        loadData(is, myRemoveInlinePoints);
        loadData(is, myUniqueSeams);
        loadData(is, myUseAxAPolys);
        loadData(is, myAxAPolys);
        loadData(is, myUseAxBPolys);
        loadData(is, myAxBPolys);
        loadData(is, myUseAxAList);
        loadData(is, myAxAList);
        loadData(is, myUseAxBList);
        loadData(is, myAxBList);
        loadData(is, myCollapseTinyEdges);
        loadData(is, myLengthThreshold);
        loadData(is, myUseAPolys);
        loadData(is, myAPolys);
        loadData(is, myUseAInsideB);
        loadData(is, myAInsideB);
        loadData(is, myUseAOutsideB);
        loadData(is, myAOutsideB);
        loadData(is, myUseBPolys);
        loadData(is, myBPolys);
        loadData(is, myUseBInsideA);
        loadData(is, myBInsideA);
        loadData(is, myUseBOutsideA);
        loadData(is, myBOutsideA);
        loadData(is, myUseABOverlap);
        loadData(is, myABOverlap);
        loadData(is, myUseAPieces);
        loadData(is, myAPieces);
        loadData(is, myUseBPieces);
        loadData(is, myBPieces);
        loadData(is, myUseABPieces);
        loadData(is, myABPieces);
        loadData(is, myUseAASeamEdges);
        loadData(is, myAASeamEdges);
        loadData(is, myUseBBSeamEdges);
        loadData(is, myBBSeamEdges);
        loadData(is, myUseABSeamEdges);
        loadData(is, myABSeamEdges);
        loadData(is, myDepthInA);
        loadData(is, myDepthInB);

        return true;
    }

    const UT_StringHolder & getGroupA() const { return myGroupA; }
    void setGroupA(const UT_StringHolder & val) { myGroupA = val; }
    UT_StringHolder opGroupA(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroupA();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "agroup", cookparms.getCookTime(), 0);
        return result;
    }
    ASurface getASurface() const { return ASurface(myASurface); }
    void setASurface(ASurface val) { myASurface = int64(val); }
    ASurface opASurface(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getASurface();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "asurface", cookparms.getCookTime(), 0);
        return ASurface(result);
    }
    bool getResolveA() const { return myResolveA; }
    void setResolveA(bool val) { myResolveA = val; }
    bool opResolveA(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getResolveA();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "resolvea", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getGroupB() const { return myGroupB; }
    void setGroupB(const UT_StringHolder & val) { myGroupB = val; }
    UT_StringHolder opGroupB(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGroupB();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "bgroup", cookparms.getCookTime(), 0);
        return result;
    }
    BSurface getBSurface() const { return BSurface(myBSurface); }
    void setBSurface(BSurface val) { myBSurface = int64(val); }
    BSurface opBSurface(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBSurface();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "bsurface", cookparms.getCookTime(), 0);
        return BSurface(result);
    }
    bool getResolveB() const { return myResolveB; }
    void setResolveB(bool val) { myResolveB = val; }
    bool opResolveB(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getResolveB();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "resolveb", cookparms.getCookTime(), 0);
        return result;
    }
    BooleanOp getBooleanOp() const { return BooleanOp(myBooleanOp); }
    void setBooleanOp(BooleanOp val) { myBooleanOp = int64(val); }
    BooleanOp opBooleanOp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBooleanOp();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "booleanop", cookparms.getCookTime(), 0);
        return BooleanOp(result);
    }
    SubtractChoices getSubtractChoices() const { return SubtractChoices(mySubtractChoices); }
    void setSubtractChoices(SubtractChoices val) { mySubtractChoices = int64(val); }
    SubtractChoices opSubtractChoices(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getSubtractChoices();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "subtractchoices", cookparms.getCookTime(), 0);
        return SubtractChoices(result);
    }
    ShatterChoices getShatterChoices() const { return ShatterChoices(myShatterChoices); }
    void setShatterChoices(ShatterChoices val) { myShatterChoices = int64(val); }
    ShatterChoices opShatterChoices(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getShatterChoices();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "shatterchoices", cookparms.getCookTime(), 0);
        return ShatterChoices(result);
    }
    bool getOpenCurvesOnly() const { return myOpenCurvesOnly; }
    void setOpenCurvesOnly(bool val) { myOpenCurvesOnly = val; }
    bool opOpenCurvesOnly(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getOpenCurvesOnly();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "opencurvesonly", cookparms.getCookTime(), 0);
        return result;
    }
    bool getGenerateAASeams() const { return myGenerateAASeams; }
    void setGenerateAASeams(bool val) { myGenerateAASeams = val; }
    bool opGenerateAASeams(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGenerateAASeams();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "generateaaseams", cookparms.getCookTime(), 0);
        return result;
    }
    bool getGenerateBBSeams() const { return myGenerateBBSeams; }
    void setGenerateBBSeams(bool val) { myGenerateBBSeams = val; }
    bool opGenerateBBSeams(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGenerateBBSeams();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "generatebbseams", cookparms.getCookTime(), 0);
        return result;
    }
    bool getGenerateABSeams() const { return myGenerateABSeams; }
    void setGenerateABSeams(bool val) { myGenerateABSeams = val; }
    bool opGenerateABSeams(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getGenerateABSeams();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "generateabseams", cookparms.getCookTime(), 0);
        return result;
    }
    WindingOp getWindingOp() const { return WindingOp(myWindingOp); }
    void setWindingOp(WindingOp val) { myWindingOp = int64(val); }
    WindingOp opWindingOp(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getWindingOp();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "windingop", cookparms.getCookTime(), 0);
        return WindingOp(result);
    }
    bool getMergeNbrs() const { return myMergeNbrs; }
    void setMergeNbrs(bool val) { myMergeNbrs = val; }
    bool opMergeNbrs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getMergeNbrs();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "mergenbrs", cookparms.getCookTime(), 0);
        return result;
    }
    Detriangulate getDetriangulate() const { return Detriangulate(myDetriangulate); }
    void setDetriangulate(Detriangulate val) { myDetriangulate = int64(val); }
    Detriangulate opDetriangulate(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDetriangulate();
        int64 result;
        OP_Utils::evalOpParm(result, thissop, "detriangulate", cookparms.getCookTime(), 0);
        return Detriangulate(result);
    }
    bool getRemoveInlinePoints() const { return myRemoveInlinePoints; }
    void setRemoveInlinePoints(bool val) { myRemoveInlinePoints = val; }
    bool opRemoveInlinePoints(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRemoveInlinePoints();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "removeinlinepoints", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUniqueSeams() const { return myUniqueSeams; }
    void setUniqueSeams(bool val) { myUniqueSeams = val; }
    bool opUniqueSeams(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUniqueSeams();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "uniqueseams", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAxAPolys() const { return myUseAxAPolys; }
    void setUseAxAPolys(bool val) { myUseAxAPolys = val; }
    bool opUseAxAPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAxAPolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useaxapolys", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAxAPolys() const { return myAxAPolys; }
    void setAxAPolys(const UT_StringHolder & val) { myAxAPolys = val; }
    UT_StringHolder opAxAPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAxAPolys();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "axapolys", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAxBPolys() const { return myUseAxBPolys; }
    void setUseAxBPolys(bool val) { myUseAxBPolys = val; }
    bool opUseAxBPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAxBPolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useaxbpolys", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAxBPolys() const { return myAxBPolys; }
    void setAxBPolys(const UT_StringHolder & val) { myAxBPolys = val; }
    UT_StringHolder opAxBPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAxBPolys();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "axbpolys", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAxAList() const { return myUseAxAList; }
    void setUseAxAList(bool val) { myUseAxAList = val; }
    bool opUseAxAList(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAxAList();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useaxalist", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAxAList() const { return myAxAList; }
    void setAxAList(const UT_StringHolder & val) { myAxAList = val; }
    UT_StringHolder opAxAList(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAxAList();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "axalist", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAxBList() const { return myUseAxBList; }
    void setUseAxBList(bool val) { myUseAxBList = val; }
    bool opUseAxBList(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAxBList();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useaxblist", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAxBList() const { return myAxBList; }
    void setAxBList(const UT_StringHolder & val) { myAxBList = val; }
    UT_StringHolder opAxBList(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAxBList();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "axblist", cookparms.getCookTime(), 0);
        return result;
    }
    bool getCollapseTinyEdges() const { return myCollapseTinyEdges; }
    void setCollapseTinyEdges(bool val) { myCollapseTinyEdges = val; }
    bool opCollapseTinyEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getCollapseTinyEdges();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "collapsetinyedges", cookparms.getCookTime(), 0);
        return result;
    }
    fpreal64 getLengthThreshold() const { return myLengthThreshold; }
    void setLengthThreshold(fpreal64 val) { myLengthThreshold = val; }
    fpreal64 opLengthThreshold(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getLengthThreshold();
        fpreal64 result;
        OP_Utils::evalOpParm(result, thissop, "lengththreshold", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAPolys() const { return myUseAPolys; }
    void setUseAPolys(bool val) { myUseAPolys = val; }
    bool opUseAPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAPolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useapolys", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAPolys() const { return myAPolys; }
    void setAPolys(const UT_StringHolder & val) { myAPolys = val; }
    UT_StringHolder opAPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAPolys();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "apolys", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAInsideB() const { return myUseAInsideB; }
    void setUseAInsideB(bool val) { myUseAInsideB = val; }
    bool opUseAInsideB(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAInsideB();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useainsideb", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAInsideB() const { return myAInsideB; }
    void setAInsideB(const UT_StringHolder & val) { myAInsideB = val; }
    UT_StringHolder opAInsideB(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAInsideB();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "ainsideb", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAOutsideB() const { return myUseAOutsideB; }
    void setUseAOutsideB(bool val) { myUseAOutsideB = val; }
    bool opUseAOutsideB(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAOutsideB();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useaoutsideb", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAOutsideB() const { return myAOutsideB; }
    void setAOutsideB(const UT_StringHolder & val) { myAOutsideB = val; }
    UT_StringHolder opAOutsideB(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAOutsideB();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "aoutsideb", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseBPolys() const { return myUseBPolys; }
    void setUseBPolys(bool val) { myUseBPolys = val; }
    bool opUseBPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseBPolys();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usebpolys", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getBPolys() const { return myBPolys; }
    void setBPolys(const UT_StringHolder & val) { myBPolys = val; }
    UT_StringHolder opBPolys(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBPolys();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "bpolys", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseBInsideA() const { return myUseBInsideA; }
    void setUseBInsideA(bool val) { myUseBInsideA = val; }
    bool opUseBInsideA(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseBInsideA();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usebinsidea", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getBInsideA() const { return myBInsideA; }
    void setBInsideA(const UT_StringHolder & val) { myBInsideA = val; }
    UT_StringHolder opBInsideA(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBInsideA();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "binsidea", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseBOutsideA() const { return myUseBOutsideA; }
    void setUseBOutsideA(bool val) { myUseBOutsideA = val; }
    bool opUseBOutsideA(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseBOutsideA();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useboutsidea", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getBOutsideA() const { return myBOutsideA; }
    void setBOutsideA(const UT_StringHolder & val) { myBOutsideA = val; }
    UT_StringHolder opBOutsideA(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBOutsideA();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "boutsidea", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseABOverlap() const { return myUseABOverlap; }
    void setUseABOverlap(bool val) { myUseABOverlap = val; }
    bool opUseABOverlap(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseABOverlap();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useaboverlap", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getABOverlap() const { return myABOverlap; }
    void setABOverlap(const UT_StringHolder & val) { myABOverlap = val; }
    UT_StringHolder opABOverlap(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getABOverlap();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "aboverlap", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAPieces() const { return myUseAPieces; }
    void setUseAPieces(bool val) { myUseAPieces = val; }
    bool opUseAPieces(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAPieces();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useaonlypieces", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAPieces() const { return myAPieces; }
    void setAPieces(const UT_StringHolder & val) { myAPieces = val; }
    UT_StringHolder opAPieces(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAPieces();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "aonlypieces", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseBPieces() const { return myUseBPieces; }
    void setUseBPieces(bool val) { myUseBPieces = val; }
    bool opUseBPieces(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseBPieces();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usebonlypieces", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getBPieces() const { return myBPieces; }
    void setBPieces(const UT_StringHolder & val) { myBPieces = val; }
    UT_StringHolder opBPieces(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBPieces();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "bonlypieces", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseABPieces() const { return myUseABPieces; }
    void setUseABPieces(bool val) { myUseABPieces = val; }
    bool opUseABPieces(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseABPieces();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useabpieces", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getABPieces() const { return myABPieces; }
    void setABPieces(const UT_StringHolder & val) { myABPieces = val; }
    UT_StringHolder opABPieces(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getABPieces();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "abpieces", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseAASeamEdges() const { return myUseAASeamEdges; }
    void setUseAASeamEdges(bool val) { myUseAASeamEdges = val; }
    bool opUseAASeamEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseAASeamEdges();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useaaseamedges", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getAASeamEdges() const { return myAASeamEdges; }
    void setAASeamEdges(const UT_StringHolder & val) { myAASeamEdges = val; }
    UT_StringHolder opAASeamEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getAASeamEdges();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "aaseamedges", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseBBSeamEdges() const { return myUseBBSeamEdges; }
    void setUseBBSeamEdges(bool val) { myUseBBSeamEdges = val; }
    bool opUseBBSeamEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseBBSeamEdges();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "usebbseamedges", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getBBSeamEdges() const { return myBBSeamEdges; }
    void setBBSeamEdges(const UT_StringHolder & val) { myBBSeamEdges = val; }
    UT_StringHolder opBBSeamEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getBBSeamEdges();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "bbseamedges", cookparms.getCookTime(), 0);
        return result;
    }
    bool getUseABSeamEdges() const { return myUseABSeamEdges; }
    void setUseABSeamEdges(bool val) { myUseABSeamEdges = val; }
    bool opUseABSeamEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getUseABSeamEdges();
        bool result;
        OP_Utils::evalOpParm(result, thissop, "useabseamedges", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getABSeamEdges() const { return myABSeamEdges; }
    void setABSeamEdges(const UT_StringHolder & val) { myABSeamEdges = val; }
    UT_StringHolder opABSeamEdges(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getABSeamEdges();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "abseamedges", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector2I getDepthInA() const { return myDepthInA; }
    void setDepthInA(UT_Vector2I val) { myDepthInA = val; }
    UT_Vector2I opDepthInA(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDepthInA();
        UT_Vector2I result;
        OP_Utils::evalOpParm(result, thissop, "adepth", cookparms.getCookTime(), 0);
        return result;
    }
    UT_Vector2I getDepthInB() const { return myDepthInB; }
    void setDepthInB(UT_Vector2I val) { myDepthInB = val; }
    UT_Vector2I opDepthInB(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDepthInB();
        UT_Vector2I result;
        OP_Utils::evalOpParm(result, thissop, "bdepth", cookparms.getCookTime(), 0);
        return result;
    }

private:
    UT_StringHolder myGroupA;
    int64 myASurface;
    bool myResolveA;
    UT_StringHolder myGroupB;
    int64 myBSurface;
    bool myResolveB;
    int64 myBooleanOp;
    int64 mySubtractChoices;
    int64 myShatterChoices;
    bool myOpenCurvesOnly;
    bool myGenerateAASeams;
    bool myGenerateBBSeams;
    bool myGenerateABSeams;
    int64 myWindingOp;
    bool myMergeNbrs;
    int64 myDetriangulate;
    bool myRemoveInlinePoints;
    bool myUniqueSeams;
    bool myUseAxAPolys;
    UT_StringHolder myAxAPolys;
    bool myUseAxBPolys;
    UT_StringHolder myAxBPolys;
    bool myUseAxAList;
    UT_StringHolder myAxAList;
    bool myUseAxBList;
    UT_StringHolder myAxBList;
    bool myCollapseTinyEdges;
    fpreal64 myLengthThreshold;
    bool myUseAPolys;
    UT_StringHolder myAPolys;
    bool myUseAInsideB;
    UT_StringHolder myAInsideB;
    bool myUseAOutsideB;
    UT_StringHolder myAOutsideB;
    bool myUseBPolys;
    UT_StringHolder myBPolys;
    bool myUseBInsideA;
    UT_StringHolder myBInsideA;
    bool myUseBOutsideA;
    UT_StringHolder myBOutsideA;
    bool myUseABOverlap;
    UT_StringHolder myABOverlap;
    bool myUseAPieces;
    UT_StringHolder myAPieces;
    bool myUseBPieces;
    UT_StringHolder myBPieces;
    bool myUseABPieces;
    UT_StringHolder myABPieces;
    bool myUseAASeamEdges;
    UT_StringHolder myAASeamEdges;
    bool myUseBBSeamEdges;
    UT_StringHolder myBBSeamEdges;
    bool myUseABSeamEdges;
    UT_StringHolder myABSeamEdges;
    UT_Vector2I myDepthInA;
    UT_Vector2I myDepthInB;

};
