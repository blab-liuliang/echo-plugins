#ifndef __UI_Value__
#define __UI_Value__

#include "UI_API.h"
#include "UI_Object.h"
#include <SYS/SYS_Types.h>
#include <iosfwd>
#include <deque>

/*
 *  A UI_Value is a utility class which maintains a single value of
 *  variable type and provides conversions between types.
 */

enum UI_ValueType {
    UI_VALUE_FLOAT,
    UI_VALUE_INTEGER,
    UI_VALUE_STRING,
    UI_VALUE_FLOAT_ARRAY,
    UI_VALUE_INT_ARRAY,
    UI_VALUE_STRING_ARRAY,
    UI_VALUE_POINTER
};

enum UI_Reason {
    UI_NO_REASON,	    // event was likely explicitly generated
    UI_VALUE_CHANGED,	    // mouse up
    UI_VALUE_ACTIVE,	    // mouse drag
    UI_VALUE_START,	    // mouse down
    UI_VALUE_NEW,	    // dependent added to UI_Value
    UI_VALUE_RANGE_CHANGED, // UI_ScrollValue range changed
    UI_VALUE_PICKED,	    // quick mouse down and release without drag
    UI_VALUE_LOCATED,	    // mouse hover (only if wantsLocates() is true)
    UI_VALUE_ITEMS_CHANGED  // only generated by UI_StringList (and subclasses)
};

#define UI_STEP_BIG	4

enum UI_StepType {
    UI_STEP_INCREMENT = 1,
    UI_STEP_DECREMENT = 2,
    UI_STEP_INCREMENT_BIG = (UI_STEP_INCREMENT | UI_STEP_BIG),
    UI_STEP_DECREMENT_BIG = (UI_STEP_DECREMENT | UI_STEP_BIG)
};

class UI_Event;
class UT_Color;
class UT_String;
class UT_StringArray;
class UT_StringHolder;
class UT_StringRef;
class UT_IStream;
class ui_Client;

//====================================================================

class UI_API UI_Value : public UI_Object
{
public:
    UI_Value();
    explicit UI_Value(int32 i);
    explicit UI_Value(int64 i);
    explicit UI_Value(fpreal32 f);
    explicit UI_Value(fpreal64 f);
    explicit UI_Value(fpreal32 fp[], exint n);
    explicit UI_Value(fpreal64 dp[], exint n);
    explicit UI_Value(int32 ip[], exint n);
    explicit UI_Value(int64 ip[], exint n);
    explicit UI_Value(const UT_StringArray &ssp);
    explicit UI_Value(const char *s);
    explicit UI_Value(const UI_Value &v);

    virtual ~UI_Value();

    virtual void setValue(int32 i);
    virtual void setValue(int64 i);
    virtual void setValue(fpreal64 f);
    virtual void setValue(fpreal64 f, exint n);
    virtual void setValue(int32 i, exint n);
    virtual void setValue(int64 i, exint n);
    virtual void setValue(const fpreal32 fp[], exint n);
    virtual void setValue(const fpreal64 dp[], exint n);
    virtual void setValue(const int32 ip[], exint n);
    virtual void setValue(const int64 ip[], exint n);
    virtual void setValue(const UT_StringArray &ssp);
    virtual void setValue(const char *s);
    virtual void setValue(const UI_Value &v);
	    void setValue(const UT_Color &c);
	    void setPointerValue(void *p);
	    void stringPrintf(const char *fmt, ...);

    virtual void changed(UI_Object *by,
			 UI_Reason reason = UI_VALUE_CHANGED,
			 UI_DeviceEvent	*state = 0);
    //  This method is similar to "changed" but it triggers the callback events
    //  immediately (bypassing the event queue). It also only notifies the
    //  objects that have added interests in this value. Not the immediate
    //  dependents. **This should only be used in special circumstances.**
    void triggerImmediate(UI_Object *by,
			  UI_Reason reason = UI_VALUE_CHANGED,
			  UI_DeviceEvent *state = 0);
    //  This method is similar to "triggerImmediate" but it notifies the
    //  immediate dependents rather than the objects that have added interests
    //  in this value.  **This should only be used in special circumstances.**
    void triggerDependents(UI_Object *by,
			   UI_Reason reason = UI_VALUE_CHANGED,
			   UI_DeviceEvent *state = 0);

    virtual void enable(bool state); // Sends enable event to dependents
    virtual void visible(bool state); // Sends visible event to dependents
    virtual void override(bool state, int);// Sends override event to dependents
    virtual void open(bool state);	// Sends open/close event to dependents
    virtual void refresh();		// Sends redraw in place events

    // This ugly hack attempts to determine the open state of UI_Feel clients
    // which are open. It returns true only if *any* of them are open.
    bool	 areAnyFeelClientsOpen() const;

    virtual void handleEvent(UI_Event *event);
    virtual void deleteReferences(UI_Object *to_whom);

    virtual void setSteps(fpreal mysmall, fpreal large);
    virtual void setRange(fpreal min, fpreal max);
    virtual void getRange(fpreal *min, fpreal *max) const;

    virtual void rangeCheck();
    virtual int	 step(UI_StepType how);

    int		save(std::ostream &os) const;
    bool	load(UT_IStream &is);

    void setFormat(const char *fmt) { myFormat = fmt; }
    const char *getFormat() const { return myFormat; }

    void getValue(int32 *ip) const;
    void getValue(int64 *ip) const;
    void getValue(fpreal32 *fp) const;
    void getValue(fpreal64 *fp) const;
    void getValue(fpreal32 *fp, exint n) const;
    void getValue(fpreal64 *dp, exint n) const;
    void getValue(int32 *ip, exint n) const;
    void getValue(int64 *ip, exint n) const;
    void getValue(char *sp, exint bufsize) const;
    void getValue(char *sp, exint bufsize, const char *format) const;
    void getValue(UT_String &s) const;
    void getValue(UT_StringHolder &s) const;
    void getValue(UT_StringArray &ssp, exint n) const;
    void getValue(UI_Value &v) const;
    void getValue(UT_Color &color) const;
    void getValue(void **pp) const;

    void getArrayValue(fpreal *d, exint index) const;
    void getArrayValue(int32 *d, exint index) const;
    void getArrayValue(int64 *d, exint index) const;
    exint getArrayLength() const;

    UI_ValueType getType() const { return type; }
    virtual int	 isVector() const { return 0; }

    void addInterest(UI_Object *client, UI_EventMethod method,
		     bool check_dup = false);
    void addPriorityInterest(UI_Object *client, UI_EventMethod method,
			     bool check_dup = false);
    bool hasInterest(UI_Object *in, UI_EventMethod method);
    bool hasInterest(UI_Object *obj);
    void removeInterest(UI_Object *in, UI_EventMethod method);
    void removeInterest(UI_Object *client);
    void removeAllInterests();

    //  Note: setString sets the char * value whereas setValue(char *) does
    //	  a strdup. (ie UI_Value will own the string you set with setString)
    const char	*getString() const;	// Short cuts for string manipulation.
    void	 setString(char *sp);
    char	*stealString();		// Take the string away from the value.
    
    // Expand environment variables and, on OSX and Linux, the ~ character.
    void	 expandEnvironment();

    operator const char *() const;
    operator bool() const;
    operator int32() const;
    operator int64() const;
    operator fpreal32() const;
    operator fpreal64() const;
    operator void *() const;

    void operator=(int32 i)             { setValue(i); }
    void operator=(int64 i)             { setValue(i); }
    void operator=(fpreal32 f)          { setValue(f); }
    void operator=(fpreal64 f)          { setValue(f); }
    void operator=(const char *s)       { setValue(s); }
    void operator=(const UI_Value &v)   { setValue(v); }
    void operator=(const UT_Color &c)   { setValue(c); }

    bool operator==(const UI_Value &v) const;
    bool operator==(const fpreal32 fp[]) const;
    bool operator==(const fpreal64 fp[]) const;
    bool operator==(const int32 ip[]) const;
    bool operator==(const int64 ip[]) const;
    bool operator==(const UT_StringArray &ssp) const;
    bool operator==(fpreal64 f) const;
    bool operator==(fpreal32 f) const;
    bool operator==(int32 i) const;
    bool operator==(int64 i) const;
    bool operator==(const char *s) const;

    virtual const char	*className() const;

    // Return the number of interests expressed in this value
    unsigned int	 getNumInterested() const;
    UI_Object		*getInterest(int index) const; 

    // Set to true to track 
    enum TraceLevel
    {
	TL_NONE,
	TL_EVENT,
	TL_VALUE
    };
    
    bool		 isTraced() const { return myTraceLevel != TL_NONE; }
    virtual void	 setTraceLevel(TraceLevel tl) { myTraceLevel = tl; }
    
protected:
    union {
        exint    i;
        fpreal   d;
        fpreal  *a;
        exint   *j;
        char    *s;
        char    **ss;
        void    *p;
    } value;
    const char		*myFormat;
    UI_ValueType	 type:4;
    TraceLevel		 myTraceLevel:2;

    void		 showTrace();
    
private:
    void		 init();
    void		 zap();

    void		 addMyInterest(UI_Object *client,
				       UI_EventMethod method,
				       bool check_dup,
				       bool priority);
    void 		 sendEventToInterests(UI_Object *by, UI_Event &event,
         		                      bool immediate);

    friend std::ostream &operator<<(std::ostream &os, const UI_Value &v)
                        {
                            v.save(os);
                            return os;
                        }
    
    typedef std::deque<ui_Client *> ui_ClientList;
    ui_ClientList::iterator ibegin() { return myInterests.begin(); }
    ui_ClientList::iterator iend() { return myInterests.end(); }
    
    ui_ClientList	 myInterests;
};

#endif
