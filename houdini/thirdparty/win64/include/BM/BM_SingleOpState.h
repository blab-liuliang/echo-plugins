/*
 * PROPRIETARY INFORMATION.  This software is proprietary to
 * Side Effects Software Inc., and is not to be reproduced,
 * transmitted, or disclosed in any way without written permission.
 *
 * NAME:	BM_SingleOpState.h
 *
 * COMMENTS:
 *	This is an "automated" state that links handles with op
 *	parameters.
 */

#ifndef __BM_SingleOpState_H__
#define __BM_SingleOpState_H__

#include "BM_API.h"
#include <UT/UT_IntArray.h>
#include <UT/UT_String.h>
#include <UT/UT_SymbolTable.h>
#include <PRM/PRM_Value.h>
#include <PI/PI_ResourceManager.h>
#include "BM_OpState.h"

class OP_Operator;
class OP_Node;
class BM_OpHandleLink;
class OPUI_Dialog;

class BM_UndoSetNode;

class BM_API BM_SingleOpState : public BM_OpState
{
    friend class BM_UndoSetNode;

public:
    // Class constructor and destructor.
	     BM_SingleOpState(BM_OpView &view, PI_StateTemplate &templ,
			      BM_SceneManager *scene, 
			      const char *cursor = BM_DEFAULT_CURSOR);
    virtual ~BM_SingleOpState(void);

    // Enter or exit this state.
    virtual int 	 enter(BM_SimpleState::BM_EntryType how);
    virtual void	 exit (void);
    virtual void	 restart(void);

    // Similar to enter, but totally from scratch. At this level, it's the
    // same as doing an enter. It cannot be entered in volatile mode.
    // We can start generating either in inline (insert) mode
    // or in branching-off mode. The generation mode is relevant only when
    // generating ops in a network. Some states reuse existing ops when
    // possible instead of generating new ones.  A request can be made for
    // new ops here, but it is up to the individual state to interpret it.
    virtual int 	 generate(BM_SimpleState::BM_EntryType how,
				  bool insertmode = true,
				  bool requestnew = false);


    // Stop the generation process.
    virtual void	 stopGenerating (void);

    // See how you can handle a node being deleted. If it's an implicit
    // node we might be OK. Return 0 if we can handle it, -1 if we must
    // be exited or restarted from scratch.
    virtual int		 handleNodeDeleted(OP_Node &node);

    virtual int		 hasOpNode(const OP_Node &node) const;

    // The name and type of this class:
    virtual const char	*className() const;

    // Allow the state to access the node so that it can process information.
    OP_Node		*getNode(void) const;

    virtual int		 getToolboxCount() const;
    virtual UI_Feel 	*getToolbox(int index) const;

protected:
    // Provide the Op to work with. The criteria for which OP to use will
    // be specific to each network type. This method does NOT overwrite
    // the myOpNode pointer.
    virtual OP_Node	*getChosenOp(void) const  = 0;

    // This method is called whenever the button is pressed to turn a PI
    // on or off.  It does not need to redraw the workbench.
    virtual void	 makePIVisible(int pi_idx, int onoff);

    // Begin generating (and maybe finish too if you can od it quickly).
    // This method is called from generate() and is currently empty. You may
    // not need to redefine it at all.
    virtual void	 doGenerate(void);

    // Build an OP that matches our name or the name passed into the function
    // if not nil. This does not set myOpNode.
    OP_Node		*createNode(const char *optype  = 0,
				    const char *nettype = 0,
				    OP_Network *parent	= 0,
				    int explicitly      = 1);

    // return the node name required for createNode
    virtual const char* getCreateNodeName() const
    {
	return getName();
    }

    // Set the work node. This will detach and clean up after the previous
    // node should there be one.
    // setNode is virtual because the state may want to do different
    // things when the node is set, like saving the look of PIs.
    virtual void	 setNode(OP_Node *node);
    void		 setNodeId(int id);

    // Make this node current. Derived classes may choose to do other things.
    virtual void	 setNodeFlags(OP_Node &node);

    // Disable the footprint flag of the current node if it has outputs
    virtual void	 clearChosenNodeFlags();

    // The user can dynamically change the bindings from the textport
    // We need to refresh the current handle in the viewports 
    // cause they could be affected.
    virtual void	 refreshBindings(int id, const char *op_type);
    virtual void	 refreshSettings(int id, const char *op_type);

    // Access to the saved node, ie the node that we may have stashed away
    // on a restart():
    OP_Node		*savedNode(void) const { return mySavedOpNode; }
    void		 savedNode(OP_Node *n)
			 {
			     clearRestartInfo();
			     mySavedOpNode = n;
			 }

    // Generate the parts of the dialog needed before the PI's are created.
    virtual void	 initializeDialogs();
    // Generate the parts of the dialog that can only be created after all the
    // PI's are created.
    virtual void	 completeDialogs();

    // Return 1 if the node is generated by a state that matches our name,
    // or if the node's name matches our name:
    virtual int          matchesNode(OP_Node &node) const;

    // Removes all the dialogs including our locally defined toolbox.
    virtual void	 removeAllDialogs();

    // callback that is called when a dialog is deleted. It clears
    // any pointers that may become stale.
    virtual void	 handleDialogDeleted( OPUI_Dialog *dialog );

    // The method gets called when reselecting and should be overridden to
    // add any undos needed to undo reselection.
    virtual void	 addAnyReselectionUndos();

    // Return false from this function to prevent our node from having its
    // inputs disconnected when we restart this state. Used by DOP data
    // states, which want to leave inputs connected. The default
    // implementation returns true.
    virtual bool	 disconnectInputsOnRestart() const;
    
    void		 clearOpHandleLinks();

    // Override this to return false if undesired
    virtual bool	 allowOpMaxExportToDialog() const   { return true; }

private:
    // Create, link, attach, position, push, and activate the PI's.
    void		 createOpHandleLinks();

    // Link the parms of the op to all the parms of the PI's.
    // This method is called from createOpHandleLinks.
    void		 linkAllParms();

    // Link a given (non-input) op parm to a PI, and create the PI if it
    // doesn't already exist.  This method is called from linkNonInputParms.
    int			 linkSingleParm(const PI_BindingHandleInfo &bhi,
					const PI_BindingParmInfo &bpi,
					OP_Operator &op_type);

    BM_OpHandleLink *	 createSingleOpHandleLink(
					const PI_BindingHandleInfo &bhi);

    void		 clearRestartInfo();
    void		 saveRestartInfo(const OP_Node &node,
					 const OP_NodeList &implicits);
    bool		 restoreRestartInfo(OP_Node &node);

protected:
    // Delete all the PI's.  This method ensures that all interests in the
    // PI's are removed and they are all deactivated.
    void		 deleteOpHandleLinks();

    // data
    int			 myOpNodeId;
    OP_Node		*mySavedOpNode;
    OPUI_Dialog		*myOpToolbox;
    UT_SymbolMap<int>	 myHandleTable;

    // As long as this state is alive, remember what PIs are visible
    UT_BitArray		 myHandleVisibility;

    UT_String		 myRestartInfoFile;
    UT_IntArray		 myRestartOpInputs;
    int			 myRestartOpId;
};

#endif
