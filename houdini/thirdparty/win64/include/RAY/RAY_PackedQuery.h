/*
 * PROPRIETARY INFORMATION.  This software is proprietary to
 * Side Effects Software Inc., and is not to be reproduced,
 * transmitted, or disclosed in any way without written permission.
 *
 * NAME:	RAY_PackedQuery.h (RAY Library, C++)
 *
 * COMMENTS:
 */

#ifndef __RAY_PackedQuery__
#define __RAY_PackedQuery__

#include "RAY_API.h"
#include <UT/UT_StringHolder.h>
#include <GT/GT_Handles.h>

class GEO_Primitive;
class RAY_Procedural;
class VPRM_Data;

/// When a new procedural is created from a packed primitive, the geometry
/// generated by the procedural should be able to access the attributes from
/// the packed primitive using the @c renderstate("packed:NAME") method.
///
/// This class is used to implement the packed query for a procedural.  Once
/// you create a @c RAY_PackedQuery, you can assign it to the procedural using
/// @c RAY_Procedural::setPackedQuery().
class RAY_API RAY_PackedQuery
{
public:
    using KeyType = int64;

    SYS_FORCE_INLINE static bool	isValidKey(KeyType k) { return k != 0; }

    /// Create a packed query for the procedural, possibly inheriting from 
    RAY_PackedQuery()
	: myInheritFrom()
    {
    }
    virtual ~RAY_PackedQuery();

    /// Create a query struct for a primitive.
    static RAY_PackedQuery	*create(const GEO_Primitive *prim);
    /// Create a query struct for a set of GT attributes.  The inherit_from
    /// should either be the current query id or a -1.
    static RAY_PackedQuery	*create(const GT_AttributeListHandle &detail,
					const GT_AttributeListHandle &uniform,
					exint uniform_index,
					const GT_AttributeListHandle &primdet,
					const GT_AttributeListHandle &packinfo);

    /// Try to import the packed setting of the given name (the "packed:" prefix
    /// is stripped off).  For example, "Cd" (not "packed:Cd")
    /// This can be specialized for @code
    ///  T in {int32, int64, fpreal32, fpreal64, UT_StringHolder }
    /// @endcode
    template <typename T>
    bool	import(const UT_StringRef &name, T *val, int size) const
    {
	if (doImport(name, val, size))
	    return true;
	const RAY_PackedQuery	*parent = find(myInheritFrom);
	return parent ? parent->import(name, val, size) : false;
    }

    /// Set the inheritance for the query.  If settings aren't found on this
    /// query, we search the parent (if there is one).
    void	setInheritFrom(const KeyType parent) { myInheritFrom = parent; }

protected:
    /// @{
    /// Import data from the packed primitive
    virtual bool	doImport(const UT_StringRef &name,
				int32 *val, int n) const = 0;
    virtual bool	doImport(const UT_StringRef &name,
				int64 *val, int n) const = 0;
    virtual bool	doImport(const UT_StringRef &name,
				fpreal32 *val, int n) const = 0;
    virtual bool	doImport(const UT_StringRef &name,
				fpreal64 *val, int n) const = 0;
    virtual bool	doImport(const UT_StringRef &name,
				UT_StringHolder *val, int n) const = 0;
    /// @}
private:
    const RAY_PackedQuery	*find(KeyType id) const;

    KeyType	myInheritFrom;
};

#endif
