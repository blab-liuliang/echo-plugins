/*
 * PROPRIETARY INFORMATION.  This software is proprietary to
 * Side Effects Software Inc., and is not to be reproduced,
 * transmitted, or disclosed in any way without written permission.
 *
 * NAME:	GU_Cookie.h ( GU Library, C++)
 *
 * COMMENTS:  The infamous Cookie operator.  This allows you to
 *		crease or cut two gdps groups with each other.
 */

#ifndef __GU_Cookie__
#define __GU_Cookie__

#include "GU_API.h"
#include <GA/GA_Edge.h>
#include <GA/GA_EdgeMap.h>
#include <GA/GA_Types.h>
#include <UT/UT_Array.h>
#include <UT/UT_Vector3.h>
#include <UT/UT_VectorTypes.h>

class GU_Detail;
class GU_RayIntersect;
class GA_PrimitiveGroup;
class GA_PointGroup;
class GA_ElementWranglerCache;
class GEO_PrimPoly;
class GA_WorkVertexBuffer;
class UT_SampleQuad2D;
class UT_SampleTri2D;

class guEdgeHashEntry;
class guTrimInfo;
class guTrimProjection;
class GU_API guIsectVal
{
public:
    int		dir;	// 1 if in direction of normal, else -1.
    UT_Vector3	pos;
    float	loc;	// Where we are on the plane/plane isect line.
};

class GU_API GU_Cookie
{
public:
    GU_Cookie();
    virtual ~GU_Cookie();

    GU_Detail  *getDetail() const { return myGdp; }

    void setGroups(const GA_PrimitiveGroup *agrp,
		   const GA_PrimitiveGroup *bgrp,
		   GA_PointGroup *aptgrp,
		   GA_PointGroup *bptgrp)
    {
	myGrpA = agrp;
	myGrpB = bgrp;
	myPtGrpA = aptgrp;
	myPtGrpB = bptgrp;
    }
    float	getTolerance() { return myTol; }
    void	setTolerance(float tol) { myTol = tol; }
    void	setAutoJoin(int aj) { myAutoJoin = aj; }

    /// Invoke the cookie operation.
    ///
    /// The group of polygons to cookie must be setup with the setGroups
    /// function.
    ///
    /// The [a|b][in|out|overlap]grps are the primitive groups to classify
    /// each clipped polygon piece into.
    ///
    /// If a set of connected polygons doesn't intersect, and the insidetest
    /// is enabled, the insidedness of the polygons will be determined by
    /// sending a ray with the winding rule.
    ///
    /// If generatecrease is set, instead of clipping the polygons, the line
    /// segments generated by poly-poly intersection will be generated.
    void	cookie(GU_Detail &gdp,
		       int generatecrease,
		       GA_PrimitiveGroup &aingrp,
		       GA_PrimitiveGroup &aoutgrp,
		       GA_PrimitiveGroup &aoverlapgrp,
		       int aclosed,
		       GA_PrimitiveGroup &bingrp,
		       GA_PrimitiveGroup &boutgrp,
		       GA_PrimitiveGroup &boverlapgrp,
		       int bclosed,
		       int insidetest);


    // The following are internal functions.

    /// The call back from intersection tests:
    /// The two indices are the primitive numbers to intersect.
    void	performIsect(int primIdA, int primIdB);

    /// This adds all the isects of the second polygon into the trim
    /// list of the first:
    void	buildTrimSegments(GEO_PrimPoly *dst,
				  GEO_PrimPoly *src);
    void	buildTrimSegmentsCoplanar(GEO_PrimPoly *dst,
					  GEO_PrimPoly *src,
					  bool reverse);


    void	addPointToGroup(GA_Offset ptoff, GEO_PrimPoly *poly);

    /// The edge is poly(edge-1) to poly(edge).
    GA_Offset   createEdgeVertex(GA_WorkVertexBuffer &vbuf,
				guTrimInfo *base, int edge, float t, int dir);

    GEO_PrimPoly *createPoly(guTrimInfo *base,
			     const UT_Array<GA_Offset> &vtxes,
			     bool closed,
			     bool preserve_groups = true);

    /// Punches a hole in the polygon base with the polygon hole.  The
    /// appropriate bridges are formed.
    void	punchHole(GEO_PrimPoly *base, GEO_PrimPoly *hole);


    UT_IntArray *buildConnectivityGraph();

    void	classifyPolygons(const GA_PrimitiveGroup &originalgrp,
			         GA_PrimitiveGroup &ingrp,
				 GA_PrimitiveGroup &outgrp,
				 GA_PrimitiveGroup &overlapgrp,
				 UT_IntArray *edges,
				 const GA_PrimitiveGroup &othergrp,
				 GU_RayIntersect *&inter,
				 bool insidetest,
				 bool inter_closed);

    /// @private
    GA_Offset   createInteriorVertex(GA_WorkVertexBuffer &vbuf,
				guTrimInfo *base,
				const UT_Vector3 &pt);
protected:
    GU_Detail			*myGdp;
    UT_Array<guTrimInfo *>	 myTrimInfo;
    GA_EdgeMap<guEdgeHashEntry *> *myEdgeTable;

    GA_ElementWranglerCache	*myWranglers;

    // We add all newly created points to each of these.  Points generated
    // from A primitives go to ptgrpa, those from B primitives to point
    // group B.
    GA_PointGroup		*myPtGrpA, *myPtGrpB;
    const GA_PrimitiveGroup	*myGrpA, *myGrpB;

    // Intersections within a polygon..
    // This is used by buildTrimSegments, but shared so don't need
    // to reallocate.
    UT_Array<guIsectVal>	myIsects;
    int				myAutoJoin;
    float			myTol;

private:
};

#endif
